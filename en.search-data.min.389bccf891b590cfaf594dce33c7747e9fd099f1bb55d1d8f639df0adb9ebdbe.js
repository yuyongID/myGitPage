'use strict';(function(){const indexCfg={cache:true};indexCfg.doc={id:'id',field:['title','content'],store:['title','href','section'],};const index=FlexSearch.create('balance',indexCfg);window.bookSearchIndex=index;index.add({'id':0,'href':'/myWiki/docs/docker/docker-learn/','title':"Docker Learn",'section':"Docker",'content':"docker learn test #  "});index.add({'id':1,'href':'/myWiki/docs/linux/','title':"Linux",'section':"Docs",'content':"linux系统中的Load： 是对当前CPU工作量的度量 (WikiPedia: the system load is a measure of the amount of work that a computer system is doing)。也有简单的说是进程队列的长度。\n什么样的Load average值要提高警惕 #   0.7 \u0026lt; load \u0026lt; 1: 此时是不错的状态，如果进来更多的汽车，你的马路仍然可以应付。 load = 1: 你的马路即将拥堵，而且没有更多的资源额外的任务，赶紧看看发生了什么吧。 load \u0026gt; 5: 非常严重拥堵，我们的马路非常繁忙，每辆车都无法很快的运行  性能指标 #  业务性能指标可以直观地反映被测系统的实际性能状况，常用的指标项有：\n 并发用户数 事务吞吐率（TPS/RPS） 事务平均响应时间 事务成功率  而系统资源性能指标，主要是反映整个系统环境的硬件资源使用情况，常用的指标包括：\n 服务器：CPU利用率、load 处理器队列长度、内存利用率、内存交换页面数、磁盘IO状态、网卡带宽使用情况等； 数据库：数据库连接数、数据库读写响应时长、数据库读写吞吐量等； 网络：网络吞吐量、网络带宽、网络缓冲池大小； 缓存（Redis）：静态资源缓存命中率、动态数据缓存命中率、缓存吞吐量等； 测试设备（压力发生器）：CPU利用率、处理器队列长度、内存利用率、内存交换页面数、磁盘IO状态、网卡带宽使用情况等。  "});index.add({'id':2,'href':'/myWiki/docs/media/','title':"Media",'section':"Docs",'content':"媒体直播相关 #  直播工作流程 #     架构端 工作流程     主播端 音视频采集、音视频编码、推流   流媒体服务端 直播流收集、音视频转码、直播流分发   观众端 拉流、音视频解码、音视频播放    端上推拉流测试方法 #     测试方法 推流端 拉流端     调参数测试 API测试：重点关注在外层比较难设置的API参数 API测试：重点关注在外层比较难设置的API参数；协议拉流测试：关注不同协议的播放情况；软硬解及切换测试：……   集成测试 QoS：当带宽受限的时候（表现为掉包或延时等），自动降低编码码率，使得观众可以观看更流畅；当带宽变得比较好时又可以升高编码码率，使用户可以观看更清晰的画面。软硬编码测试：…… QoS：在拉流SDK中可以理解成一个网络流畅度测试，包含的功能有秒开、音画同步、画质。播放器控制功能测试：……播放器动态参数测试：……   专项测试 美颜滤镜测试，画质评估测试，中断测试，性能测试，兼容测试，打点上报测试 性能测试，兼容性测试，中断测试，分辨率测试，打点上报测试    导致视频直播延时的原因 #   视频的编码格式导致。帧间压缩的视频编码，只能在收到关键帧 I 帧时候才能开始播放； 网络协议切片大小决定了首发数据的间隔。HLS 数据传播方式是传播 TS 文件，可能回直接导致 20～30s 的延时； 链路过长导致。服务器和客户端都会预留媒体缓存；  音视频媒体三个概念 #  帧率：1s 内包含多少数据， 影响画面流畅度。FPS\n码率：编码器每秒编出来的数据大小。kbps，Mbps，MBps。码率决定了视频文件的总大小，而编码是为了在这个大小之下保存最好的图像。\n分辨率：单位英寸上锁包含的像素点数。1080p，1080i\n如果一个媒体流的码率降低了，相对静态的视频可能还是相对清晰，但是通过增加大量的运动粒子，编码器就难以预测像素点的运动，而码率又不足以支撑画面。此时画面就会出现卡顿，大量滥竽充数的色块和马赛克。\n媒体编码 #  音频：AAC，opus\n视频：H.264\nH.264 会使用 I 帧（关键帧）、P 帧（向前参考帧）和 B 帧（双向参考帧）将视频数据压缩：\n I \u0026ndash;\u0026gt; B \u0026lt;\u0026ndash;\u0026gt; B \u0026lt;\u0026ndash; P I\n 图像组（Group of pictures，GOP）指定了视频帧的组织方式。移动端直播的 GOP 都会被设置成 1 ~ 4 秒，当然我们也可以使用更长的 GOP 降低占用的带宽。\n"});index.add({'id':3,'href':'/myWiki/docs/qa/','title':"Q\u0026 A",'section':"Docs",'content':"Python垃圾回收机制 #  Python GC主要使用引用计数（reference counting）来跟踪和回收垃圾。在引用计数的基础上，通过“标记-清除”（mark and sweep）解决容器对象可能产生的循环引用问题，通过“分代回收”（generation collection）以空间换时间的方法提高垃圾回收效率。\n1 引用计数 #  PyObject是每个对象必有的内容，其中ob_refcnt就是做为引用计数。当一个对象有新的引用时，它的ob_refcnt就会增加，当引用它的对象被删除，它的ob_refcnt就会减少.引用计数为0时，该对象生命就结束了。\n优点:\n 简单 实时性  缺点:\n 维护引用计数消耗资源 循环引用  2 标记-清除机制 #  基本思路是先按需分配，等到没有空闲内存的时候从寄存器和程序栈上的引用出发，遍历以对象为节点、以引用为边构成的图，把所有可以访问到的对象打上标记，然后清扫一遍内存空间，把所有没标记的对象释放。\n3 分代技术 #  分代回收的整体思想是：将系统中的所有内存块根据其存活时间划分为不同的集合，每个集合就成为一个“代”，垃圾收集频率随着“代”的存活时间的增大而减小，存活时间通常利用经过几次垃圾回收来度量。\nPython默认定义了三代对象集合，索引数越大，对象存活时间越长。\nreids 数据类型 #     数据类型 最大存储 特性 应用场景     string【SET runoobkey redis 】 512MB 可以包含任何数据,比如jpg图片或者序列化的对象,一个键最大能存储512M 常规key-value缓存应用。常规计数: 微博数, 粉丝数。   hash 【HMSET runoobkey name \u0026ldquo;redis tutorial\u0026rdquo; description \u0026ldquo;redis basic commands for caching\u0026rdquo; likes 20 visitors 23000】 每个 hash 可以存储 2^32 -1 键值对（40多亿） 适合存储对象,并且可以像数据库中update一个属性一样只修改某一项属性值(Memcached中需要取出整个字符串反序列化成对象修改完再序列化存回去) 存储、读取、修改用户属性。用户对象包含姓名，年龄，生日等信息   list 【LPUSH runoobkey redis】 列表最多可存储 2^32 - 1 元素（40多亿） 增删快,提供了操作某一段元素的API 1、最新消息排行等功能(比如朋友圈的时间线) 2、消息队列   set 【SADD runoobkey redis】 集合中最大的成员数为 232 - 1 1、添加、删除、查找的复杂度都是O(1) 2、为集合提供了求交集、并集、差集等操作 1、共同好友 2、利用唯一性,统计访问网站的所有独立ip 3、好友推荐时,根据tag求交集,大于某个阈值就可以推荐   zset 【ZADD runoobkey 1 redis】  数据插入集合时,已经进行天然排序 1、排行榜 2、带权重的消息队列    压测 #  线下环境压测的意义 #  缩比的压力测试环境压测出来的数据，完全不能用做生产环境的参考。但是这样的测试环境在研发阶段有其重要价值：\n 上线前发现性能瓶颈：链接异常为释放，线程数过多等； 应用基线数据：每次上线前压一次，对比历史数据即可发现是否有提升； 快速吸能调优及验证；  压测制定的考虑 #   流量模型的去定。可以基于业务的一段时间各接口的峰值，最后拼装成流量模型； 脏数据问题。有专用测试账户和单独请求头部两种方式，最终数据落到影子库和影子表里。仿真环境要多测试，数据要有多重机制保障； 监控覆盖度要足够； 压测扩展。验证其他功能，类似限流，熔断，降级； 参数调优。nginx配置，linux内核参数快速回收等； 缓存和数据库。重要业务有缓存，reids cpu 高是否有模糊匹配，高时间复杂度的指令，mysql 的索引添加，慢查询； mock服务。计费，短信； cpu阈值。50%～70%，响应时间1s为宜；   分布式锁 #  常用的分布式锁的实现有三种方式。\n  基于redis实现（利用redis的原子性操作setnx来实现）\n 每次进来先检测一下这个key是否实现。如果失效了移除失效锁 使用setnx原子命令争抢锁。Redis Setnx（SET if Not eXists） 命令在指定的 key 不存在时，为 key 设置指定的值，确认返回值为 1。属于 string 的数据类型。 抢到锁的设置过期时间。EXPIRE key 10086 设置 key 生存时间为 10086 秒   优点：redis本身是内存操作、并且通常是多片部署，因此有这较高的并发控制，可以抗住大量的请求。\n缺点：redis本身是缓存，有一定概率出现数据不一致请求。\n   基于 mysql 实现（利用 mysql 的 innodb 的行锁来实现，有两种方式， 排他锁与共享锁）\n SELECT ... FOR UPDATE 是排他锁，其他事物不能读取，也不能写。   为选择的行添加排它锁(X锁)，保证查询到的数据是最新的数据，允许其它事务对该数据加上共享锁(S锁)，但不能修改，只有当前事务可以修改，其它事务需要等当前事务 commit 或 rollback 之后才可以修改加锁的行;\n  SELECT ... LOCK IN SHARE MODE是共享锁，其他事务可以读，但不能写。   为选择的行添加共享锁(S锁)，其它事务也可以对该行数据添加S锁，它保证了读取到的是最新的数据，并且不允许别人修改，但是自己也 不一定 能够修改，因为可能别的事务也对这个数据加了S锁;\n   基于Zookeeper实现（利用zk的临时顺序节点来实现）\n  乐观锁和悲观锁 #    乐观锁(Optimistic Lock)：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。 乐观锁不能解决脏读的问题。\n  悲观锁(Pessimistic Lock)：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。\n  自动化测试用例各种数据，网络和环境异常的问题\nhttps://tech.meituan.com/2018/01/09/lego-api-test.html\n线上问题的处理流程\n监控的建议和建树 #  监控对象 #    硬件监控\n 电源状态、CPU 状态、机器温度、风扇状态、物理磁盘、raid 状态、内存状态、网卡状态    服务器基础监控\n **CPU：**单个 CPU 以及整体的使用情况。 **内存：**已用内存、可用内存。 **磁盘：**磁盘使用率、磁盘读写的吞吐量。 **网络：**出口流量、入口流量、TCP 连接状态。    数据库监控\n 数据库连接数、QPS、TPS、并行处理的会话数、缓存命中率、主从延时、锁状态、慢查询    中间件监控\n **Nginx：**活跃连接数、等待连接数、丢弃连接数、请求量、耗时、5XX 错误率。 **Tomcat：**最大线程数、当前线程数、请求量、耗时、错误量、堆内存使用情况、GC 次数和耗时。 **缓存：**成功连接数、阻塞连接数、已使用内存、内存碎片率、请求量、耗时、缓存命中率。 **消息队列：**连接数、队列数、生产速率、消费速率、消息堆积量。    应用监控\n **HTTP 接口：**URL 存活、请求量、耗时、异常量。 **RPC 接口：**请求量、耗时、超时量、拒绝量。 **JVM：**GC 次数、GC 耗时、各个内存区域的大小、当前线程数、死锁线程数。 **线程池：**活跃线程数、任务队列大小、任务执行耗时、拒绝任务数。 **连接池：**总连接数、活跃连接数。 **日志监控：**访问日志、错误日志。 **业务指标：**视业务来定，比如 PV、订单量等。    质量管理的建树\n小工具的开发目的\nCI 过程的检查点和退出时机\n大流量活动容量的预估策略\nhttps://tech.meituan.com/2016/09/28/stress-test-before-promotion.html\n测试理论 #  黑盒测试方法 #  等价类划分法；边界值分析法；因果图法；场景法；正交实验设计法；判定表驱动分析法；错误推测法；功能图分析法。\n设计用例的方法 #  "});index.add({'id':4,'href':'/myWiki/docs/shell/','title':"Shell",'section':"Docs",'content':"Shell 记录 #  计算用命令列表 #     命令 意义     sort -k1 -nr sort 排列计算，不带参数会将元素归类；-k1 以第一列为关键词；-nr的n代表关键词是 number 数字，r 代表 reverse 倒叙输出。   uniq -c uniq 省略重复行。-c代表计数   date +%d/%b/%Y:%H:%M Nginx 日志日期格式的 data，date -d '-1 minute' +%d/%b/%Y:%H:%M当前时间的前一分钟        AWK 需要记录的内建变量 #     变量名 意义     $0 整行的内容   NR 从1开始的行数   OFS 输出字段分隔符，OFS=\u0026quot;\\t\u0026quot;输出用制表符来分列   NF 当前记录中的字段个数，就是有多少列。$NF 最后一列数据    AWK 正则与 grep 的对比 #  # 下面操作相等 grep \u0026#34;TIME_WAIT\u0026#34; netstat.txt awk \u0026#39;/TIME_WAIT/\u0026#39; netstat.txt # 下面操作相等 grep -v \u0026#34;TIME_WAIT\u0026#34; netstat.txt awk \u0026#39;!/TIME_WAIT/\u0026#39; netstat.txt 计算当前文件夹总大小 #  ls -l | awk \u0026#39;NR!=1{sum+=$5}END{print sum}\u0026#39; 计算 nginx 日志中 ip 数量前十 #  awk \u0026#39;{a[$1]++}END{for(i in a)print a[i]\u0026#34; \u0026#34;i}\u0026#39; access.log | sort -k1 -nr | head -10 awk \u0026#39;{print $1}\u0026#39; access.log |sort | uniq -c | sort -k1 -nr | head -10 统计日志中访问大于100次的 IP #  awk \u0026#39;{a[$1]++}END{for(i in a)if{a[i]\u0026gt;100 print a[i]\u0026#34;, \u0026#34;i}}\u0026#39; access.log 统计某时间段内访问最多的10个IP #  awk \u0026#39;$4\u0026gt;=\u0026#34;[9/Apr/2016:00:00:01\u0026#34; \u0026amp;\u0026amp; $4\u0026lt;=\u0026#34;[9/Apr/2016:23:59:59\u0026#34; {a[$1]++}END{for(i in a)print a[i],i}\u0026#39; access.log |sort -k1 -nr|head -n10 统计每个URL访问内容的总大小（$body_bytes_sent） #  awk \u0026#39;{a[$7]++;size[$7]+=$10}END{for(i in a)print a[i],size[i],i}\u0026#39; access.log 统计访问状态码为404的IP及出现次数 #  awk \u0026#39;{if($9~/404/)a[$1\u0026#34; \u0026#34;$9]++}END{for(i in a)print i,a[i]}\u0026#39; access.log "});index.add({'id':8,'href':'/myWiki/docs/go-language/go-notes/','title':"go 语言一些笔记",'section':"go 语言",'content':"一些笔记 #  1\u0026lt;\u0026lt;31 // 2的31次方 map 的空值 #  a := make(map[int]bool) fmt.Println(a[0]) // false b := make(map[int]int) fmt.Println(b[0]) // 0 c := make(map[int]string) fmt.Println(c[0]) // \u0026#34;\u0026#34; 空字符串 string 字符串迭代 #   使用 for+i 迭代字符串时，获取元素类型是 byte 使用 for + range 迭代字符串时，获取元素类型是 rune  转化为二进制字符串 #  s := fmt.Sprintf(\u0026#34;%b\u0026#34;, C) make 与 new #  new： 返回的永远是指针，指向分配类型的地址。同时把分配的内存置零；\nmake：返回 chan，map，slice，本身。这三种类型是饮用类型，没有必要返回指针；make(type, len, cap)，初始化一个 type 类型的，其中前 len 个元素都赋零值，最长长度为 cap。\n"});index.add({'id':9,'href':'/myWiki/docs/arithmetic/example/binarysearch/','title':"二分查找 binary search",'section':"栗子🌰",'content':"二分查找 binary search #   二分查找 ...  func search(nums []int, target int) int { left, right := 0, len(nums)-1 for left \u0026lt;= right { mid := left + (right-left)/2 if nums[mid] == target { return mid } if nums[mid] \u0026gt; target { right = mid - 1 continue } left = mid + 1 } return -1 }     "});index.add({'id':10,'href':'/myWiki/docs/arithmetic/example/binarytree/','title':"二叉树 binary tree",'section':"栗子🌰",'content':"二叉树 binary tree #   反转二叉树 ...  /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func invertTree(root *TreeNode) *TreeNode { if root == nil { return nil } root.Right, root.Left = invertTree(root.Left), invertTree(root.Right) return root }      二叉树的最大深度 ...  /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ // 递归方式 func maxDepth(root *TreeNode) int { if root == nil { return 0 } if root.Right == nil \u0026amp;\u0026amp; root.Left == nil { return 1 } leftDepth := maxDepth(root.Left) rightDepth := maxDepth(root.Right) if leftDepth \u0026gt; rightDepth { return 1+leftDepth } return 1+rightDepth } // BFS 迭代方式 func maxDepth(root *TreeNode) int { if root == nil { return 0 } queue := []*TreeNode{root,} depth := 0 for len(queue) \u0026gt; 0{ size := len(queue) for i:=0;i\u0026lt;size;i++{ node := queue[0] queue = queue[1:] if node.Left != nil { queue = append(queue, node.Left) } if node.Right != nil { queue = append(queue, node.Right) } } depth = depth+1 } return depth }      合并二叉树 ...  /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func mergeTrees(t1 *TreeNode, t2 *TreeNode) *TreeNode { if t1 == nil { return t2 } if t2 == nil { return t1 } var nodeLeft *TreeNode var nodeRight *TreeNode if t1.Left == nil \u0026amp;\u0026amp; t1.Right == nil { nodeLeft = t2.Left nodeRight = t2.Right } if t2.Left == nil \u0026amp;\u0026amp; t2.Right == nil { nodeLeft = t1.Left nodeRight = t1.Right } if nodeLeft == nil { nodeLeft = mergeTrees(t1.Left, t2.Left) } if nodeRight == nil { nodeRight = mergeTrees(t1.Right, t2.Right) } node := TreeNode{ Val: t1.Val+t2.Val, Left: nodeLeft, Right: nodeRight, } return \u0026amp;node }      二叉树层次遍历2 ...  /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func levelOrderBottom(root *TreeNode) [][]int { if root == nil { return nil } queue := []*TreeNode{root} result := [][]int{} for len(queue) \u0026gt; 0 { levelVal := []int{} size := len(queue) for i:=0;i\u0026lt;size;i++ { levelVal = append(levelVal, queue[i].Val) if queue[i].Left != nil { queue = append(queue, queue[i].Left) } if queue[i].Right != nil { queue = append(queue, queue[i].Right) } } queue = queue[size:] result = append([][]int{levelVal}, result...) } return result }      将有序数组转化为高度平衡二叉搜索树 ...  func sortedArrayToBST(nums []int) *TreeNode { if len(nums) \u0026lt;=0 { return nil } if len(nums) == 1 { return \u0026amp;TreeNode{Val:nums[0]} } mid := len(nums)/2 return \u0026amp;TreeNode{ Val: nums[mid], Left: sortedArrayToBST(nums[:mid]), Right: sortedArrayToBST(nums[mid+1:]), } }      对称二叉树 ...  /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ // 递归遍历，传入双树，递归对比左树和右 func isSymmetric(root *TreeNode) bool { return checker(root, root) } func checker(left, right *TreeNode) bool { if left == nil \u0026amp;\u0026amp; right == nil { return true } if left == nil || right == nil { return false } return left.Val == right.Val \u0026amp;\u0026amp; checker(left.Left, right.Right) \u0026amp;\u0026amp; checker(left.Right, right.Left) } // 迭代遍历，用队列缓存取一双一双自左树和右树的镜像节点。然后从队列中取出一双来进行节点值对比。相等就把两个对比完的节点的镜像值一双一双存进队列。 func isSymmetric(root *TreeNode) bool { queue := []*TreeNode{ root, root, } for len(queue) \u0026gt; 0 { left, right := queue[0], queue[1] queue = queue[2:] if left == nil \u0026amp;\u0026amp; right == nil { continue } if left == nil || right == nil { return false } if left.Val != right.Val { return false } queue = append(queue, left.Left) queue = append(queue, right.Right) queue = append(queue, left.Right) queue = append(queue, right.Left) } return true }      二叉树深度 ...  /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func maxDepth(root *TreeNode) int { if root == nil { return 0 } if root.Left == nil \u0026amp;\u0026amp; root.Right == nil { return 1 } leftDepth := maxDepth(root.Left) rightDepth := maxDepth(root.Right) if leftDepth \u0026gt; rightDepth { return 1 + leftDepth } return 1 + rightDepth }      二叉树中序遍历 ...  /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ // 递归方式 func inorderTraversal(root *TreeNode) []int { if root == nil { return []int{} } if root.Left == nil \u0026amp;\u0026amp; root.Right == nil { return []int{root.Val} } leftList := inorderTraversal(root.Left) rightList := inorderTraversal(root.Right) result := append(leftList, root.Val) result = append(result, rightList...) return result } // 迭代方式 /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func inorderTraversal(root *TreeNode) []int { if root == nil { return []int{} } if root.Left == nil \u0026amp;\u0026amp; root.Right == nil { return []int{root.Val} } result := []int{} stack := []*TreeNode{root} for len(stack) \u0026gt; 0 { node := stack[len(stack)-1] if node.Left != nil { stack = append(stack, node.Left) node.Left = nil continue } stack = stack[:len(stack)-1] result = append(result, node.Val) if node.Right != nil { stack = append(stack, node.Right) node.Right = nil } } return result }     "});index.add({'id':11,'href':'/myWiki/docs/arithmetic/example/bitoperation/','title':"位运算 bit operation",'section':"栗子🌰",'content':"位运算 bit operation #   IP 到 CIDR ...  #!/usr/bin/env python # -*- coding: utf-8 -*- def ipToCIDR(ip, range): \u0026#34;\u0026#34;\u0026#34; :type ip: str :type range: int :rtype: List[str] \u0026#34;\u0026#34;\u0026#34; ipInt = ipToInt(ip) ans = [] x = 0 while x \u0026lt; range: zeros = countZeros(ipInt + x) while x + (1\u0026lt;\u0026lt;zeros) \u0026gt; range: zeros -= 1 ans.append(intToIp(ipInt + x) + \u0026#34;/\u0026#34; + str(32 - zeros)) x += 1\u0026lt;\u0026lt;zeros return ans def ipToInt(ip): ans = 0 for idx, part in enumerate(ip.split(\u0026#39;.\u0026#39;)[::-1]): ans += int(part) \u0026lt;\u0026lt; idx * 8 return ans def intToIp(ipInt): ans = [] for x in xrange(4): ans.append((ipInt \u0026gt;\u0026gt; x * 8) \u0026amp; 255) return \u0026#39;.\u0026#39;.join(map(str, ans[::-1])) def countZeros(ip): cnt = 0 while ip: if ip \u0026amp; 1: break cnt += 1 ip \u0026gt;\u0026gt;= 1 return cnt if __name__ == \u0026#39;__main__\u0026#39;: print(ipToCIDR(\u0026#34;255.0.0.7\u0026#34;, 11))      只出现一次的数字 ...  答案是使用位运算。对于这道题，可使用异或运算 ⊕。\nfunc singleNumber(nums []int) int { single := 0 for _, num := range nums { single ^= num } return single }      汉明距离 ...  // 标准库方法 func hammingDistance(x int, y int) int { return bits.OnesCount(uint(x) ^ uint(y)) } // 通过位移计算异或结果的1的个数 func hammingDistance(x int, y int) int { distance := 0 xor := x^y for xor\u0026gt;0 { if xor\u0026amp;1 == 1 { distance = distance + 1 } xor = xor\u0026gt;\u0026gt;1 } return distance } // 布赖恩·克尼根算法 // 当我们在 number 和 number-1 上做 AND 位运算时，原数字 number 的最右边等于 1 的比特会被移除。 func hammingDistance(x int, y int) int { distance := 0 xor := x^y for xor\u0026gt;0 { distance = distance + 1 xor = xor \u0026amp; (xor-1) } return distance }      二进制手表 ...  // 暴力解法，直接遍历所有合法的时间组合，计算“1”的个数的和是否与输出 num 相等 func readBinaryWatch(num int) []string { ret := make([]string,0) for i:=0;i\u0026lt;12;i++{ for j:=0;j\u0026lt;=59;j++{ if bitNums(i)+bitNums(j) == num { ret =append(ret,fmt.Sprintf(\u0026#34;%d:%02d\u0026#34;,i,j)) } } } return ret } func bitNums(i int) int{ num :=0 for i\u0026gt;0{ if i%2==1{ num++ } i=i\u0026gt;\u0026gt;1 } return num }     "});index.add({'id':12,'href':'/myWiki/docs/arithmetic/example/hashmap/','title':"哈希表 hash map",'section':"栗子🌰",'content':"哈希表 hash map #   宝石与石头 ...  func numJewelsInStones(J string, S string) int { jewels := make(map[string]struct{}) result := 0 for i:=0;i\u0026lt;len(J);i++{ jewels[string(J[i])] = struct{}{} } for i:=0;i\u0026lt;len(S);i++{ if _, ok := jewels[string(S[i])];ok { result = result + 1 } } return result }      岛屿的周长 ...  // 强行遍历所有节点的四周，判断四周格子的类型来计算是否周长+1 func islandPerimeter(grid [][]int) int { perimeter := 0 for i:=0;i\u0026lt;len(grid);i++{ sum := 0 for j:=0;j\u0026lt;len(grid[0]);j++{ if grid[i][j] == 0{ continue } if j-1\u0026lt;0 || grid[i][j-1] == 0 {sum++} if i-1\u0026lt;0 || grid[i-1][j] == 0 {sum++} if j+1\u0026gt;=len(grid[0]) || grid[i][j+1] == 0 {sum++} if i+1\u0026gt;=len(grid) || grid[i+1][j] == 0 {sum++} } perimeter = perimeter + sum } return perimeter } // DFS 递归遍历岛屿的格子，通过判断是否下一次进入的格子的类型和是否已经遍历过，来返回计入周长的边长是1还是0 func islandPerimeter(grid [][]int) int { for r:=0;r\u0026lt;len(grid);r++{ for c:=0;c\u0026lt;len(grid[0]);c++{ if grid[r][c] == 1 { return dfs(grid, r, c) } } } return 0 } func dfs(grid [][]int, r int, c int) int { if !(0 \u0026lt;= r \u0026amp;\u0026amp; r \u0026lt; len(grid) \u0026amp;\u0026amp; 0 \u0026lt;= c \u0026amp;\u0026amp; c \u0026lt; len(grid[0])) { return 1 } if grid[r][c] == 0 { return 1 } if grid[r][c] == 2 { return 0 } grid[r][c] = 2 return dfs(grid, r+1, c) + dfs(grid, r, c+1) + dfs(grid, r-1, c) + dfs(grid, r, c-1) }      两个数组的交集 ...  func intersection(nums1 []int, nums2 []int) []int { result := []int{} setMap := make(map[int]bool) for _, v := range nums1 { setMap[v] = false } for _, v := range nums2 { if sight, exist := setMap[v]; !sight \u0026amp;\u0026amp; exist { setMap[v] = true result = append(result, v) } } return result }     "});index.add({'id':13,'href':'/myWiki/docs/arithmetic/example/string/','title':"字符串 string",'section':"栗子🌰",'content':"字符串 string #   罗马数字转整数 ...  直接使用 hash map 作为索引会比较省事\nfunc romanToInt(s string) int { tranMap := map[string]int { \u0026#34;I\u0026#34;: 1, \u0026#34;V\u0026#34;: 5, \u0026#34;X\u0026#34;: 10, \u0026#34;L\u0026#34;: 50, \u0026#34;C\u0026#34;: 100, \u0026#34;D\u0026#34;: 500, \u0026#34;M\u0026#34;: 1000, \u0026#34;IV\u0026#34;: 4, \u0026#34;IX\u0026#34;: 9, \u0026#34;XL\u0026#34;: 40, \u0026#34;XC\u0026#34;: 90, \u0026#34;CD\u0026#34;: 400, \u0026#34;CM\u0026#34;: 900, } sList := strings.Split(s, \u0026#34;\u0026#34;) result := 0 for i:=0;i\u0026lt;len(sList);i++ { if i == len(sList) -1 { result = result + tranMap[sList[i]] continue } if v, ok := tranMap[sList[i]+sList[i+1]];ok{ result = result + v i = i + 1 continue } result = result + tranMap[sList[i]] } return result }      有效的括号 ...  func isValid(s string) bool { parMap := map[rune]rune { \u0026#39;(\u0026#39;: \u0026#39;0\u0026#39;, \u0026#39;{\u0026#39;: \u0026#39;0\u0026#39;, \u0026#39;[\u0026#39;: \u0026#39;0\u0026#39;, \u0026#39;)\u0026#39;: \u0026#39;(\u0026#39;, \u0026#39;}\u0026#39;: \u0026#39;{\u0026#39;, \u0026#39;]\u0026#39;: \u0026#39;[\u0026#39;, } parQueue := []rune{} for _, v := range s { if _, ok := parMap[v]; !ok { continue } if parMap[v] == \u0026#39;0\u0026#39; { parQueue = append(parQueue, v) continue } if len(parQueue) == 0 {return false} if parMap[v] != parQueue[len(parQueue)-1] { return false } parQueue = parQueue[:len(parQueue)-1] } if len(parQueue) \u0026gt; 0 {return false} return true }      最长公共前缀 ...  func longestCommonPrefix(strs []string) string { if len(strs) == 0 { return \u0026#34;\u0026#34; } if len(strs) == 1 { return strs[0] } mid := len(strs)/2 left := longestCommonPrefix(strs[:mid]) right := longestCommonPrefix(strs[mid:]) var length int if len(left) \u0026lt; len(right) { length = len(left) } else { length = len(right) } result := \u0026#34;\u0026#34; for i:=0;i\u0026lt;length;i++ { if left[i] != right[i] { break } result = result + string(left[i]) } return result }      二进制求和 ...  // 对齐末尾字符，同时字符“相加”，通过 carry 的值传递进位。每位的结果位 carry+a[i]+b[i]，留下的结果位为 %2 的结果，下一次的进位为 /2 的结果。 func addBinary(a string, b string) string { result, carry, n := \u0026#34;\u0026#34;, 0, 0 if len(a) \u0026gt; len(b) { n = len(a) } else { n = len(b) } for i:=0; i\u0026lt;n; i++ { if i \u0026lt; len(a) { carry = carry + int(a[len(a)-1-i] - \u0026#39;0\u0026#39;) // 当字符串中 a[len(a)-1-i] 为 \u0026#34;0\u0026#34; 时，之际操作游标取出的是 uint8=48 类型是 byte，直接 int 转换就会得到一个 int=48；当[-\u0026#39;\u0026#39;0\u0026#39;]之后，相当是 utf8 编码的两个 48 相减，获得的是 uint8=0，int 转换之后就会得到一个 int 类型的 0。如果该位为 \u0026#34;1\u0026#34;，由于正好比\u0026#34;0\u0026#34;多1个编码位，所以得到的就是 uint8=1，int 转换即可得到 1。  } if i \u0026lt; len(b) { carry = carry + int(b[len(b)-1-i] - \u0026#39;0\u0026#39;) } result = strconv.Itoa(carry%2) + result // result = fmt.Sprintf(\u0026#34;%b%s\u0026#34;, carry%2, result)  carry = carry / 2 } if carry \u0026gt; 0 { result = \u0026#34;1\u0026#34; + result } return result }      字符串相加 ...  func addStrings(num1 string, num2 string) string { carry, n := 0, 0 result := \u0026#34;\u0026#34; if len(num1) \u0026gt; len(num2) { n = len(num1) } else { n = len(num2) } for i:=0; i\u0026lt;n; i ++ { if i \u0026lt; len(num1) { carry = carry + int(num1[len(num1)-1-i] - \u0026#39;0\u0026#39;) } if i \u0026lt; len(num2) { carry = carry + int(num2[len(num2)-1-i] - \u0026#39;0\u0026#39;) } result = strconv.Itoa(carry%10) + result carry = carry / 10 } if carry\u0026gt;0 { result = strconv.Itoa(carry) + result } return result }      验证回文串 ...  func isPalindrome(s string) bool { left, right := 0, len(s)-1 for left \u0026lt;= right { for left \u0026lt; right \u0026amp;\u0026amp; !isalnum(s[left]) { left = left + 1 } for left \u0026lt; right \u0026amp;\u0026amp; !isalnum(s[right]) { right = right - 1 } if strings.ToLower(string(s[left])) != strings.ToLower(string(s[right])) { return false } left, right = left+1, right-1 } return true } func isalnum(ch byte) bool { return (ch \u0026gt;= \u0026#39;A\u0026#39; \u0026amp;\u0026amp; ch \u0026lt;= \u0026#39;Z\u0026#39;) || (ch \u0026gt;= \u0026#39;a\u0026#39; \u0026amp;\u0026amp; ch \u0026lt;= \u0026#39;z\u0026#39;) || (ch \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; ch \u0026lt;= \u0026#39;9\u0026#39;) }      无重复字符的最长子串 ...  // 双游标配合 map[字母]index 组成的滑动窗口 func lengthOfLongestSubstring(s string) int { result, sMap := 0, map[byte]int{} for left, right:=0, 0; right\u0026lt;len(s); right++ { if v, ok := sMap[s[right]]; ok { left = max(left, v) // 左指针只在最大的一方 \u0026#34;abba\u0026#34;  } result = max(result, right-left+1) sMap[s[right]] = right + 1 } return result } func max(a, b int) int { if a \u0026gt; b { return a } return b }      括号生成 ...  func generateParenthesis(n int) []string { result := new([]string) backtrack(\u0026#34;\u0026#34;, n, n, result) return *result } func backtrack(path string, left, right int, result *[]string) { if left == 0 \u0026amp;\u0026amp; right == 0 { *result = append(*result, path) return } if left \u0026gt; 0 { backtrack(path+\u0026#34;(\u0026#34;, left-1, right, result) } if right \u0026gt; left { backtrack(path+\u0026#34;)\u0026#34;, left, right-1, result) } }      最长回文串 ...  func longestPalindrome(s string) int { sMap := map[byte]int{} for i:=0; i\u0026lt;len(s); i++ { if v, ok := sMap[s[i]]; ok { sMap[s[i]] = v + 1 } else { sMap[s[i]] = 1 } } result, less := 0, 0 for _, v := range sMap { mod := v % 2 result = result + v - mod less = less + mod } if less \u0026gt;0 { return result+1 } return result }       Z 字形变换 ...  func convert(s string, numRows int) string { if numRows \u0026lt;= 1 {return s} listS := make([]string, numRows) i, flag := 0, -1 for _, v := range s { listS[i] = listS[i] + string(v) if i == numRows-1 || i == 0 { flag = -flag } i = i + flag } resutl := \u0026#34;\u0026#34; for _, v := range listS { resutl = resutl + v } return resutl }      电话号码的字母组合 ...  func letterCombinations(digits string) []string { if len(digits) \u0026lt;= 0 {return nil} digitsMap := map[byte][]string{ \u0026#39;2\u0026#39;: []string{\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;}, \u0026#39;3\u0026#39;: []string{\u0026#34;d\u0026#34;, \u0026#34;e\u0026#34;, \u0026#34;f\u0026#34;}, \u0026#39;4\u0026#39;: []string{\u0026#34;g\u0026#34;, \u0026#34;h\u0026#34;, \u0026#34;i\u0026#34;}, \u0026#39;5\u0026#39;: []string{\u0026#34;j\u0026#34;, \u0026#34;k\u0026#34;, \u0026#34;l\u0026#34;}, \u0026#39;6\u0026#39;: []string{\u0026#34;m\u0026#34;, \u0026#34;n\u0026#34;, \u0026#34;o\u0026#34;}, \u0026#39;7\u0026#39;: []string{\u0026#34;p\u0026#34;, \u0026#34;q\u0026#34;, \u0026#34;r\u0026#34;, \u0026#34;s\u0026#34;}, \u0026#39;8\u0026#39;: []string{\u0026#34;t\u0026#34;, \u0026#34;u\u0026#34;, \u0026#34;v\u0026#34;}, \u0026#39;9\u0026#39;: []string{\u0026#34;w\u0026#34;, \u0026#34;x\u0026#34;, \u0026#34;y\u0026#34;, \u0026#34;z\u0026#34;}, } path := \u0026#34;\u0026#34; result := []string{} backtrack(path, digits, \u0026amp;result, digitsMap) return result } func backtrack(path, digits string, result *[]string, digitsMap map[byte][]string) { if len(path) == len(digits) { *result = append(*result, path) return } i := len(path) for _, v := range digitsMap[digits[i]] { backtrack(path+v, digits, result, digitsMap) } }      分割回文串 ...  func partition(s string) [][]string { length := len(s) result := [][]string{} if length == 0 { return result } pathList := []string{} backtrack(pathList, s, 0, length, \u0026amp;result) return result } func backtrack(pathList []string, s string, index int, length int, result *[][]string) { if index \u0026gt;= length { tmp := make([]string, len(pathList)) copy(tmp, pathList) *result = append(*result, tmp) return } for i:=index; i\u0026lt;length; i++ { if !isPalindrome(s, index, i){ continue } pathList = append(pathList, s[index:i+1]) backtrack(pathList, s, i+1, length, result) pathList = pathList[:len(pathList)-1] } } func isPalindrome(s string, left, right int) bool { for left \u0026lt;= right { if s[left] != s[right] { return false } left = left + 1 right = right -1 } return true }     "});index.add({'id':14,'href':'/myWiki/docs/arithmetic/example/mathematics/','title':"数学 mathematics",'section':"栗子🌰",'content':"数学 mathematics #   整数反转 ...  func reverse(x int) int { y := 0 for x != 0 { y = y*10 + x%10 x = x/10 } if y \u0026lt; -(1\u0026lt;\u0026lt;31) || y \u0026gt; (1\u0026lt;\u0026lt;31)-1 { return 0 } return y }     "});index.add({'id':15,'href':'/myWiki/docs/arithmetic/example/array/','title':"数组 array",'section':"栗子🌰",'content':"数组 array #   两数之和 ...  func twoSum(nums []int, target int) []int { result := map[int]int{} for i:=0;i\u0026lt;len(nums);i++{ if k, exist := result[target-nums[i]];exist { return []int{k, i} } result[nums[i]] = i } return nil }      合并两个有序数组 ...   合并有序数列，不一定从小到大合并，也可以从大到小合并； 第一个数组有空间余量，直接操作比创建新变量空间合适；  func merge(nums1 []int, m int, nums2 []int, n int) { p1 := m-1 p2 := n-1 p3 := m+n-1 for ;p1\u0026gt;=0\u0026amp;\u0026amp;p2\u0026gt;=0;p3--{ if nums1[p1] \u0026lt; nums2[p2] { nums1[p3] = nums2[p2] p2 = p2-1 continue } nums1[p3] = nums1[p1] p1 = p1-1 } for i:=0;i\u0026lt;p2+1;i++{ nums1[i] = nums2[i] } return nums1 }      两数之和 II - 输入有序数组 ...  初始时两个指针分别指向第一个元素位置和最后一个元素的位置。每次计算两个指针指向的两个元素之和，并和目标值比较。如果两个元素之和等于目标值，则发现了唯一解。如果两个元素之和小于目标值，则将左侧指针右移一位。如果两个元素之和大于目标值，则将右侧指针左移一位。移动指针之后，重复上述操作，直到找到答案。\nfunc twoSum(numbers []int, target int) []int { low, high := 0, len(numbers) - 1 for low \u0026lt; high { sum := numbers[low] + numbers[high] if sum == target { return []int{low + 1, high + 1} } else if sum \u0026lt; target { low++ } else { high-- } } return []int{-1, -1} }       搜索旋转排序数组 ...  func search(nums []int, target int) int { left := 0 right := len(nums) - 1 for left \u0026lt;= right { mid := (left + right) / 2 if nums[mid] == target { return mid } // 判断是否在前半部分查找 \tif (nums[left] \u0026lt;= target \u0026amp;\u0026amp; target \u0026lt;= nums[mid]) || (nums[mid] \u0026lt;= nums[right] \u0026amp;\u0026amp; (target \u0026lt; nums[mid] || target \u0026gt; nums[right])) { right = mid - 1 } else { left = mid + 1 } } return -1 }      二维数组中的查找 ...  func findNumberIn2DArray(matrix [][]int, target int) bool { if len(matrix) == 0 || len(matrix[0]) == 0 { return false } r, c := 0, len(matrix[0])-1 for r\u0026lt;len(matrix) \u0026amp;\u0026amp; c\u0026gt;=0 { if matrix[r][c] == target { return true } if matrix[r][c] \u0026gt; target { c = c - 1 continue } if matrix[r][c] \u0026lt; target { r = r + 1 continue } } return false }      快速排序 ...  // 真快速排序 func sortArray(nums []int) []int { quickSortHelper(nums, 0, len(nums)-1) return nums } func quickSortHelper(nums []int, left, right int) { if left \u0026lt; right { pivot := partition(nums, left, right) quickSortHelper(nums, left, pivot-1) quickSortHelper(nums, pivot+1, right) } } func partition(nums []int, left, right int) int { pivotValue := nums[right] i := left - 1 for j:=left; j\u0026lt;right; j++ { if nums[j] \u0026lt;= pivotValue { i = i + 1 swap(nums, i, j) } } swap(nums, i+1, right) return i+1 } func swap(nums []int, i, j int) { nums[i], nums[j] = nums[j], nums[i] } // 伪快速排序 func sortArray(nums []int) []int { if len(nums) \u0026lt; 2 { return nums } lessList, greatList := []int{}, []int{} for _, v := range nums[1:] { if v \u0026lt; nums[0] { lessList = append(lessList, v) continue } greatList = append(greatList, v) } result := append([]int{}, sortArray(lessList)...) result = append(result, nums[0]) result = append(result, sortArray(greatList)...) return result } // 冒泡排序 func sortArray(nums []int) []int { if len(nums) \u0026lt; 2 { return nums } for i:=0; i\u0026lt;len(nums); i++ { for j:=0; j\u0026lt;len(nums)-i; j++ { if nums[j] \u0026gt; nums[j+1] { nums[j], nums[j+1] = nums[j+1], nums[j] } } } return nums }      三数之和 ...  func threeSum(nums []int) [][]int { n := len(nums) sort.Ints(nums) // 先排序  result := [][]int{} for i:=0; i\u0026lt;n; i++ { if i \u0026gt; 0 \u0026amp;\u0026amp; nums[i] == nums[i-1] { //固定位位游标去重  continue } right := n-1 for left:=i+1; left\u0026lt;n; left++ { //迭代移动左游标，不停右移增加  if left\u0026gt;i+1 \u0026amp;\u0026amp; nums[left] == nums[left-1]{ //大于初始值的左游标去重  continue } for left\u0026lt;right \u0026amp;\u0026amp; nums[i]+nums[left]+nums[right]\u0026gt;0 { //左右游标不能交叉  right = right - 1 //三值和大于0，右游标不停往左移，值越来越少  } if left == right {break} //游标相遇，直接退出迭代  if nums[i]+nums[left]+nums[right] == 0 { result = append(result, []int{nums[i], nums[left], nums[right]}) } } } return result }      岛屿的最大面积 ...  func maxAreaOfIsland(grid [][]int) int { result := 0 for r:=0; r\u0026lt;len(grid); r++ { for c:=0; c\u0026lt;len(grid[0]); c++ { if grid[r][c] == 1 { value := helper(r, c, grid) if result \u0026lt; value { result = value } } } } return result } func helper(r, c int, grid [][]int) int { if r \u0026lt; 0 || r \u0026gt; len(grid) - 1 || c \u0026lt; 0 || c \u0026gt; len(grid[0]) - 1 { return 0 } if grid[r][c] == 0 || grid[r][c] == 2 { return 0 } grid[r][c] = 2 return 1 + helper(r+1, c, grid) + helper(r-1, c, grid) + helper(r, c+1, grid) + helper(r, c-1, grid) }       最长连续递增序列 ...  func findLengthOfLCIS(nums []int) int { if len(nums) \u0026lt;= 1 { return len(nums) } result, tmp := 1, 1 for i:=0; i\u0026lt;len(nums)-1; i++ { if nums[i] \u0026lt; nums[i+1] { tmp = tmp + 1 } else { tmp = 1 } if tmp \u0026gt; result { result = tmp } } return result }      数组中的第k个最大元素 ...  // 快速选择算法 import \u0026#34;math/rand\u0026#34; func findKthLargest(nums []int, k int) int { rand.Seed(time.Now().UnixNano()) left, right := 0, len(nums)-1 target := len(nums) - k cur := -1 for cur != target { cur = partition(left, right, nums) if cur \u0026lt; target { left = cur + 1 } else if cur \u0026gt; target { right = cur - 1 } } return nums[cur] } func partition(left, right int, nums []int) int{ if left == right { return left } i := rand.Int() % (right - left + 1) + left n := nums[i] nums[i], nums[right] = nums[right], nums[i] l , r := left, right-1 for l \u0026lt; r { for l \u0026lt; r \u0026amp;\u0026amp; nums[l] \u0026lt;= n { l = l + 1 } for l \u0026lt; r \u0026amp;\u0026amp; n \u0026lt; nums[r] { r = r - 1 } if l != r { nums[l], nums[r] = nums[r], nums[l] } } if nums[l] \u0026gt; n { nums[l], nums[right] = nums[right], nums[l] return l } return right }       全排列 ...  func permute(nums []int) [][]int { result := [][]int{} path := []int{} used := make([]bool, len(nums)) backtrack(path, nums, used, \u0026amp;result) return result } func backtrack(path, nums []int, used []bool, result *[][]int) { if len(path) == len(nums) { tmp := make([]int, len(path)) copy(tmp, path) *result = append(*result, tmp) return } for i:=0; i\u0026lt;len(nums); i++ { if !used[i] { used[i] = true path = append(path, nums[i]) backtrack(path, nums, used, result) path = path[:len(path)-1] used[i] = false } } }      乘最多水的容器 ...  func maxArea(height []int) int { result, i, j := 0, 0, len(height)-1 for i != j { area := (j-i) * min(height[i], height[j]) if area \u0026gt; result { result = area } if height[i] \u0026lt; height[j] { i = i + 1 continue } j = j - 1 } return result } func min(i, j int) int { if i \u0026lt; j {return i} return j }      最大子序和 ...  // 动态规划 func maxSubArray(nums []int) int { max := nums[0] for i:=1; i\u0026lt;len(nums); i++ { if nums[i-1] + nums[i] \u0026gt; nums[i] { nums[i] = nums[i-1] + nums[i] // 通过对比，将当前 index 的最优解放到数组里，以方便下个迭代 index 对比调用。  } if nums[i] \u0026gt; max { max = nums[i] } } return max }      乘积最大子数组 ...  // 未考虑空间复杂度的动态规划 func maxProduct(nums []int) int { length := len(nums) if length == 0 { return 0 } iMax, iMin := make([]int, length), make([]int, length) iMax[0], iMin[0] = nums[0], nums[0] for i:=1; i\u0026lt;length; i++ { if nums[i] \u0026gt;= 0 { iMin[i] = min(nums[i], nums[i]*iMin[i-1]) iMax[i] = max(nums[i], nums[i]*iMax[i-1]) } else { iMin[i] = min(nums[i], nums[i]*iMax[i-1]) iMax[i] = max(nums[i], nums[i]*iMin[i-1]) } } result := iMax[0] for i:=1; i\u0026lt;length; i++ { result = max(result, iMax[i]) } return result } // 表格复用的动态规划 func maxProduct(nums []int) int { length := len(nums) if length == 0 { return 0 } preMax, preMin, result := nums[0], nums[0], nums[0] var curMax, curMin int for i:=1; i\u0026lt;length; i++ { if nums[i] \u0026gt;= 0 { curMin = min(nums[i], nums[i]*preMin) curMax = max(nums[i], nums[i]*preMax) } else { curMin = min(nums[i], nums[i]*preMax) curMax = max(nums[i], nums[i]*preMin) } result = max(result, curMax) preMin, preMax = curMin, curMax } return result } func max(x, y int) int { if x \u0026gt;= y { return x } return y } func min(x,y int) int { if x \u0026lt;= y { return x } return y }     "});index.add({'id':18,'href':'/myWiki/docs/arithmetic/example/linkedlist/','title':"链表 linked list",'section':"栗子🌰",'content':"链表 linked list #   合并两个有序列表 ...  /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode { result := \u0026amp;ListNode{} preHead := result for (l1 != nil \u0026amp;\u0026amp; l2 != nil){ if l1.Val \u0026lt; l2.Val { preHead.Next = l1 l1 = l1.Next } else { preHead.Next = l2 l2 = l2.Next } preHead = preHead.Next } if l1 == nil{ preHead.Next = l2 } if l2 == nil { preHead.Next = l1 } return result.Next }      反转链表 ...  /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func reverseList(head *ListNode) *ListNode { if nil == head { return head } cur, next := head, head.Next for ; nil != next; cur, next, next.Next = next, next.Next, cur { } head.Next = nil return cur }      删除链表中的节点 ...  /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func deleteNode(node *ListNode) { node.Val, node.Next= node.Next.Val, node.Next.Next }     "});index.add({'id':19,'href':'/myWiki/docs/go-language/dev-rule/','title':"面向对象设计原则",'section':"go 语言",'content':"面向对象设计原则 #  依赖倒置原则（DIP）\n 高层模块（稳定）不应该依赖底层模块（变化），二者都应该依赖抽象（稳定） 抽象（稳定）不应该依赖实现细节（变化），实现细节应该依赖于抽象（稳定）  开放封闭原则（OCP）\n 对扩展开放，对更改封闭 类模块应该可以扩展的，但是不可以修改的  单一职责原则（LSP）\n 一个类应该仅有一个引起他变化的原因 变化的方向隐含这类的责任  Liskov替换原则（LSP）\n 子类必须能够替换他们的基类（IS-A） 继承表达类型抽象  接口隔离原则（ISP）\n 不应该强迫客户程序依赖他们不使用的方法 接口应该小而完备  优先使用对象组合，而不是类继承\n 类继承通常为“白箱复用”，对象组合通常为“黑箱复用” 继承在某种程度上破坏了封装性，子类父类耦合度高。 而对象组合则是要求被组合的对象有良好定义的接口，耦合度低。  封装变化点\n 使用封装来创建对象之间的分界层。类设计者可以在分界的一侧进行修改，而不会对另外一侧产生不良的影响。从而实现层次间的松耦合。  针对接口编程，而不是针对实现编程\n 不将变量的类型声明为某个特定的具体类，而声明为某接口； 客户程序无需获知对象的具体类型，只需要知道对象所具有的接口； 减少系统中各部分的依赖关系，从而实现“高内聚，低耦合”  "});index.add({'id':20,'href':'/myWiki/docs/arithmetic/leetcoderanking/','title':"高频题目",'section':"算法与数据结构",'content':"LeetCode 的高频题目 #  DFS：深度优先搜索算法（Depth First Search），对于二叉树而言，它沿着树的深度遍历树的节点，尽可能深的搜索树的分支，这一过程一直进行到已发现从源节点可达的所有节点为止。\n平衡二叉树： 左右子树的高度相差不超过 1 的树为平衡二叉树\n   插入方式 描述 旋转方式     LL 在 A 的左子树根节点的左子树上插入节点而破坏平衡 右旋转   RR 在 A 的右子树根节点的右子树上插入节点而破坏平衡 左旋转   LR 在A的左子树根节点的右子树上插入节点而破坏平衡 先左旋后右旋   RL 在 A 的右子树根节点的左子树上插入节点而破坏平衡 先右旋后左旋    XOR 异或运算 ⊕ #   任何数和 0 做异或运算，结果仍然是原来的数，即 a⊕0=a。 任何数和其自身做异或运算，结果是 0，即 a⊕a=0。 异或运算满足交换律和结合律，即 a⊕b⊕a=b⊕a⊕a=b⊕(a⊕a)=b⊕0=b。  汉明距离 #  两个整数之间的汉明距离是对应位置上数字不同的位数。XOR 的位运算，当且仅当输入位不同时输出为 1。\n 计算 x 和 y 之间的汉明距离，可以先计算 x XOR y，然后统计结果中等于 1 的位数。\n 为了计算等于 1 的位数，可以将每个位移动到最左侧或最右侧，然后检查该位是否为 1。检查最右位是否为 1，可以使用取模运算（i % 2）或者 AND 操作（i \u0026amp; 1），这两个操作都会屏蔽最右位以外的其他位。\n  布赖恩·克尼根算法 #  该算法使用特定比特位和算术运算移除等于 1 的最右比特位。\n 当我们在 number 和 number-1 上做 AND 位运算时，原数字 number 的最右边等于 1 的比特会被移除。\n 二进制字符串的游标取值操作 #  当字符串中 a[i] 为 \u0026ldquo;0\u0026rdquo; 时，之际操作游标取出的是 uint8=48 类型是 byte，直接 int 转换就会得到一个 int=48；当操作[-\u0026lsquo;\u0026lsquo;0\u0026rsquo;]之后，相当是 utf8 编码的两个 48 相减，获得的是 uint8=0，int 转换之后就会得到一个 int 类型的 0。如果该位为 \u0026ldquo;1\u0026rdquo;，由于正好比\u0026quot;0\u0026quot;多1个编码位，所以得到的就是 uint8=1，int 转换即可得到 1。\n回溯算法编码公式 #  result = [] func backtrack(路径，选择列表) { if 满足结束条件 { result.add(路径) } return for 选择 in 选择列表 { 做选择 backtrack(路径，选择列表) 撤销选择 } } 位运算 bit operation #   IP 到 CIDR 只出现一次的数字 二进制手表  字符串 string #   罗马数字转整数 有效的括号 最长公共前缀（实现方法有待优化） 二进制求和 字符串相加 验证回文串 无重复字符的最长子串 括号生成 最长回文串 Z 字型变换 电话号码的字母组合 分割回文串  数学 mathematics #   整数反转  数组 arrary #   两数之和 合并两个有序数组 两数之和 II - 输入有序数组 搜索旋转排序数组 二维数组中的查找 快速排序 三数之和 岛屿的最大面积 最长连续递增序列 数组中的第 k 个最大元素 全排列 乘最多水的容器 最大子序和 最大乘积子数组  链表 linked list #   合并两个有序链表 反转链表 删除链表中的节点  二叉树 binary tree #   反转二叉树 二叉树的最大深度 合并二叉树 二叉树层次遍历2 将有序数组转化为高度平衡二叉搜索树 对称二叉树 二叉树深度 二叉树中序遍历  哈希表 hash map #   宝石与石头 岛屿的周长 两个数组的交集  二分查找 binary search #   二分查找  "});})();