'use strict';(function(){const indexCfg={cache:true};indexCfg.doc={id:'id',field:['title','content'],store:['title','href','section'],};const index=FlexSearch.create('balance',indexCfg);window.bookSearchIndex=index;index.add({'id':0,'href':'/myWiki/docs/docker/docker-learn/','title':"Docker Learn",'section':"Docker",'content':"docker learn test #  "});index.add({'id':1,'href':'/myWiki/docs/linux/','title':"Linux",'section':"Docs",'content':"linuxç³»ç»Ÿä¸­çš„Loadï¼š æ˜¯å¯¹å½“å‰CPUå·¥ä½œé‡çš„åº¦é‡ (WikiPedia: the system load is a measure of the amount of work that a computer system is doing)ã€‚ä¹Ÿæœ‰ç®€å•çš„è¯´æ˜¯è¿›ç¨‹é˜Ÿåˆ—çš„é•¿åº¦ã€‚\nä»€ä¹ˆæ ·çš„Load averageå€¼è¦æé«˜è­¦æƒ• #   0.7 \u0026lt; load \u0026lt; 1: æ­¤æ—¶æ˜¯ä¸é”™çš„çŠ¶æ€ï¼Œå¦‚æœè¿›æ¥æ›´å¤šçš„æ±½è½¦ï¼Œä½ çš„é©¬è·¯ä»ç„¶å¯ä»¥åº”ä»˜ã€‚ load = 1: ä½ çš„é©¬è·¯å³å°†æ‹¥å µï¼Œè€Œä¸”æ²¡æœ‰æ›´å¤šçš„èµ„æºé¢å¤–çš„ä»»åŠ¡ï¼Œèµ¶ç´§çœ‹çœ‹å‘ç”Ÿäº†ä»€ä¹ˆå§ã€‚ load \u0026gt; 5: éå¸¸ä¸¥é‡æ‹¥å µï¼Œæˆ‘ä»¬çš„é©¬è·¯éå¸¸ç¹å¿™ï¼Œæ¯è¾†è½¦éƒ½æ— æ³•å¾ˆå¿«çš„è¿è¡Œ  æ€§èƒ½æŒ‡æ ‡ #  ä¸šåŠ¡æ€§èƒ½æŒ‡æ ‡å¯ä»¥ç›´è§‚åœ°åæ˜ è¢«æµ‹ç³»ç»Ÿçš„å®é™…æ€§èƒ½çŠ¶å†µï¼Œå¸¸ç”¨çš„æŒ‡æ ‡é¡¹æœ‰ï¼š\n å¹¶å‘ç”¨æˆ·æ•° äº‹åŠ¡ååç‡ï¼ˆTPS/RPSï¼‰ äº‹åŠ¡å¹³å‡å“åº”æ—¶é—´ äº‹åŠ¡æˆåŠŸç‡  è€Œç³»ç»Ÿèµ„æºæ€§èƒ½æŒ‡æ ‡ï¼Œä¸»è¦æ˜¯åæ˜ æ•´ä¸ªç³»ç»Ÿç¯å¢ƒçš„ç¡¬ä»¶èµ„æºä½¿ç”¨æƒ…å†µï¼Œå¸¸ç”¨çš„æŒ‡æ ‡åŒ…æ‹¬ï¼š\n æœåŠ¡å™¨ï¼šCPUåˆ©ç”¨ç‡ã€load å¤„ç†å™¨é˜Ÿåˆ—é•¿åº¦ã€å†…å­˜åˆ©ç”¨ç‡ã€å†…å­˜äº¤æ¢é¡µé¢æ•°ã€ç£ç›˜IOçŠ¶æ€ã€ç½‘å¡å¸¦å®½ä½¿ç”¨æƒ…å†µç­‰ï¼› æ•°æ®åº“ï¼šæ•°æ®åº“è¿æ¥æ•°ã€æ•°æ®åº“è¯»å†™å“åº”æ—¶é•¿ã€æ•°æ®åº“è¯»å†™ååé‡ç­‰ï¼› ç½‘ç»œï¼šç½‘ç»œååé‡ã€ç½‘ç»œå¸¦å®½ã€ç½‘ç»œç¼“å†²æ± å¤§å°ï¼› ç¼“å­˜ï¼ˆRedisï¼‰ï¼šé™æ€èµ„æºç¼“å­˜å‘½ä¸­ç‡ã€åŠ¨æ€æ•°æ®ç¼“å­˜å‘½ä¸­ç‡ã€ç¼“å­˜ååé‡ç­‰ï¼› æµ‹è¯•è®¾å¤‡ï¼ˆå‹åŠ›å‘ç”Ÿå™¨ï¼‰ï¼šCPUåˆ©ç”¨ç‡ã€å¤„ç†å™¨é˜Ÿåˆ—é•¿åº¦ã€å†…å­˜åˆ©ç”¨ç‡ã€å†…å­˜äº¤æ¢é¡µé¢æ•°ã€ç£ç›˜IOçŠ¶æ€ã€ç½‘å¡å¸¦å®½ä½¿ç”¨æƒ…å†µç­‰ã€‚  "});index.add({'id':2,'href':'/myWiki/docs/media/','title':"Media",'section':"Docs",'content':"åª’ä½“ç›´æ’­ç›¸å…³ #  ç›´æ’­å·¥ä½œæµç¨‹ #     æ¶æ„ç«¯ å·¥ä½œæµç¨‹     ä¸»æ’­ç«¯ éŸ³è§†é¢‘é‡‡é›†ã€éŸ³è§†é¢‘ç¼–ç ã€æ¨æµ   æµåª’ä½“æœåŠ¡ç«¯ ç›´æ’­æµæ”¶é›†ã€éŸ³è§†é¢‘è½¬ç ã€ç›´æ’­æµåˆ†å‘   è§‚ä¼—ç«¯ æ‹‰æµã€éŸ³è§†é¢‘è§£ç ã€éŸ³è§†é¢‘æ’­æ”¾    ç«¯ä¸Šæ¨æ‹‰æµæµ‹è¯•æ–¹æ³• #     æµ‹è¯•æ–¹æ³• æ¨æµç«¯ æ‹‰æµç«¯     è°ƒå‚æ•°æµ‹è¯• APIæµ‹è¯•ï¼šé‡ç‚¹å…³æ³¨åœ¨å¤–å±‚æ¯”è¾ƒéš¾è®¾ç½®çš„APIå‚æ•° APIæµ‹è¯•ï¼šé‡ç‚¹å…³æ³¨åœ¨å¤–å±‚æ¯”è¾ƒéš¾è®¾ç½®çš„APIå‚æ•°ï¼›åè®®æ‹‰æµæµ‹è¯•ï¼šå…³æ³¨ä¸åŒåè®®çš„æ’­æ”¾æƒ…å†µï¼›è½¯ç¡¬è§£åŠåˆ‡æ¢æµ‹è¯•ï¼šâ€¦â€¦   é›†æˆæµ‹è¯• QoSï¼šå½“å¸¦å®½å—é™çš„æ—¶å€™ï¼ˆè¡¨ç°ä¸ºæ‰åŒ…æˆ–å»¶æ—¶ç­‰ï¼‰ï¼Œè‡ªåŠ¨é™ä½ç¼–ç ç ç‡ï¼Œä½¿å¾—è§‚ä¼—å¯ä»¥è§‚çœ‹æ›´æµç•…ï¼›å½“å¸¦å®½å˜å¾—æ¯”è¾ƒå¥½æ—¶åˆå¯ä»¥å‡é«˜ç¼–ç ç ç‡ï¼Œä½¿ç”¨æˆ·å¯ä»¥è§‚çœ‹æ›´æ¸…æ™°çš„ç”»é¢ã€‚è½¯ç¡¬ç¼–ç æµ‹è¯•ï¼šâ€¦â€¦ QoSï¼šåœ¨æ‹‰æµSDKä¸­å¯ä»¥ç†è§£æˆä¸€ä¸ªç½‘ç»œæµç•…åº¦æµ‹è¯•ï¼ŒåŒ…å«çš„åŠŸèƒ½æœ‰ç§’å¼€ã€éŸ³ç”»åŒæ­¥ã€ç”»è´¨ã€‚æ’­æ”¾å™¨æ§åˆ¶åŠŸèƒ½æµ‹è¯•ï¼šâ€¦â€¦æ’­æ”¾å™¨åŠ¨æ€å‚æ•°æµ‹è¯•ï¼šâ€¦â€¦   ä¸“é¡¹æµ‹è¯• ç¾é¢œæ»¤é•œæµ‹è¯•ï¼Œç”»è´¨è¯„ä¼°æµ‹è¯•ï¼Œä¸­æ–­æµ‹è¯•ï¼Œæ€§èƒ½æµ‹è¯•ï¼Œå…¼å®¹æµ‹è¯•ï¼Œæ‰“ç‚¹ä¸ŠæŠ¥æµ‹è¯• æ€§èƒ½æµ‹è¯•ï¼Œå…¼å®¹æ€§æµ‹è¯•ï¼Œä¸­æ–­æµ‹è¯•ï¼Œåˆ†è¾¨ç‡æµ‹è¯•ï¼Œæ‰“ç‚¹ä¸ŠæŠ¥æµ‹è¯•    å¯¼è‡´è§†é¢‘ç›´æ’­å»¶æ—¶çš„åŸå›  #   è§†é¢‘çš„ç¼–ç æ ¼å¼å¯¼è‡´ã€‚å¸§é—´å‹ç¼©çš„è§†é¢‘ç¼–ç ï¼Œåªèƒ½åœ¨æ”¶åˆ°å…³é”®å¸§ I å¸§æ—¶å€™æ‰èƒ½å¼€å§‹æ’­æ”¾ï¼› ç½‘ç»œåè®®åˆ‡ç‰‡å¤§å°å†³å®šäº†é¦–å‘æ•°æ®çš„é—´éš”ã€‚HLS æ•°æ®ä¼ æ’­æ–¹å¼æ˜¯ä¼ æ’­ TS æ–‡ä»¶ï¼Œå¯èƒ½å›ç›´æ¥å¯¼è‡´ 20ï½30s çš„å»¶æ—¶ï¼› é“¾è·¯è¿‡é•¿å¯¼è‡´ã€‚æœåŠ¡å™¨å’Œå®¢æˆ·ç«¯éƒ½ä¼šé¢„ç•™åª’ä½“ç¼“å­˜ï¼›  éŸ³è§†é¢‘åª’ä½“ä¸‰ä¸ªæ¦‚å¿µ #  å¸§ç‡ï¼š1s å†…åŒ…å«å¤šå°‘æ•°æ®ï¼Œ å½±å“ç”»é¢æµç•…åº¦ã€‚FPS\nç ç‡ï¼šç¼–ç å™¨æ¯ç§’ç¼–å‡ºæ¥çš„æ•°æ®å¤§å°ã€‚kbpsï¼ŒMbpsï¼ŒMBpsã€‚ç ç‡å†³å®šäº†è§†é¢‘æ–‡ä»¶çš„æ€»å¤§å°ï¼Œè€Œç¼–ç æ˜¯ä¸ºäº†åœ¨è¿™ä¸ªå¤§å°ä¹‹ä¸‹ä¿å­˜æœ€å¥½çš„å›¾åƒã€‚\nåˆ†è¾¨ç‡ï¼šå•ä½è‹±å¯¸ä¸Šé”åŒ…å«çš„åƒç´ ç‚¹æ•°ã€‚1080pï¼Œ1080i\nå¦‚æœä¸€ä¸ªåª’ä½“æµçš„ç ç‡é™ä½äº†ï¼Œç›¸å¯¹é™æ€çš„è§†é¢‘å¯èƒ½è¿˜æ˜¯ç›¸å¯¹æ¸…æ™°ï¼Œä½†æ˜¯é€šè¿‡å¢åŠ å¤§é‡çš„è¿åŠ¨ç²’å­ï¼Œç¼–ç å™¨å°±éš¾ä»¥é¢„æµ‹åƒç´ ç‚¹çš„è¿åŠ¨ï¼Œè€Œç ç‡åˆä¸è¶³ä»¥æ”¯æ’‘ç”»é¢ã€‚æ­¤æ—¶ç”»é¢å°±ä¼šå‡ºç°å¡é¡¿ï¼Œå¤§é‡æ»¥ç«½å……æ•°çš„è‰²å—å’Œé©¬èµ›å…‹ã€‚\nåª’ä½“ç¼–ç  #  éŸ³é¢‘ï¼šAACï¼Œopus\nè§†é¢‘ï¼šH.264\nH.264 ä¼šä½¿ç”¨ I å¸§ï¼ˆå…³é”®å¸§ï¼‰ã€P å¸§ï¼ˆå‘å‰å‚è€ƒå¸§ï¼‰å’Œ B å¸§ï¼ˆåŒå‘å‚è€ƒå¸§ï¼‰å°†è§†é¢‘æ•°æ®å‹ç¼©ï¼š\n I \u0026ndash;\u0026gt; B \u0026lt;\u0026ndash;\u0026gt; B \u0026lt;\u0026ndash; P I\n å›¾åƒç»„ï¼ˆGroup of picturesï¼ŒGOPï¼‰æŒ‡å®šäº†è§†é¢‘å¸§çš„ç»„ç»‡æ–¹å¼ã€‚ç§»åŠ¨ç«¯ç›´æ’­çš„ GOP éƒ½ä¼šè¢«è®¾ç½®æˆ 1 ~ 4 ç§’ï¼Œå½“ç„¶æˆ‘ä»¬ä¹Ÿå¯ä»¥ä½¿ç”¨æ›´é•¿çš„ GOP é™ä½å ç”¨çš„å¸¦å®½ã€‚\n"});index.add({'id':3,'href':'/myWiki/docs/qa/','title':"Q\u0026 A",'section':"Docs",'content':"Pythonåƒåœ¾å›æ”¶æœºåˆ¶ #  Python GCä¸»è¦ä½¿ç”¨å¼•ç”¨è®¡æ•°ï¼ˆreference countingï¼‰æ¥è·Ÿè¸ªå’Œå›æ”¶åƒåœ¾ã€‚åœ¨å¼•ç”¨è®¡æ•°çš„åŸºç¡€ä¸Šï¼Œé€šè¿‡â€œæ ‡è®°-æ¸…é™¤â€ï¼ˆmark and sweepï¼‰è§£å†³å®¹å™¨å¯¹è±¡å¯èƒ½äº§ç”Ÿçš„å¾ªç¯å¼•ç”¨é—®é¢˜ï¼Œé€šè¿‡â€œåˆ†ä»£å›æ”¶â€ï¼ˆgeneration collectionï¼‰ä»¥ç©ºé—´æ¢æ—¶é—´çš„æ–¹æ³•æé«˜åƒåœ¾å›æ”¶æ•ˆç‡ã€‚\n1 å¼•ç”¨è®¡æ•° #  PyObjectæ˜¯æ¯ä¸ªå¯¹è±¡å¿…æœ‰çš„å†…å®¹ï¼Œå…¶ä¸­ob_refcntå°±æ˜¯åšä¸ºå¼•ç”¨è®¡æ•°ã€‚å½“ä¸€ä¸ªå¯¹è±¡æœ‰æ–°çš„å¼•ç”¨æ—¶ï¼Œå®ƒçš„ob_refcntå°±ä¼šå¢åŠ ï¼Œå½“å¼•ç”¨å®ƒçš„å¯¹è±¡è¢«åˆ é™¤ï¼Œå®ƒçš„ob_refcntå°±ä¼šå‡å°‘.å¼•ç”¨è®¡æ•°ä¸º0æ—¶ï¼Œè¯¥å¯¹è±¡ç”Ÿå‘½å°±ç»“æŸäº†ã€‚\nä¼˜ç‚¹:\n ç®€å• å®æ—¶æ€§  ç¼ºç‚¹:\n ç»´æŠ¤å¼•ç”¨è®¡æ•°æ¶ˆè€—èµ„æº å¾ªç¯å¼•ç”¨  2 æ ‡è®°-æ¸…é™¤æœºåˆ¶ #  åŸºæœ¬æ€è·¯æ˜¯å…ˆæŒ‰éœ€åˆ†é…ï¼Œç­‰åˆ°æ²¡æœ‰ç©ºé—²å†…å­˜çš„æ—¶å€™ä»å¯„å­˜å™¨å’Œç¨‹åºæ ˆä¸Šçš„å¼•ç”¨å‡ºå‘ï¼Œéå†ä»¥å¯¹è±¡ä¸ºèŠ‚ç‚¹ã€ä»¥å¼•ç”¨ä¸ºè¾¹æ„æˆçš„å›¾ï¼ŒæŠŠæ‰€æœ‰å¯ä»¥è®¿é—®åˆ°çš„å¯¹è±¡æ‰“ä¸Šæ ‡è®°ï¼Œç„¶åæ¸…æ‰«ä¸€éå†…å­˜ç©ºé—´ï¼ŒæŠŠæ‰€æœ‰æ²¡æ ‡è®°çš„å¯¹è±¡é‡Šæ”¾ã€‚\n3 åˆ†ä»£æŠ€æœ¯ #  åˆ†ä»£å›æ”¶çš„æ•´ä½“æ€æƒ³æ˜¯ï¼šå°†ç³»ç»Ÿä¸­çš„æ‰€æœ‰å†…å­˜å—æ ¹æ®å…¶å­˜æ´»æ—¶é—´åˆ’åˆ†ä¸ºä¸åŒçš„é›†åˆï¼Œæ¯ä¸ªé›†åˆå°±æˆä¸ºä¸€ä¸ªâ€œä»£â€ï¼Œåƒåœ¾æ”¶é›†é¢‘ç‡éšç€â€œä»£â€çš„å­˜æ´»æ—¶é—´çš„å¢å¤§è€Œå‡å°ï¼Œå­˜æ´»æ—¶é—´é€šå¸¸åˆ©ç”¨ç»è¿‡å‡ æ¬¡åƒåœ¾å›æ”¶æ¥åº¦é‡ã€‚\nPythoné»˜è®¤å®šä¹‰äº†ä¸‰ä»£å¯¹è±¡é›†åˆï¼Œç´¢å¼•æ•°è¶Šå¤§ï¼Œå¯¹è±¡å­˜æ´»æ—¶é—´è¶Šé•¿ã€‚\nreids æ•°æ®ç±»å‹ #     æ•°æ®ç±»å‹ æœ€å¤§å­˜å‚¨ ç‰¹æ€§ åº”ç”¨åœºæ™¯     stringã€SET runoobkey redis ã€‘ 512MB å¯ä»¥åŒ…å«ä»»ä½•æ•°æ®,æ¯”å¦‚jpgå›¾ç‰‡æˆ–è€…åºåˆ—åŒ–çš„å¯¹è±¡,ä¸€ä¸ªé”®æœ€å¤§èƒ½å­˜å‚¨512M å¸¸è§„key-valueç¼“å­˜åº”ç”¨ã€‚å¸¸è§„è®¡æ•°: å¾®åšæ•°, ç²‰ä¸æ•°ã€‚   hash ã€HMSET runoobkey name \u0026ldquo;redis tutorial\u0026rdquo; description \u0026ldquo;redis basic commands for caching\u0026rdquo; likes 20 visitors 23000ã€‘ æ¯ä¸ª hash å¯ä»¥å­˜å‚¨ 2^32 -1 é”®å€¼å¯¹ï¼ˆ40å¤šäº¿ï¼‰ é€‚åˆå­˜å‚¨å¯¹è±¡,å¹¶ä¸”å¯ä»¥åƒæ•°æ®åº“ä¸­updateä¸€ä¸ªå±æ€§ä¸€æ ·åªä¿®æ”¹æŸä¸€é¡¹å±æ€§å€¼(Memcachedä¸­éœ€è¦å–å‡ºæ•´ä¸ªå­—ç¬¦ä¸²ååºåˆ—åŒ–æˆå¯¹è±¡ä¿®æ”¹å®Œå†åºåˆ—åŒ–å­˜å›å») å­˜å‚¨ã€è¯»å–ã€ä¿®æ”¹ç”¨æˆ·å±æ€§ã€‚ç”¨æˆ·å¯¹è±¡åŒ…å«å§“åï¼Œå¹´é¾„ï¼Œç”Ÿæ—¥ç­‰ä¿¡æ¯   list ã€LPUSH runoobkey redisã€‘ åˆ—è¡¨æœ€å¤šå¯å­˜å‚¨ 2^32 - 1 å…ƒç´ ï¼ˆ40å¤šäº¿ï¼‰ å¢åˆ å¿«,æä¾›äº†æ“ä½œæŸä¸€æ®µå…ƒç´ çš„API 1ã€æœ€æ–°æ¶ˆæ¯æ’è¡Œç­‰åŠŸèƒ½(æ¯”å¦‚æœ‹å‹åœˆçš„æ—¶é—´çº¿) 2ã€æ¶ˆæ¯é˜Ÿåˆ—   set ã€SADD runoobkey redisã€‘ é›†åˆä¸­æœ€å¤§çš„æˆå‘˜æ•°ä¸º 232 - 1 1ã€æ·»åŠ ã€åˆ é™¤ã€æŸ¥æ‰¾çš„å¤æ‚åº¦éƒ½æ˜¯O(1) 2ã€ä¸ºé›†åˆæä¾›äº†æ±‚äº¤é›†ã€å¹¶é›†ã€å·®é›†ç­‰æ“ä½œ 1ã€å…±åŒå¥½å‹ 2ã€åˆ©ç”¨å”¯ä¸€æ€§,ç»Ÿè®¡è®¿é—®ç½‘ç«™çš„æ‰€æœ‰ç‹¬ç«‹ip 3ã€å¥½å‹æ¨èæ—¶,æ ¹æ®tagæ±‚äº¤é›†,å¤§äºæŸä¸ªé˜ˆå€¼å°±å¯ä»¥æ¨è   zset ã€ZADD runoobkey 1 redisã€‘  æ•°æ®æ’å…¥é›†åˆæ—¶,å·²ç»è¿›è¡Œå¤©ç„¶æ’åº 1ã€æ’è¡Œæ¦œ 2ã€å¸¦æƒé‡çš„æ¶ˆæ¯é˜Ÿåˆ—    å‹æµ‹ #  çº¿ä¸‹ç¯å¢ƒå‹æµ‹çš„æ„ä¹‰ #  ç¼©æ¯”çš„å‹åŠ›æµ‹è¯•ç¯å¢ƒå‹æµ‹å‡ºæ¥çš„æ•°æ®ï¼Œå®Œå…¨ä¸èƒ½ç”¨åšç”Ÿäº§ç¯å¢ƒçš„å‚è€ƒã€‚ä½†æ˜¯è¿™æ ·çš„æµ‹è¯•ç¯å¢ƒåœ¨ç ”å‘é˜¶æ®µæœ‰å…¶é‡è¦ä»·å€¼ï¼š\n ä¸Šçº¿å‰å‘ç°æ€§èƒ½ç“¶é¢ˆï¼šé“¾æ¥å¼‚å¸¸ä¸ºé‡Šæ”¾ï¼Œçº¿ç¨‹æ•°è¿‡å¤šç­‰ï¼› åº”ç”¨åŸºçº¿æ•°æ®ï¼šæ¯æ¬¡ä¸Šçº¿å‰å‹ä¸€æ¬¡ï¼Œå¯¹æ¯”å†å²æ•°æ®å³å¯å‘ç°æ˜¯å¦æœ‰æå‡ï¼› å¿«é€Ÿå¸èƒ½è°ƒä¼˜åŠéªŒè¯ï¼›  å‹æµ‹åˆ¶å®šçš„è€ƒè™‘ #   æµé‡æ¨¡å‹çš„å»å®šã€‚å¯ä»¥åŸºäºä¸šåŠ¡çš„ä¸€æ®µæ—¶é—´å„æ¥å£çš„å³°å€¼ï¼Œæœ€åæ‹¼è£…æˆæµé‡æ¨¡å‹ï¼› è„æ•°æ®é—®é¢˜ã€‚æœ‰ä¸“ç”¨æµ‹è¯•è´¦æˆ·å’Œå•ç‹¬è¯·æ±‚å¤´éƒ¨ä¸¤ç§æ–¹å¼ï¼Œæœ€ç»ˆæ•°æ®è½åˆ°å½±å­åº“å’Œå½±å­è¡¨é‡Œã€‚ä»¿çœŸç¯å¢ƒè¦å¤šæµ‹è¯•ï¼Œæ•°æ®è¦æœ‰å¤šé‡æœºåˆ¶ä¿éšœï¼› ç›‘æ§è¦†ç›–åº¦è¦è¶³å¤Ÿï¼› å‹æµ‹æ‰©å±•ã€‚éªŒè¯å…¶ä»–åŠŸèƒ½ï¼Œç±»ä¼¼é™æµï¼Œç†”æ–­ï¼Œé™çº§ï¼› å‚æ•°è°ƒä¼˜ã€‚nginxé…ç½®ï¼Œlinuxå†…æ ¸å‚æ•°å¿«é€Ÿå›æ”¶ç­‰ï¼› ç¼“å­˜å’Œæ•°æ®åº“ã€‚é‡è¦ä¸šåŠ¡æœ‰ç¼“å­˜ï¼Œreids cpu é«˜æ˜¯å¦æœ‰æ¨¡ç³ŠåŒ¹é…ï¼Œé«˜æ—¶é—´å¤æ‚åº¦çš„æŒ‡ä»¤ï¼Œmysql çš„ç´¢å¼•æ·»åŠ ï¼Œæ…¢æŸ¥è¯¢ï¼› mockæœåŠ¡ã€‚è®¡è´¹ï¼ŒçŸ­ä¿¡ï¼› cpué˜ˆå€¼ã€‚50%ï½70%ï¼Œå“åº”æ—¶é—´1sä¸ºå®œï¼›   åˆ†å¸ƒå¼é” #  å¸¸ç”¨çš„åˆ†å¸ƒå¼é”çš„å®ç°æœ‰ä¸‰ç§æ–¹å¼ã€‚\n  åŸºäºrediså®ç°ï¼ˆåˆ©ç”¨redisçš„åŸå­æ€§æ“ä½œsetnxæ¥å®ç°ï¼‰\n æ¯æ¬¡è¿›æ¥å…ˆæ£€æµ‹ä¸€ä¸‹è¿™ä¸ªkeyæ˜¯å¦å®ç°ã€‚å¦‚æœå¤±æ•ˆäº†ç§»é™¤å¤±æ•ˆé” ä½¿ç”¨setnxåŸå­å‘½ä»¤äº‰æŠ¢é”ã€‚Redis Setnxï¼ˆSET if Not eXistsï¼‰ å‘½ä»¤åœ¨æŒ‡å®šçš„ key ä¸å­˜åœ¨æ—¶ï¼Œä¸º key è®¾ç½®æŒ‡å®šçš„å€¼ï¼Œç¡®è®¤è¿”å›å€¼ä¸º 1ã€‚å±äº string çš„æ•°æ®ç±»å‹ã€‚ æŠ¢åˆ°é”çš„è®¾ç½®è¿‡æœŸæ—¶é—´ã€‚EXPIRE key 10086 è®¾ç½® key ç”Ÿå­˜æ—¶é—´ä¸º 10086 ç§’   ä¼˜ç‚¹ï¼šredisæœ¬èº«æ˜¯å†…å­˜æ“ä½œã€å¹¶ä¸”é€šå¸¸æ˜¯å¤šç‰‡éƒ¨ç½²ï¼Œå› æ­¤æœ‰è¿™è¾ƒé«˜çš„å¹¶å‘æ§åˆ¶ï¼Œå¯ä»¥æŠ—ä½å¤§é‡çš„è¯·æ±‚ã€‚\nç¼ºç‚¹ï¼šredisæœ¬èº«æ˜¯ç¼“å­˜ï¼Œæœ‰ä¸€å®šæ¦‚ç‡å‡ºç°æ•°æ®ä¸ä¸€è‡´è¯·æ±‚ã€‚\n   åŸºäº mysql å®ç°ï¼ˆåˆ©ç”¨ mysql çš„ innodb çš„è¡Œé”æ¥å®ç°ï¼Œæœ‰ä¸¤ç§æ–¹å¼ï¼Œ æ’ä»–é”ä¸å…±äº«é”ï¼‰\n SELECT ... FOR UPDATE æ˜¯æ’ä»–é”ï¼Œå…¶ä»–äº‹ç‰©ä¸èƒ½è¯»å–ï¼Œä¹Ÿä¸èƒ½å†™ã€‚   ä¸ºé€‰æ‹©çš„è¡Œæ·»åŠ æ’å®ƒé”(Xé”)ï¼Œä¿è¯æŸ¥è¯¢åˆ°çš„æ•°æ®æ˜¯æœ€æ–°çš„æ•°æ®ï¼Œå…è®¸å…¶å®ƒäº‹åŠ¡å¯¹è¯¥æ•°æ®åŠ ä¸Šå…±äº«é”(Sé”)ï¼Œä½†ä¸èƒ½ä¿®æ”¹ï¼Œåªæœ‰å½“å‰äº‹åŠ¡å¯ä»¥ä¿®æ”¹ï¼Œå…¶å®ƒäº‹åŠ¡éœ€è¦ç­‰å½“å‰äº‹åŠ¡ commit æˆ– rollback ä¹‹åæ‰å¯ä»¥ä¿®æ”¹åŠ é”çš„è¡Œ;\n  SELECT ... LOCK IN SHARE MODEæ˜¯å…±äº«é”ï¼Œå…¶ä»–äº‹åŠ¡å¯ä»¥è¯»ï¼Œä½†ä¸èƒ½å†™ã€‚   ä¸ºé€‰æ‹©çš„è¡Œæ·»åŠ å…±äº«é”(Sé”)ï¼Œå…¶å®ƒäº‹åŠ¡ä¹Ÿå¯ä»¥å¯¹è¯¥è¡Œæ•°æ®æ·»åŠ Sé”ï¼Œå®ƒä¿è¯äº†è¯»å–åˆ°çš„æ˜¯æœ€æ–°çš„æ•°æ®ï¼Œå¹¶ä¸”ä¸å…è®¸åˆ«äººä¿®æ”¹ï¼Œä½†æ˜¯è‡ªå·±ä¹Ÿ ä¸ä¸€å®š èƒ½å¤Ÿä¿®æ”¹ï¼Œå› ä¸ºå¯èƒ½åˆ«çš„äº‹åŠ¡ä¹Ÿå¯¹è¿™ä¸ªæ•°æ®åŠ äº†Sé”;\n   åŸºäºZookeeperå®ç°ï¼ˆåˆ©ç”¨zkçš„ä¸´æ—¶é¡ºåºèŠ‚ç‚¹æ¥å®ç°ï¼‰\n  ä¹è§‚é”å’Œæ‚²è§‚é” #    ä¹è§‚é”(Optimistic Lock)ï¼šå‡è®¾ä¸ä¼šå‘ç”Ÿå¹¶å‘å†²çªï¼Œåªåœ¨æäº¤æ“ä½œæ—¶æ£€æŸ¥æ˜¯å¦è¿åæ•°æ®å®Œæ•´æ€§ã€‚ ä¹è§‚é”ä¸èƒ½è§£å†³è„è¯»çš„é—®é¢˜ã€‚\n  æ‚²è§‚é”(Pessimistic Lock)ï¼šå‡å®šä¼šå‘ç”Ÿå¹¶å‘å†²çªï¼Œå±è”½ä¸€åˆ‡å¯èƒ½è¿åæ•°æ®å®Œæ•´æ€§çš„æ“ä½œã€‚\n  è‡ªåŠ¨åŒ–æµ‹è¯•ç”¨ä¾‹å„ç§æ•°æ®ï¼Œç½‘ç»œå’Œç¯å¢ƒå¼‚å¸¸çš„é—®é¢˜\nhttps://tech.meituan.com/2018/01/09/lego-api-test.html\nçº¿ä¸Šé—®é¢˜çš„å¤„ç†æµç¨‹\nç›‘æ§çš„å»ºè®®å’Œå»ºæ ‘ #  ç›‘æ§å¯¹è±¡ #    ç¡¬ä»¶ç›‘æ§\n ç”µæºçŠ¶æ€ã€CPU çŠ¶æ€ã€æœºå™¨æ¸©åº¦ã€é£æ‰‡çŠ¶æ€ã€ç‰©ç†ç£ç›˜ã€raid çŠ¶æ€ã€å†…å­˜çŠ¶æ€ã€ç½‘å¡çŠ¶æ€    æœåŠ¡å™¨åŸºç¡€ç›‘æ§\n **CPUï¼š**å•ä¸ª CPU ä»¥åŠæ•´ä½“çš„ä½¿ç”¨æƒ…å†µã€‚ **å†…å­˜ï¼š**å·²ç”¨å†…å­˜ã€å¯ç”¨å†…å­˜ã€‚ **ç£ç›˜ï¼š**ç£ç›˜ä½¿ç”¨ç‡ã€ç£ç›˜è¯»å†™çš„ååé‡ã€‚ **ç½‘ç»œï¼š**å‡ºå£æµé‡ã€å…¥å£æµé‡ã€TCP è¿æ¥çŠ¶æ€ã€‚    æ•°æ®åº“ç›‘æ§\n æ•°æ®åº“è¿æ¥æ•°ã€QPSã€TPSã€å¹¶è¡Œå¤„ç†çš„ä¼šè¯æ•°ã€ç¼“å­˜å‘½ä¸­ç‡ã€ä¸»ä»å»¶æ—¶ã€é”çŠ¶æ€ã€æ…¢æŸ¥è¯¢    ä¸­é—´ä»¶ç›‘æ§\n **Nginxï¼š**æ´»è·ƒè¿æ¥æ•°ã€ç­‰å¾…è¿æ¥æ•°ã€ä¸¢å¼ƒè¿æ¥æ•°ã€è¯·æ±‚é‡ã€è€—æ—¶ã€5XX é”™è¯¯ç‡ã€‚ **Tomcatï¼š**æœ€å¤§çº¿ç¨‹æ•°ã€å½“å‰çº¿ç¨‹æ•°ã€è¯·æ±‚é‡ã€è€—æ—¶ã€é”™è¯¯é‡ã€å †å†…å­˜ä½¿ç”¨æƒ…å†µã€GC æ¬¡æ•°å’Œè€—æ—¶ã€‚ **ç¼“å­˜ï¼š**æˆåŠŸè¿æ¥æ•°ã€é˜»å¡è¿æ¥æ•°ã€å·²ä½¿ç”¨å†…å­˜ã€å†…å­˜ç¢ç‰‡ç‡ã€è¯·æ±‚é‡ã€è€—æ—¶ã€ç¼“å­˜å‘½ä¸­ç‡ã€‚ **æ¶ˆæ¯é˜Ÿåˆ—ï¼š**è¿æ¥æ•°ã€é˜Ÿåˆ—æ•°ã€ç”Ÿäº§é€Ÿç‡ã€æ¶ˆè´¹é€Ÿç‡ã€æ¶ˆæ¯å †ç§¯é‡ã€‚    åº”ç”¨ç›‘æ§\n **HTTP æ¥å£ï¼š**URL å­˜æ´»ã€è¯·æ±‚é‡ã€è€—æ—¶ã€å¼‚å¸¸é‡ã€‚ **RPC æ¥å£ï¼š**è¯·æ±‚é‡ã€è€—æ—¶ã€è¶…æ—¶é‡ã€æ‹’ç»é‡ã€‚ **JVMï¼š**GC æ¬¡æ•°ã€GC è€—æ—¶ã€å„ä¸ªå†…å­˜åŒºåŸŸçš„å¤§å°ã€å½“å‰çº¿ç¨‹æ•°ã€æ­»é”çº¿ç¨‹æ•°ã€‚ **çº¿ç¨‹æ± ï¼š**æ´»è·ƒçº¿ç¨‹æ•°ã€ä»»åŠ¡é˜Ÿåˆ—å¤§å°ã€ä»»åŠ¡æ‰§è¡Œè€—æ—¶ã€æ‹’ç»ä»»åŠ¡æ•°ã€‚ **è¿æ¥æ± ï¼š**æ€»è¿æ¥æ•°ã€æ´»è·ƒè¿æ¥æ•°ã€‚ **æ—¥å¿—ç›‘æ§ï¼š**è®¿é—®æ—¥å¿—ã€é”™è¯¯æ—¥å¿—ã€‚ **ä¸šåŠ¡æŒ‡æ ‡ï¼š**è§†ä¸šåŠ¡æ¥å®šï¼Œæ¯”å¦‚ PVã€è®¢å•é‡ç­‰ã€‚    è´¨é‡ç®¡ç†çš„å»ºæ ‘\nå°å·¥å…·çš„å¼€å‘ç›®çš„\nCI è¿‡ç¨‹çš„æ£€æŸ¥ç‚¹å’Œé€€å‡ºæ—¶æœº\nå¤§æµé‡æ´»åŠ¨å®¹é‡çš„é¢„ä¼°ç­–ç•¥\nhttps://tech.meituan.com/2016/09/28/stress-test-before-promotion.html\næµ‹è¯•ç†è®º #  é»‘ç›’æµ‹è¯•æ–¹æ³• #  ç­‰ä»·ç±»åˆ’åˆ†æ³•ï¼›è¾¹ç•Œå€¼åˆ†ææ³•ï¼›å› æœå›¾æ³•ï¼›åœºæ™¯æ³•ï¼›æ­£äº¤å®éªŒè®¾è®¡æ³•ï¼›åˆ¤å®šè¡¨é©±åŠ¨åˆ†ææ³•ï¼›é”™è¯¯æ¨æµ‹æ³•ï¼›åŠŸèƒ½å›¾åˆ†ææ³•ã€‚\nè®¾è®¡ç”¨ä¾‹çš„æ–¹æ³• #  "});index.add({'id':4,'href':'/myWiki/docs/shell/','title':"Shell",'section':"Docs",'content':"Shell è®°å½• #  è®¡ç®—ç”¨å‘½ä»¤åˆ—è¡¨ #     å‘½ä»¤ æ„ä¹‰     sort -k1 -nr sort æ’åˆ—è®¡ç®—ï¼Œä¸å¸¦å‚æ•°ä¼šå°†å…ƒç´ å½’ç±»ï¼›-k1 ä»¥ç¬¬ä¸€åˆ—ä¸ºå…³é”®è¯ï¼›-nrçš„nä»£è¡¨å…³é”®è¯æ˜¯ number æ•°å­—ï¼Œr ä»£è¡¨ reverse å€’å™è¾“å‡ºã€‚   uniq -c uniq çœç•¥é‡å¤è¡Œã€‚-cä»£è¡¨è®¡æ•°   date +%d/%b/%Y:%H:%M Nginx æ—¥å¿—æ—¥æœŸæ ¼å¼çš„ dataï¼Œdate -d '-1 minute' +%d/%b/%Y:%H:%Må½“å‰æ—¶é—´çš„å‰ä¸€åˆ†é’Ÿ        AWK éœ€è¦è®°å½•çš„å†…å»ºå˜é‡ #     å˜é‡å æ„ä¹‰     $0 æ•´è¡Œçš„å†…å®¹   NR ä»1å¼€å§‹çš„è¡Œæ•°   OFS è¾“å‡ºå­—æ®µåˆ†éš”ç¬¦ï¼ŒOFS=\u0026quot;\\t\u0026quot;è¾“å‡ºç”¨åˆ¶è¡¨ç¬¦æ¥åˆ†åˆ—   NF å½“å‰è®°å½•ä¸­çš„å­—æ®µä¸ªæ•°ï¼Œå°±æ˜¯æœ‰å¤šå°‘åˆ—ã€‚$NF æœ€åä¸€åˆ—æ•°æ®    AWK æ­£åˆ™ä¸ grep çš„å¯¹æ¯” #  # ä¸‹é¢æ“ä½œç›¸ç­‰ grep \u0026#34;TIME_WAIT\u0026#34; netstat.txt awk \u0026#39;/TIME_WAIT/\u0026#39; netstat.txt # ä¸‹é¢æ“ä½œç›¸ç­‰ grep -v \u0026#34;TIME_WAIT\u0026#34; netstat.txt awk \u0026#39;!/TIME_WAIT/\u0026#39; netstat.txt è®¡ç®—å½“å‰æ–‡ä»¶å¤¹æ€»å¤§å° #  ls -l | awk \u0026#39;NR!=1{sum+=$5}END{print sum}\u0026#39; è®¡ç®— nginx æ—¥å¿—ä¸­ ip æ•°é‡å‰å #  awk \u0026#39;{a[$1]++}END{for(i in a)print a[i]\u0026#34; \u0026#34;i}\u0026#39; access.log | sort -k1 -nr | head -10 awk \u0026#39;{print $1}\u0026#39; access.log |sort | uniq -c | sort -k1 -nr | head -10 ç»Ÿè®¡æ—¥å¿—ä¸­è®¿é—®å¤§äº100æ¬¡çš„ IP #  awk \u0026#39;{a[$1]++}END{for(i in a)if{a[i]\u0026gt;100 print a[i]\u0026#34;, \u0026#34;i}}\u0026#39; access.log ç»Ÿè®¡æŸæ—¶é—´æ®µå†…è®¿é—®æœ€å¤šçš„10ä¸ªIP #  awk \u0026#39;$4\u0026gt;=\u0026#34;[9/Apr/2016:00:00:01\u0026#34; \u0026amp;\u0026amp; $4\u0026lt;=\u0026#34;[9/Apr/2016:23:59:59\u0026#34; {a[$1]++}END{for(i in a)print a[i],i}\u0026#39; access.log |sort -k1 -nr|head -n10 ç»Ÿè®¡æ¯ä¸ªURLè®¿é—®å†…å®¹çš„æ€»å¤§å°ï¼ˆ$body_bytes_sentï¼‰ #  awk \u0026#39;{a[$7]++;size[$7]+=$10}END{for(i in a)print a[i],size[i],i}\u0026#39; access.log ç»Ÿè®¡è®¿é—®çŠ¶æ€ç ä¸º404çš„IPåŠå‡ºç°æ¬¡æ•° #  awk \u0026#39;{if($9~/404/)a[$1\u0026#34; \u0026#34;$9]++}END{for(i in a)print i,a[i]}\u0026#39; access.log "});index.add({'id':8,'href':'/myWiki/docs/go-language/go-notes/','title':"go è¯­è¨€ä¸€äº›ç¬”è®°",'section':"go è¯­è¨€",'content':"ä¸€äº›ç¬”è®° #  1\u0026lt;\u0026lt;31 // 2çš„31æ¬¡æ–¹ map çš„ç©ºå€¼ #  a := make(map[int]bool) fmt.Println(a[0]) // false b := make(map[int]int) fmt.Println(b[0]) // 0 c := make(map[int]string) fmt.Println(c[0]) // \u0026#34;\u0026#34; ç©ºå­—ç¬¦ä¸² string å­—ç¬¦ä¸²è¿­ä»£ #   ä½¿ç”¨ for+i è¿­ä»£å­—ç¬¦ä¸²æ—¶ï¼Œè·å–å…ƒç´ ç±»å‹æ˜¯ byte ä½¿ç”¨ for + range è¿­ä»£å­—ç¬¦ä¸²æ—¶ï¼Œè·å–å…ƒç´ ç±»å‹æ˜¯ rune  è½¬åŒ–ä¸ºäºŒè¿›åˆ¶å­—ç¬¦ä¸² #  s := fmt.Sprintf(\u0026#34;%b\u0026#34;, C) make ä¸ new #  newï¼š è¿”å›çš„æ°¸è¿œæ˜¯æŒ‡é’ˆï¼ŒæŒ‡å‘åˆ†é…ç±»å‹çš„åœ°å€ã€‚åŒæ—¶æŠŠåˆ†é…çš„å†…å­˜ç½®é›¶ï¼›\nmakeï¼šè¿”å› chanï¼Œmapï¼Œsliceï¼Œæœ¬èº«ã€‚è¿™ä¸‰ç§ç±»å‹æ˜¯é¥®ç”¨ç±»å‹ï¼Œæ²¡æœ‰å¿…è¦è¿”å›æŒ‡é’ˆï¼›make(type, len, cap)ï¼Œåˆå§‹åŒ–ä¸€ä¸ª type ç±»å‹çš„ï¼Œå…¶ä¸­å‰ len ä¸ªå…ƒç´ éƒ½èµ‹é›¶å€¼ï¼Œæœ€é•¿é•¿åº¦ä¸º capã€‚\n"});index.add({'id':9,'href':'/myWiki/docs/arithmetic/example/binarysearch/','title':"äºŒåˆ†æŸ¥æ‰¾ binary search",'section':"æ —å­ğŸŒ°",'content':"äºŒåˆ†æŸ¥æ‰¾ binary search #   äºŒåˆ†æŸ¥æ‰¾ ...  func search(nums []int, target int) int { left, right := 0, len(nums)-1 for left \u0026lt;= right { mid := left + (right-left)/2 if nums[mid] == target { return mid } if nums[mid] \u0026gt; target { right = mid - 1 continue } left = mid + 1 } return -1 }     "});index.add({'id':10,'href':'/myWiki/docs/arithmetic/example/binarytree/','title':"äºŒå‰æ ‘ binary tree",'section':"æ —å­ğŸŒ°",'content':"äºŒå‰æ ‘ binary tree #   åè½¬äºŒå‰æ ‘ ...  /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func invertTree(root *TreeNode) *TreeNode { if root == nil { return nil } root.Right, root.Left = invertTree(root.Left), invertTree(root.Right) return root }      äºŒå‰æ ‘çš„æœ€å¤§æ·±åº¦ ...  /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ // é€’å½’æ–¹å¼ func maxDepth(root *TreeNode) int { if root == nil { return 0 } if root.Right == nil \u0026amp;\u0026amp; root.Left == nil { return 1 } leftDepth := maxDepth(root.Left) rightDepth := maxDepth(root.Right) if leftDepth \u0026gt; rightDepth { return 1+leftDepth } return 1+rightDepth } // BFS è¿­ä»£æ–¹å¼ func maxDepth(root *TreeNode) int { if root == nil { return 0 } queue := []*TreeNode{root,} depth := 0 for len(queue) \u0026gt; 0{ size := len(queue) for i:=0;i\u0026lt;size;i++{ node := queue[0] queue = queue[1:] if node.Left != nil { queue = append(queue, node.Left) } if node.Right != nil { queue = append(queue, node.Right) } } depth = depth+1 } return depth }      åˆå¹¶äºŒå‰æ ‘ ...  /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func mergeTrees(t1 *TreeNode, t2 *TreeNode) *TreeNode { if t1 == nil { return t2 } if t2 == nil { return t1 } var nodeLeft *TreeNode var nodeRight *TreeNode if t1.Left == nil \u0026amp;\u0026amp; t1.Right == nil { nodeLeft = t2.Left nodeRight = t2.Right } if t2.Left == nil \u0026amp;\u0026amp; t2.Right == nil { nodeLeft = t1.Left nodeRight = t1.Right } if nodeLeft == nil { nodeLeft = mergeTrees(t1.Left, t2.Left) } if nodeRight == nil { nodeRight = mergeTrees(t1.Right, t2.Right) } node := TreeNode{ Val: t1.Val+t2.Val, Left: nodeLeft, Right: nodeRight, } return \u0026amp;node }      äºŒå‰æ ‘å±‚æ¬¡éå†2 ...  /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func levelOrderBottom(root *TreeNode) [][]int { if root == nil { return nil } queue := []*TreeNode{root} result := [][]int{} for len(queue) \u0026gt; 0 { levelVal := []int{} size := len(queue) for i:=0;i\u0026lt;size;i++ { levelVal = append(levelVal, queue[i].Val) if queue[i].Left != nil { queue = append(queue, queue[i].Left) } if queue[i].Right != nil { queue = append(queue, queue[i].Right) } } queue = queue[size:] result = append([][]int{levelVal}, result...) } return result }      å°†æœ‰åºæ•°ç»„è½¬åŒ–ä¸ºé«˜åº¦å¹³è¡¡äºŒå‰æœç´¢æ ‘ ...  func sortedArrayToBST(nums []int) *TreeNode { if len(nums) \u0026lt;=0 { return nil } if len(nums) == 1 { return \u0026amp;TreeNode{Val:nums[0]} } mid := len(nums)/2 return \u0026amp;TreeNode{ Val: nums[mid], Left: sortedArrayToBST(nums[:mid]), Right: sortedArrayToBST(nums[mid+1:]), } }      å¯¹ç§°äºŒå‰æ ‘ ...  /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ // é€’å½’éå†ï¼Œä¼ å…¥åŒæ ‘ï¼Œé€’å½’å¯¹æ¯”å·¦æ ‘å’Œå³ func isSymmetric(root *TreeNode) bool { return checker(root, root) } func checker(left, right *TreeNode) bool { if left == nil \u0026amp;\u0026amp; right == nil { return true } if left == nil || right == nil { return false } return left.Val == right.Val \u0026amp;\u0026amp; checker(left.Left, right.Right) \u0026amp;\u0026amp; checker(left.Right, right.Left) } // è¿­ä»£éå†ï¼Œç”¨é˜Ÿåˆ—ç¼“å­˜å–ä¸€åŒä¸€åŒè‡ªå·¦æ ‘å’Œå³æ ‘çš„é•œåƒèŠ‚ç‚¹ã€‚ç„¶åä»é˜Ÿåˆ—ä¸­å–å‡ºä¸€åŒæ¥è¿›è¡ŒèŠ‚ç‚¹å€¼å¯¹æ¯”ã€‚ç›¸ç­‰å°±æŠŠä¸¤ä¸ªå¯¹æ¯”å®Œçš„èŠ‚ç‚¹çš„é•œåƒå€¼ä¸€åŒä¸€åŒå­˜è¿›é˜Ÿåˆ—ã€‚ func isSymmetric(root *TreeNode) bool { queue := []*TreeNode{ root, root, } for len(queue) \u0026gt; 0 { left, right := queue[0], queue[1] queue = queue[2:] if left == nil \u0026amp;\u0026amp; right == nil { continue } if left == nil || right == nil { return false } if left.Val != right.Val { return false } queue = append(queue, left.Left) queue = append(queue, right.Right) queue = append(queue, left.Right) queue = append(queue, right.Left) } return true }      äºŒå‰æ ‘æ·±åº¦ ...  /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func maxDepth(root *TreeNode) int { if root == nil { return 0 } if root.Left == nil \u0026amp;\u0026amp; root.Right == nil { return 1 } leftDepth := maxDepth(root.Left) rightDepth := maxDepth(root.Right) if leftDepth \u0026gt; rightDepth { return 1 + leftDepth } return 1 + rightDepth }      äºŒå‰æ ‘ä¸­åºéå† ...  /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ // é€’å½’æ–¹å¼ func inorderTraversal(root *TreeNode) []int { if root == nil { return []int{} } if root.Left == nil \u0026amp;\u0026amp; root.Right == nil { return []int{root.Val} } leftList := inorderTraversal(root.Left) rightList := inorderTraversal(root.Right) result := append(leftList, root.Val) result = append(result, rightList...) return result } // è¿­ä»£æ–¹å¼ /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func inorderTraversal(root *TreeNode) []int { if root == nil { return []int{} } if root.Left == nil \u0026amp;\u0026amp; root.Right == nil { return []int{root.Val} } result := []int{} stack := []*TreeNode{root} for len(stack) \u0026gt; 0 { node := stack[len(stack)-1] if node.Left != nil { stack = append(stack, node.Left) node.Left = nil continue } stack = stack[:len(stack)-1] result = append(result, node.Val) if node.Right != nil { stack = append(stack, node.Right) node.Right = nil } } return result }     "});index.add({'id':11,'href':'/myWiki/docs/arithmetic/example/bitoperation/','title':"ä½è¿ç®— bit operation",'section':"æ —å­ğŸŒ°",'content':"ä½è¿ç®— bit operation #   IP åˆ° CIDR ...  #!/usr/bin/env python # -*- coding: utf-8 -*- def ipToCIDR(ip, range): \u0026#34;\u0026#34;\u0026#34; :type ip: str :type range: int :rtype: List[str] \u0026#34;\u0026#34;\u0026#34; ipInt = ipToInt(ip) ans = [] x = 0 while x \u0026lt; range: zeros = countZeros(ipInt + x) while x + (1\u0026lt;\u0026lt;zeros) \u0026gt; range: zeros -= 1 ans.append(intToIp(ipInt + x) + \u0026#34;/\u0026#34; + str(32 - zeros)) x += 1\u0026lt;\u0026lt;zeros return ans def ipToInt(ip): ans = 0 for idx, part in enumerate(ip.split(\u0026#39;.\u0026#39;)[::-1]): ans += int(part) \u0026lt;\u0026lt; idx * 8 return ans def intToIp(ipInt): ans = [] for x in xrange(4): ans.append((ipInt \u0026gt;\u0026gt; x * 8) \u0026amp; 255) return \u0026#39;.\u0026#39;.join(map(str, ans[::-1])) def countZeros(ip): cnt = 0 while ip: if ip \u0026amp; 1: break cnt += 1 ip \u0026gt;\u0026gt;= 1 return cnt if __name__ == \u0026#39;__main__\u0026#39;: print(ipToCIDR(\u0026#34;255.0.0.7\u0026#34;, 11))      åªå‡ºç°ä¸€æ¬¡çš„æ•°å­— ...  ç­”æ¡ˆæ˜¯ä½¿ç”¨ä½è¿ç®—ã€‚å¯¹äºè¿™é“é¢˜ï¼Œå¯ä½¿ç”¨å¼‚æˆ–è¿ç®— âŠ•ã€‚\nfunc singleNumber(nums []int) int { single := 0 for _, num := range nums { single ^= num } return single }      æ±‰æ˜è·ç¦» ...  // æ ‡å‡†åº“æ–¹æ³• func hammingDistance(x int, y int) int { return bits.OnesCount(uint(x) ^ uint(y)) } // é€šè¿‡ä½ç§»è®¡ç®—å¼‚æˆ–ç»“æœçš„1çš„ä¸ªæ•° func hammingDistance(x int, y int) int { distance := 0 xor := x^y for xor\u0026gt;0 { if xor\u0026amp;1 == 1 { distance = distance + 1 } xor = xor\u0026gt;\u0026gt;1 } return distance } // å¸ƒèµ–æ©Â·å…‹å°¼æ ¹ç®—æ³• // å½“æˆ‘ä»¬åœ¨ number å’Œ number-1 ä¸Šåš AND ä½è¿ç®—æ—¶ï¼ŒåŸæ•°å­— number çš„æœ€å³è¾¹ç­‰äº 1 çš„æ¯”ç‰¹ä¼šè¢«ç§»é™¤ã€‚ func hammingDistance(x int, y int) int { distance := 0 xor := x^y for xor\u0026gt;0 { distance = distance + 1 xor = xor \u0026amp; (xor-1) } return distance }      äºŒè¿›åˆ¶æ‰‹è¡¨ ...  // æš´åŠ›è§£æ³•ï¼Œç›´æ¥éå†æ‰€æœ‰åˆæ³•çš„æ—¶é—´ç»„åˆï¼Œè®¡ç®—â€œ1â€çš„ä¸ªæ•°çš„å’Œæ˜¯å¦ä¸è¾“å‡º num ç›¸ç­‰ func readBinaryWatch(num int) []string { ret := make([]string,0) for i:=0;i\u0026lt;12;i++{ for j:=0;j\u0026lt;=59;j++{ if bitNums(i)+bitNums(j) == num { ret =append(ret,fmt.Sprintf(\u0026#34;%d:%02d\u0026#34;,i,j)) } } } return ret } func bitNums(i int) int{ num :=0 for i\u0026gt;0{ if i%2==1{ num++ } i=i\u0026gt;\u0026gt;1 } return num }     "});index.add({'id':12,'href':'/myWiki/docs/arithmetic/example/hashmap/','title':"å“ˆå¸Œè¡¨ hash map",'section':"æ —å­ğŸŒ°",'content':"å“ˆå¸Œè¡¨ hash map #   å®çŸ³ä¸çŸ³å¤´ ...  func numJewelsInStones(J string, S string) int { jewels := make(map[string]struct{}) result := 0 for i:=0;i\u0026lt;len(J);i++{ jewels[string(J[i])] = struct{}{} } for i:=0;i\u0026lt;len(S);i++{ if _, ok := jewels[string(S[i])];ok { result = result + 1 } } return result }      å²›å±¿çš„å‘¨é•¿ ...  // å¼ºè¡Œéå†æ‰€æœ‰èŠ‚ç‚¹çš„å››å‘¨ï¼Œåˆ¤æ–­å››å‘¨æ ¼å­çš„ç±»å‹æ¥è®¡ç®—æ˜¯å¦å‘¨é•¿+1 func islandPerimeter(grid [][]int) int { perimeter := 0 for i:=0;i\u0026lt;len(grid);i++{ sum := 0 for j:=0;j\u0026lt;len(grid[0]);j++{ if grid[i][j] == 0{ continue } if j-1\u0026lt;0 || grid[i][j-1] == 0 {sum++} if i-1\u0026lt;0 || grid[i-1][j] == 0 {sum++} if j+1\u0026gt;=len(grid[0]) || grid[i][j+1] == 0 {sum++} if i+1\u0026gt;=len(grid) || grid[i+1][j] == 0 {sum++} } perimeter = perimeter + sum } return perimeter } // DFS é€’å½’éå†å²›å±¿çš„æ ¼å­ï¼Œé€šè¿‡åˆ¤æ–­æ˜¯å¦ä¸‹ä¸€æ¬¡è¿›å…¥çš„æ ¼å­çš„ç±»å‹å’Œæ˜¯å¦å·²ç»éå†è¿‡ï¼Œæ¥è¿”å›è®¡å…¥å‘¨é•¿çš„è¾¹é•¿æ˜¯1è¿˜æ˜¯0 func islandPerimeter(grid [][]int) int { for r:=0;r\u0026lt;len(grid);r++{ for c:=0;c\u0026lt;len(grid[0]);c++{ if grid[r][c] == 1 { return dfs(grid, r, c) } } } return 0 } func dfs(grid [][]int, r int, c int) int { if !(0 \u0026lt;= r \u0026amp;\u0026amp; r \u0026lt; len(grid) \u0026amp;\u0026amp; 0 \u0026lt;= c \u0026amp;\u0026amp; c \u0026lt; len(grid[0])) { return 1 } if grid[r][c] == 0 { return 1 } if grid[r][c] == 2 { return 0 } grid[r][c] = 2 return dfs(grid, r+1, c) + dfs(grid, r, c+1) + dfs(grid, r-1, c) + dfs(grid, r, c-1) }      ä¸¤ä¸ªæ•°ç»„çš„äº¤é›† ...  func intersection(nums1 []int, nums2 []int) []int { result := []int{} setMap := make(map[int]bool) for _, v := range nums1 { setMap[v] = false } for _, v := range nums2 { if sight, exist := setMap[v]; !sight \u0026amp;\u0026amp; exist { setMap[v] = true result = append(result, v) } } return result }     "});index.add({'id':13,'href':'/myWiki/docs/arithmetic/example/string/','title':"å­—ç¬¦ä¸² string",'section':"æ —å­ğŸŒ°",'content':"å­—ç¬¦ä¸² string #   ç½—é©¬æ•°å­—è½¬æ•´æ•° ...  ç›´æ¥ä½¿ç”¨ hash map ä½œä¸ºç´¢å¼•ä¼šæ¯”è¾ƒçœäº‹\nfunc romanToInt(s string) int { tranMap := map[string]int { \u0026#34;I\u0026#34;: 1, \u0026#34;V\u0026#34;: 5, \u0026#34;X\u0026#34;: 10, \u0026#34;L\u0026#34;: 50, \u0026#34;C\u0026#34;: 100, \u0026#34;D\u0026#34;: 500, \u0026#34;M\u0026#34;: 1000, \u0026#34;IV\u0026#34;: 4, \u0026#34;IX\u0026#34;: 9, \u0026#34;XL\u0026#34;: 40, \u0026#34;XC\u0026#34;: 90, \u0026#34;CD\u0026#34;: 400, \u0026#34;CM\u0026#34;: 900, } sList := strings.Split(s, \u0026#34;\u0026#34;) result := 0 for i:=0;i\u0026lt;len(sList);i++ { if i == len(sList) -1 { result = result + tranMap[sList[i]] continue } if v, ok := tranMap[sList[i]+sList[i+1]];ok{ result = result + v i = i + 1 continue } result = result + tranMap[sList[i]] } return result }      æœ‰æ•ˆçš„æ‹¬å· ...  func isValid(s string) bool { parMap := map[rune]rune { \u0026#39;(\u0026#39;: \u0026#39;0\u0026#39;, \u0026#39;{\u0026#39;: \u0026#39;0\u0026#39;, \u0026#39;[\u0026#39;: \u0026#39;0\u0026#39;, \u0026#39;)\u0026#39;: \u0026#39;(\u0026#39;, \u0026#39;}\u0026#39;: \u0026#39;{\u0026#39;, \u0026#39;]\u0026#39;: \u0026#39;[\u0026#39;, } parQueue := []rune{} for _, v := range s { if _, ok := parMap[v]; !ok { continue } if parMap[v] == \u0026#39;0\u0026#39; { parQueue = append(parQueue, v) continue } if len(parQueue) == 0 {return false} if parMap[v] != parQueue[len(parQueue)-1] { return false } parQueue = parQueue[:len(parQueue)-1] } if len(parQueue) \u0026gt; 0 {return false} return true }      æœ€é•¿å…¬å…±å‰ç¼€ ...  func longestCommonPrefix(strs []string) string { if len(strs) == 0 { return \u0026#34;\u0026#34; } if len(strs) == 1 { return strs[0] } mid := len(strs)/2 left := longestCommonPrefix(strs[:mid]) right := longestCommonPrefix(strs[mid:]) var length int if len(left) \u0026lt; len(right) { length = len(left) } else { length = len(right) } result := \u0026#34;\u0026#34; for i:=0;i\u0026lt;length;i++ { if left[i] != right[i] { break } result = result + string(left[i]) } return result }      äºŒè¿›åˆ¶æ±‚å’Œ ...  // å¯¹é½æœ«å°¾å­—ç¬¦ï¼ŒåŒæ—¶å­—ç¬¦â€œç›¸åŠ â€ï¼Œé€šè¿‡ carry çš„å€¼ä¼ é€’è¿›ä½ã€‚æ¯ä½çš„ç»“æœä½ carry+a[i]+b[i]ï¼Œç•™ä¸‹çš„ç»“æœä½ä¸º %2 çš„ç»“æœï¼Œä¸‹ä¸€æ¬¡çš„è¿›ä½ä¸º /2 çš„ç»“æœã€‚ func addBinary(a string, b string) string { result, carry, n := \u0026#34;\u0026#34;, 0, 0 if len(a) \u0026gt; len(b) { n = len(a) } else { n = len(b) } for i:=0; i\u0026lt;n; i++ { if i \u0026lt; len(a) { carry = carry + int(a[len(a)-1-i] - \u0026#39;0\u0026#39;) // å½“å­—ç¬¦ä¸²ä¸­ a[len(a)-1-i] ä¸º \u0026#34;0\u0026#34; æ—¶ï¼Œä¹‹é™…æ“ä½œæ¸¸æ ‡å–å‡ºçš„æ˜¯ uint8=48 ç±»å‹æ˜¯ byteï¼Œç›´æ¥ int è½¬æ¢å°±ä¼šå¾—åˆ°ä¸€ä¸ª int=48ï¼›å½“[-\u0026#39;\u0026#39;0\u0026#39;]ä¹‹åï¼Œç›¸å½“æ˜¯ utf8 ç¼–ç çš„ä¸¤ä¸ª 48 ç›¸å‡ï¼Œè·å¾—çš„æ˜¯ uint8=0ï¼Œint è½¬æ¢ä¹‹åå°±ä¼šå¾—åˆ°ä¸€ä¸ª int ç±»å‹çš„ 0ã€‚å¦‚æœè¯¥ä½ä¸º \u0026#34;1\u0026#34;ï¼Œç”±äºæ­£å¥½æ¯”\u0026#34;0\u0026#34;å¤š1ä¸ªç¼–ç ä½ï¼Œæ‰€ä»¥å¾—åˆ°çš„å°±æ˜¯ uint8=1ï¼Œint è½¬æ¢å³å¯å¾—åˆ° 1ã€‚  } if i \u0026lt; len(b) { carry = carry + int(b[len(b)-1-i] - \u0026#39;0\u0026#39;) } result = strconv.Itoa(carry%2) + result // result = fmt.Sprintf(\u0026#34;%b%s\u0026#34;, carry%2, result)  carry = carry / 2 } if carry \u0026gt; 0 { result = \u0026#34;1\u0026#34; + result } return result }      å­—ç¬¦ä¸²ç›¸åŠ  ...  func addStrings(num1 string, num2 string) string { carry, n := 0, 0 result := \u0026#34;\u0026#34; if len(num1) \u0026gt; len(num2) { n = len(num1) } else { n = len(num2) } for i:=0; i\u0026lt;n; i ++ { if i \u0026lt; len(num1) { carry = carry + int(num1[len(num1)-1-i] - \u0026#39;0\u0026#39;) } if i \u0026lt; len(num2) { carry = carry + int(num2[len(num2)-1-i] - \u0026#39;0\u0026#39;) } result = strconv.Itoa(carry%10) + result carry = carry / 10 } if carry\u0026gt;0 { result = strconv.Itoa(carry) + result } return result }      éªŒè¯å›æ–‡ä¸² ...  func isPalindrome(s string) bool { left, right := 0, len(s)-1 for left \u0026lt;= right { for left \u0026lt; right \u0026amp;\u0026amp; !isalnum(s[left]) { left = left + 1 } for left \u0026lt; right \u0026amp;\u0026amp; !isalnum(s[right]) { right = right - 1 } if strings.ToLower(string(s[left])) != strings.ToLower(string(s[right])) { return false } left, right = left+1, right-1 } return true } func isalnum(ch byte) bool { return (ch \u0026gt;= \u0026#39;A\u0026#39; \u0026amp;\u0026amp; ch \u0026lt;= \u0026#39;Z\u0026#39;) || (ch \u0026gt;= \u0026#39;a\u0026#39; \u0026amp;\u0026amp; ch \u0026lt;= \u0026#39;z\u0026#39;) || (ch \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; ch \u0026lt;= \u0026#39;9\u0026#39;) }      æ— é‡å¤å­—ç¬¦çš„æœ€é•¿å­ä¸² ...  // åŒæ¸¸æ ‡é…åˆ map[å­—æ¯]index ç»„æˆçš„æ»‘åŠ¨çª—å£ func lengthOfLongestSubstring(s string) int { result, sMap := 0, map[byte]int{} for left, right:=0, 0; right\u0026lt;len(s); right++ { if v, ok := sMap[s[right]]; ok { left = max(left, v) // å·¦æŒ‡é’ˆåªåœ¨æœ€å¤§çš„ä¸€æ–¹ \u0026#34;abba\u0026#34;  } result = max(result, right-left+1) sMap[s[right]] = right + 1 } return result } func max(a, b int) int { if a \u0026gt; b { return a } return b }      æ‹¬å·ç”Ÿæˆ ...  func generateParenthesis(n int) []string { result := new([]string) backtrack(\u0026#34;\u0026#34;, n, n, result) return *result } func backtrack(path string, left, right int, result *[]string) { if left == 0 \u0026amp;\u0026amp; right == 0 { *result = append(*result, path) return } if left \u0026gt; 0 { backtrack(path+\u0026#34;(\u0026#34;, left-1, right, result) } if right \u0026gt; left { backtrack(path+\u0026#34;)\u0026#34;, left, right-1, result) } }      æœ€é•¿å›æ–‡ä¸² ...  func longestPalindrome(s string) int { sMap := map[byte]int{} for i:=0; i\u0026lt;len(s); i++ { if v, ok := sMap[s[i]]; ok { sMap[s[i]] = v + 1 } else { sMap[s[i]] = 1 } } result, less := 0, 0 for _, v := range sMap { mod := v % 2 result = result + v - mod less = less + mod } if less \u0026gt;0 { return result+1 } return result }       Z å­—å½¢å˜æ¢ ...  func convert(s string, numRows int) string { if numRows \u0026lt;= 1 {return s} listS := make([]string, numRows) i, flag := 0, -1 for _, v := range s { listS[i] = listS[i] + string(v) if i == numRows-1 || i == 0 { flag = -flag } i = i + flag } resutl := \u0026#34;\u0026#34; for _, v := range listS { resutl = resutl + v } return resutl }      ç”µè¯å·ç çš„å­—æ¯ç»„åˆ ...  func letterCombinations(digits string) []string { if len(digits) \u0026lt;= 0 {return nil} digitsMap := map[byte][]string{ \u0026#39;2\u0026#39;: []string{\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;}, \u0026#39;3\u0026#39;: []string{\u0026#34;d\u0026#34;, \u0026#34;e\u0026#34;, \u0026#34;f\u0026#34;}, \u0026#39;4\u0026#39;: []string{\u0026#34;g\u0026#34;, \u0026#34;h\u0026#34;, \u0026#34;i\u0026#34;}, \u0026#39;5\u0026#39;: []string{\u0026#34;j\u0026#34;, \u0026#34;k\u0026#34;, \u0026#34;l\u0026#34;}, \u0026#39;6\u0026#39;: []string{\u0026#34;m\u0026#34;, \u0026#34;n\u0026#34;, \u0026#34;o\u0026#34;}, \u0026#39;7\u0026#39;: []string{\u0026#34;p\u0026#34;, \u0026#34;q\u0026#34;, \u0026#34;r\u0026#34;, \u0026#34;s\u0026#34;}, \u0026#39;8\u0026#39;: []string{\u0026#34;t\u0026#34;, \u0026#34;u\u0026#34;, \u0026#34;v\u0026#34;}, \u0026#39;9\u0026#39;: []string{\u0026#34;w\u0026#34;, \u0026#34;x\u0026#34;, \u0026#34;y\u0026#34;, \u0026#34;z\u0026#34;}, } path := \u0026#34;\u0026#34; result := []string{} backtrack(path, digits, \u0026amp;result, digitsMap) return result } func backtrack(path, digits string, result *[]string, digitsMap map[byte][]string) { if len(path) == len(digits) { *result = append(*result, path) return } i := len(path) for _, v := range digitsMap[digits[i]] { backtrack(path+v, digits, result, digitsMap) } }      åˆ†å‰²å›æ–‡ä¸² ...  func partition(s string) [][]string { length := len(s) result := [][]string{} if length == 0 { return result } pathList := []string{} backtrack(pathList, s, 0, length, \u0026amp;result) return result } func backtrack(pathList []string, s string, index int, length int, result *[][]string) { if index \u0026gt;= length { tmp := make([]string, len(pathList)) copy(tmp, pathList) *result = append(*result, tmp) return } for i:=index; i\u0026lt;length; i++ { if !isPalindrome(s, index, i){ continue } pathList = append(pathList, s[index:i+1]) backtrack(pathList, s, i+1, length, result) pathList = pathList[:len(pathList)-1] } } func isPalindrome(s string, left, right int) bool { for left \u0026lt;= right { if s[left] != s[right] { return false } left = left + 1 right = right -1 } return true }     "});index.add({'id':14,'href':'/myWiki/docs/arithmetic/example/mathematics/','title':"æ•°å­¦ mathematics",'section':"æ —å­ğŸŒ°",'content':"æ•°å­¦ mathematics #   æ•´æ•°åè½¬ ...  func reverse(x int) int { y := 0 for x != 0 { y = y*10 + x%10 x = x/10 } if y \u0026lt; -(1\u0026lt;\u0026lt;31) || y \u0026gt; (1\u0026lt;\u0026lt;31)-1 { return 0 } return y }     "});index.add({'id':15,'href':'/myWiki/docs/arithmetic/example/array/','title':"æ•°ç»„ array",'section':"æ —å­ğŸŒ°",'content':"æ•°ç»„ array #   ä¸¤æ•°ä¹‹å’Œ ...  func twoSum(nums []int, target int) []int { result := map[int]int{} for i:=0;i\u0026lt;len(nums);i++{ if k, exist := result[target-nums[i]];exist { return []int{k, i} } result[nums[i]] = i } return nil }      åˆå¹¶ä¸¤ä¸ªæœ‰åºæ•°ç»„ ...   åˆå¹¶æœ‰åºæ•°åˆ—ï¼Œä¸ä¸€å®šä»å°åˆ°å¤§åˆå¹¶ï¼Œä¹Ÿå¯ä»¥ä»å¤§åˆ°å°åˆå¹¶ï¼› ç¬¬ä¸€ä¸ªæ•°ç»„æœ‰ç©ºé—´ä½™é‡ï¼Œç›´æ¥æ“ä½œæ¯”åˆ›å»ºæ–°å˜é‡ç©ºé—´åˆé€‚ï¼›  func merge(nums1 []int, m int, nums2 []int, n int) { p1 := m-1 p2 := n-1 p3 := m+n-1 for ;p1\u0026gt;=0\u0026amp;\u0026amp;p2\u0026gt;=0;p3--{ if nums1[p1] \u0026lt; nums2[p2] { nums1[p3] = nums2[p2] p2 = p2-1 continue } nums1[p3] = nums1[p1] p1 = p1-1 } for i:=0;i\u0026lt;p2+1;i++{ nums1[i] = nums2[i] } return nums1 }      ä¸¤æ•°ä¹‹å’Œ II - è¾“å…¥æœ‰åºæ•°ç»„ ...  åˆå§‹æ—¶ä¸¤ä¸ªæŒ‡é’ˆåˆ†åˆ«æŒ‡å‘ç¬¬ä¸€ä¸ªå…ƒç´ ä½ç½®å’Œæœ€åä¸€ä¸ªå…ƒç´ çš„ä½ç½®ã€‚æ¯æ¬¡è®¡ç®—ä¸¤ä¸ªæŒ‡é’ˆæŒ‡å‘çš„ä¸¤ä¸ªå…ƒç´ ä¹‹å’Œï¼Œå¹¶å’Œç›®æ ‡å€¼æ¯”è¾ƒã€‚å¦‚æœä¸¤ä¸ªå…ƒç´ ä¹‹å’Œç­‰äºç›®æ ‡å€¼ï¼Œåˆ™å‘ç°äº†å”¯ä¸€è§£ã€‚å¦‚æœä¸¤ä¸ªå…ƒç´ ä¹‹å’Œå°äºç›®æ ‡å€¼ï¼Œåˆ™å°†å·¦ä¾§æŒ‡é’ˆå³ç§»ä¸€ä½ã€‚å¦‚æœä¸¤ä¸ªå…ƒç´ ä¹‹å’Œå¤§äºç›®æ ‡å€¼ï¼Œåˆ™å°†å³ä¾§æŒ‡é’ˆå·¦ç§»ä¸€ä½ã€‚ç§»åŠ¨æŒ‡é’ˆä¹‹åï¼Œé‡å¤ä¸Šè¿°æ“ä½œï¼Œç›´åˆ°æ‰¾åˆ°ç­”æ¡ˆã€‚\nfunc twoSum(numbers []int, target int) []int { low, high := 0, len(numbers) - 1 for low \u0026lt; high { sum := numbers[low] + numbers[high] if sum == target { return []int{low + 1, high + 1} } else if sum \u0026lt; target { low++ } else { high-- } } return []int{-1, -1} }       æœç´¢æ—‹è½¬æ’åºæ•°ç»„ ...  func search(nums []int, target int) int { left := 0 right := len(nums) - 1 for left \u0026lt;= right { mid := (left + right) / 2 if nums[mid] == target { return mid } // åˆ¤æ–­æ˜¯å¦åœ¨å‰åŠéƒ¨åˆ†æŸ¥æ‰¾ \tif (nums[left] \u0026lt;= target \u0026amp;\u0026amp; target \u0026lt;= nums[mid]) || (nums[mid] \u0026lt;= nums[right] \u0026amp;\u0026amp; (target \u0026lt; nums[mid] || target \u0026gt; nums[right])) { right = mid - 1 } else { left = mid + 1 } } return -1 }      äºŒç»´æ•°ç»„ä¸­çš„æŸ¥æ‰¾ ...  func findNumberIn2DArray(matrix [][]int, target int) bool { if len(matrix) == 0 || len(matrix[0]) == 0 { return false } r, c := 0, len(matrix[0])-1 for r\u0026lt;len(matrix) \u0026amp;\u0026amp; c\u0026gt;=0 { if matrix[r][c] == target { return true } if matrix[r][c] \u0026gt; target { c = c - 1 continue } if matrix[r][c] \u0026lt; target { r = r + 1 continue } } return false }      å¿«é€Ÿæ’åº ...  // çœŸå¿«é€Ÿæ’åº func sortArray(nums []int) []int { quickSortHelper(nums, 0, len(nums)-1) return nums } func quickSortHelper(nums []int, left, right int) { if left \u0026lt; right { pivot := partition(nums, left, right) quickSortHelper(nums, left, pivot-1) quickSortHelper(nums, pivot+1, right) } } func partition(nums []int, left, right int) int { pivotValue := nums[right] i := left - 1 for j:=left; j\u0026lt;right; j++ { if nums[j] \u0026lt;= pivotValue { i = i + 1 swap(nums, i, j) } } swap(nums, i+1, right) return i+1 } func swap(nums []int, i, j int) { nums[i], nums[j] = nums[j], nums[i] } // ä¼ªå¿«é€Ÿæ’åº func sortArray(nums []int) []int { if len(nums) \u0026lt; 2 { return nums } lessList, greatList := []int{}, []int{} for _, v := range nums[1:] { if v \u0026lt; nums[0] { lessList = append(lessList, v) continue } greatList = append(greatList, v) } result := append([]int{}, sortArray(lessList)...) result = append(result, nums[0]) result = append(result, sortArray(greatList)...) return result } // å†’æ³¡æ’åº func sortArray(nums []int) []int { if len(nums) \u0026lt; 2 { return nums } for i:=0; i\u0026lt;len(nums); i++ { for j:=0; j\u0026lt;len(nums)-i; j++ { if nums[j] \u0026gt; nums[j+1] { nums[j], nums[j+1] = nums[j+1], nums[j] } } } return nums }      ä¸‰æ•°ä¹‹å’Œ ...  func threeSum(nums []int) [][]int { n := len(nums) sort.Ints(nums) // å…ˆæ’åº  result := [][]int{} for i:=0; i\u0026lt;n; i++ { if i \u0026gt; 0 \u0026amp;\u0026amp; nums[i] == nums[i-1] { //å›ºå®šä½ä½æ¸¸æ ‡å»é‡  continue } right := n-1 for left:=i+1; left\u0026lt;n; left++ { //è¿­ä»£ç§»åŠ¨å·¦æ¸¸æ ‡ï¼Œä¸åœå³ç§»å¢åŠ   if left\u0026gt;i+1 \u0026amp;\u0026amp; nums[left] == nums[left-1]{ //å¤§äºåˆå§‹å€¼çš„å·¦æ¸¸æ ‡å»é‡  continue } for left\u0026lt;right \u0026amp;\u0026amp; nums[i]+nums[left]+nums[right]\u0026gt;0 { //å·¦å³æ¸¸æ ‡ä¸èƒ½äº¤å‰  right = right - 1 //ä¸‰å€¼å’Œå¤§äº0ï¼Œå³æ¸¸æ ‡ä¸åœå¾€å·¦ç§»ï¼Œå€¼è¶Šæ¥è¶Šå°‘  } if left == right {break} //æ¸¸æ ‡ç›¸é‡ï¼Œç›´æ¥é€€å‡ºè¿­ä»£  if nums[i]+nums[left]+nums[right] == 0 { result = append(result, []int{nums[i], nums[left], nums[right]}) } } } return result }      å²›å±¿çš„æœ€å¤§é¢ç§¯ ...  func maxAreaOfIsland(grid [][]int) int { result := 0 for r:=0; r\u0026lt;len(grid); r++ { for c:=0; c\u0026lt;len(grid[0]); c++ { if grid[r][c] == 1 { value := helper(r, c, grid) if result \u0026lt; value { result = value } } } } return result } func helper(r, c int, grid [][]int) int { if r \u0026lt; 0 || r \u0026gt; len(grid) - 1 || c \u0026lt; 0 || c \u0026gt; len(grid[0]) - 1 { return 0 } if grid[r][c] == 0 || grid[r][c] == 2 { return 0 } grid[r][c] = 2 return 1 + helper(r+1, c, grid) + helper(r-1, c, grid) + helper(r, c+1, grid) + helper(r, c-1, grid) }       æœ€é•¿è¿ç»­é€’å¢åºåˆ— ...  func findLengthOfLCIS(nums []int) int { if len(nums) \u0026lt;= 1 { return len(nums) } result, tmp := 1, 1 for i:=0; i\u0026lt;len(nums)-1; i++ { if nums[i] \u0026lt; nums[i+1] { tmp = tmp + 1 } else { tmp = 1 } if tmp \u0026gt; result { result = tmp } } return result }      æ•°ç»„ä¸­çš„ç¬¬kä¸ªæœ€å¤§å…ƒç´  ...  // å¿«é€Ÿé€‰æ‹©ç®—æ³• import \u0026#34;math/rand\u0026#34; func findKthLargest(nums []int, k int) int { rand.Seed(time.Now().UnixNano()) left, right := 0, len(nums)-1 target := len(nums) - k cur := -1 for cur != target { cur = partition(left, right, nums) if cur \u0026lt; target { left = cur + 1 } else if cur \u0026gt; target { right = cur - 1 } } return nums[cur] } func partition(left, right int, nums []int) int{ if left == right { return left } i := rand.Int() % (right - left + 1) + left n := nums[i] nums[i], nums[right] = nums[right], nums[i] l , r := left, right-1 for l \u0026lt; r { for l \u0026lt; r \u0026amp;\u0026amp; nums[l] \u0026lt;= n { l = l + 1 } for l \u0026lt; r \u0026amp;\u0026amp; n \u0026lt; nums[r] { r = r - 1 } if l != r { nums[l], nums[r] = nums[r], nums[l] } } if nums[l] \u0026gt; n { nums[l], nums[right] = nums[right], nums[l] return l } return right }       å…¨æ’åˆ— ...  func permute(nums []int) [][]int { result := [][]int{} path := []int{} used := make([]bool, len(nums)) backtrack(path, nums, used, \u0026amp;result) return result } func backtrack(path, nums []int, used []bool, result *[][]int) { if len(path) == len(nums) { tmp := make([]int, len(path)) copy(tmp, path) *result = append(*result, tmp) return } for i:=0; i\u0026lt;len(nums); i++ { if !used[i] { used[i] = true path = append(path, nums[i]) backtrack(path, nums, used, result) path = path[:len(path)-1] used[i] = false } } }      ä¹˜æœ€å¤šæ°´çš„å®¹å™¨ ...  func maxArea(height []int) int { result, i, j := 0, 0, len(height)-1 for i != j { area := (j-i) * min(height[i], height[j]) if area \u0026gt; result { result = area } if height[i] \u0026lt; height[j] { i = i + 1 continue } j = j - 1 } return result } func min(i, j int) int { if i \u0026lt; j {return i} return j }      æœ€å¤§å­åºå’Œ ...  // åŠ¨æ€è§„åˆ’ func maxSubArray(nums []int) int { max := nums[0] for i:=1; i\u0026lt;len(nums); i++ { if nums[i-1] + nums[i] \u0026gt; nums[i] { nums[i] = nums[i-1] + nums[i] // é€šè¿‡å¯¹æ¯”ï¼Œå°†å½“å‰ index çš„æœ€ä¼˜è§£æ”¾åˆ°æ•°ç»„é‡Œï¼Œä»¥æ–¹ä¾¿ä¸‹ä¸ªè¿­ä»£ index å¯¹æ¯”è°ƒç”¨ã€‚  } if nums[i] \u0026gt; max { max = nums[i] } } return max }      ä¹˜ç§¯æœ€å¤§å­æ•°ç»„ ...  // æœªè€ƒè™‘ç©ºé—´å¤æ‚åº¦çš„åŠ¨æ€è§„åˆ’ func maxProduct(nums []int) int { length := len(nums) if length == 0 { return 0 } iMax, iMin := make([]int, length), make([]int, length) iMax[0], iMin[0] = nums[0], nums[0] for i:=1; i\u0026lt;length; i++ { if nums[i] \u0026gt;= 0 { iMin[i] = min(nums[i], nums[i]*iMin[i-1]) iMax[i] = max(nums[i], nums[i]*iMax[i-1]) } else { iMin[i] = min(nums[i], nums[i]*iMax[i-1]) iMax[i] = max(nums[i], nums[i]*iMin[i-1]) } } result := iMax[0] for i:=1; i\u0026lt;length; i++ { result = max(result, iMax[i]) } return result } // è¡¨æ ¼å¤ç”¨çš„åŠ¨æ€è§„åˆ’ func maxProduct(nums []int) int { length := len(nums) if length == 0 { return 0 } preMax, preMin, result := nums[0], nums[0], nums[0] var curMax, curMin int for i:=1; i\u0026lt;length; i++ { if nums[i] \u0026gt;= 0 { curMin = min(nums[i], nums[i]*preMin) curMax = max(nums[i], nums[i]*preMax) } else { curMin = min(nums[i], nums[i]*preMax) curMax = max(nums[i], nums[i]*preMin) } result = max(result, curMax) preMin, preMax = curMin, curMax } return result } func max(x, y int) int { if x \u0026gt;= y { return x } return y } func min(x,y int) int { if x \u0026lt;= y { return x } return y }     "});index.add({'id':18,'href':'/myWiki/docs/arithmetic/example/linkedlist/','title':"é“¾è¡¨ linked list",'section':"æ —å­ğŸŒ°",'content':"é“¾è¡¨ linked list #   åˆå¹¶ä¸¤ä¸ªæœ‰åºåˆ—è¡¨ ...  /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode { result := \u0026amp;ListNode{} preHead := result for (l1 != nil \u0026amp;\u0026amp; l2 != nil){ if l1.Val \u0026lt; l2.Val { preHead.Next = l1 l1 = l1.Next } else { preHead.Next = l2 l2 = l2.Next } preHead = preHead.Next } if l1 == nil{ preHead.Next = l2 } if l2 == nil { preHead.Next = l1 } return result.Next }      åè½¬é“¾è¡¨ ...  /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func reverseList(head *ListNode) *ListNode { if nil == head { return head } cur, next := head, head.Next for ; nil != next; cur, next, next.Next = next, next.Next, cur { } head.Next = nil return cur }      åˆ é™¤é“¾è¡¨ä¸­çš„èŠ‚ç‚¹ ...  /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func deleteNode(node *ListNode) { node.Val, node.Next= node.Next.Val, node.Next.Next }     "});index.add({'id':19,'href':'/myWiki/docs/go-language/dev-rule/','title':"é¢å‘å¯¹è±¡è®¾è®¡åŸåˆ™",'section':"go è¯­è¨€",'content':"é¢å‘å¯¹è±¡è®¾è®¡åŸåˆ™ #  ä¾èµ–å€’ç½®åŸåˆ™ï¼ˆDIPï¼‰\n é«˜å±‚æ¨¡å—ï¼ˆç¨³å®šï¼‰ä¸åº”è¯¥ä¾èµ–åº•å±‚æ¨¡å—ï¼ˆå˜åŒ–ï¼‰ï¼ŒäºŒè€…éƒ½åº”è¯¥ä¾èµ–æŠ½è±¡ï¼ˆç¨³å®šï¼‰ æŠ½è±¡ï¼ˆç¨³å®šï¼‰ä¸åº”è¯¥ä¾èµ–å®ç°ç»†èŠ‚ï¼ˆå˜åŒ–ï¼‰ï¼Œå®ç°ç»†èŠ‚åº”è¯¥ä¾èµ–äºæŠ½è±¡ï¼ˆç¨³å®šï¼‰  å¼€æ”¾å°é—­åŸåˆ™ï¼ˆOCPï¼‰\n å¯¹æ‰©å±•å¼€æ”¾ï¼Œå¯¹æ›´æ”¹å°é—­ ç±»æ¨¡å—åº”è¯¥å¯ä»¥æ‰©å±•çš„ï¼Œä½†æ˜¯ä¸å¯ä»¥ä¿®æ”¹çš„  å•ä¸€èŒè´£åŸåˆ™ï¼ˆLSPï¼‰\n ä¸€ä¸ªç±»åº”è¯¥ä»…æœ‰ä¸€ä¸ªå¼•èµ·ä»–å˜åŒ–çš„åŸå›  å˜åŒ–çš„æ–¹å‘éšå«è¿™ç±»çš„è´£ä»»  Liskovæ›¿æ¢åŸåˆ™ï¼ˆLSPï¼‰\n å­ç±»å¿…é¡»èƒ½å¤Ÿæ›¿æ¢ä»–ä»¬çš„åŸºç±»ï¼ˆIS-Aï¼‰ ç»§æ‰¿è¡¨è¾¾ç±»å‹æŠ½è±¡  æ¥å£éš”ç¦»åŸåˆ™ï¼ˆISPï¼‰\n ä¸åº”è¯¥å¼ºè¿«å®¢æˆ·ç¨‹åºä¾èµ–ä»–ä»¬ä¸ä½¿ç”¨çš„æ–¹æ³• æ¥å£åº”è¯¥å°è€Œå®Œå¤‡  ä¼˜å…ˆä½¿ç”¨å¯¹è±¡ç»„åˆï¼Œè€Œä¸æ˜¯ç±»ç»§æ‰¿\n ç±»ç»§æ‰¿é€šå¸¸ä¸ºâ€œç™½ç®±å¤ç”¨â€ï¼Œå¯¹è±¡ç»„åˆé€šå¸¸ä¸ºâ€œé»‘ç®±å¤ç”¨â€ ç»§æ‰¿åœ¨æŸç§ç¨‹åº¦ä¸Šç ´åäº†å°è£…æ€§ï¼Œå­ç±»çˆ¶ç±»è€¦åˆåº¦é«˜ã€‚ è€Œå¯¹è±¡ç»„åˆåˆ™æ˜¯è¦æ±‚è¢«ç»„åˆçš„å¯¹è±¡æœ‰è‰¯å¥½å®šä¹‰çš„æ¥å£ï¼Œè€¦åˆåº¦ä½ã€‚  å°è£…å˜åŒ–ç‚¹\n ä½¿ç”¨å°è£…æ¥åˆ›å»ºå¯¹è±¡ä¹‹é—´çš„åˆ†ç•Œå±‚ã€‚ç±»è®¾è®¡è€…å¯ä»¥åœ¨åˆ†ç•Œçš„ä¸€ä¾§è¿›è¡Œä¿®æ”¹ï¼Œè€Œä¸ä¼šå¯¹å¦å¤–ä¸€ä¾§äº§ç”Ÿä¸è‰¯çš„å½±å“ã€‚ä»è€Œå®ç°å±‚æ¬¡é—´çš„æ¾è€¦åˆã€‚  é’ˆå¯¹æ¥å£ç¼–ç¨‹ï¼Œè€Œä¸æ˜¯é’ˆå¯¹å®ç°ç¼–ç¨‹\n ä¸å°†å˜é‡çš„ç±»å‹å£°æ˜ä¸ºæŸä¸ªç‰¹å®šçš„å…·ä½“ç±»ï¼Œè€Œå£°æ˜ä¸ºæŸæ¥å£ï¼› å®¢æˆ·ç¨‹åºæ— éœ€è·çŸ¥å¯¹è±¡çš„å…·ä½“ç±»å‹ï¼Œåªéœ€è¦çŸ¥é“å¯¹è±¡æ‰€å…·æœ‰çš„æ¥å£ï¼› å‡å°‘ç³»ç»Ÿä¸­å„éƒ¨åˆ†çš„ä¾èµ–å…³ç³»ï¼Œä»è€Œå®ç°â€œé«˜å†…èšï¼Œä½è€¦åˆâ€  "});index.add({'id':20,'href':'/myWiki/docs/arithmetic/leetcoderanking/','title':"é«˜é¢‘é¢˜ç›®",'section':"ç®—æ³•ä¸æ•°æ®ç»“æ„",'content':"LeetCode çš„é«˜é¢‘é¢˜ç›® #  DFSï¼šæ·±åº¦ä¼˜å…ˆæœç´¢ç®—æ³•ï¼ˆDepth First Searchï¼‰ï¼Œå¯¹äºäºŒå‰æ ‘è€Œè¨€ï¼Œå®ƒæ²¿ç€æ ‘çš„æ·±åº¦éå†æ ‘çš„èŠ‚ç‚¹ï¼Œå°½å¯èƒ½æ·±çš„æœç´¢æ ‘çš„åˆ†æ”¯ï¼Œè¿™ä¸€è¿‡ç¨‹ä¸€ç›´è¿›è¡Œåˆ°å·²å‘ç°ä»æºèŠ‚ç‚¹å¯è¾¾çš„æ‰€æœ‰èŠ‚ç‚¹ä¸ºæ­¢ã€‚\nå¹³è¡¡äºŒå‰æ ‘ï¼š å·¦å³å­æ ‘çš„é«˜åº¦ç›¸å·®ä¸è¶…è¿‡ 1 çš„æ ‘ä¸ºå¹³è¡¡äºŒå‰æ ‘\n   æ’å…¥æ–¹å¼ æè¿° æ—‹è½¬æ–¹å¼     LL åœ¨ A çš„å·¦å­æ ‘æ ¹èŠ‚ç‚¹çš„å·¦å­æ ‘ä¸Šæ’å…¥èŠ‚ç‚¹è€Œç ´åå¹³è¡¡ å³æ—‹è½¬   RR åœ¨ A çš„å³å­æ ‘æ ¹èŠ‚ç‚¹çš„å³å­æ ‘ä¸Šæ’å…¥èŠ‚ç‚¹è€Œç ´åå¹³è¡¡ å·¦æ—‹è½¬   LR åœ¨Açš„å·¦å­æ ‘æ ¹èŠ‚ç‚¹çš„å³å­æ ‘ä¸Šæ’å…¥èŠ‚ç‚¹è€Œç ´åå¹³è¡¡ å…ˆå·¦æ—‹åå³æ—‹   RL åœ¨ A çš„å³å­æ ‘æ ¹èŠ‚ç‚¹çš„å·¦å­æ ‘ä¸Šæ’å…¥èŠ‚ç‚¹è€Œç ´åå¹³è¡¡ å…ˆå³æ—‹åå·¦æ—‹    XOR å¼‚æˆ–è¿ç®— âŠ• #   ä»»ä½•æ•°å’Œ 0 åšå¼‚æˆ–è¿ç®—ï¼Œç»“æœä»ç„¶æ˜¯åŸæ¥çš„æ•°ï¼Œå³ aâŠ•0=aã€‚ ä»»ä½•æ•°å’Œå…¶è‡ªèº«åšå¼‚æˆ–è¿ç®—ï¼Œç»“æœæ˜¯ 0ï¼Œå³ aâŠ•a=0ã€‚ å¼‚æˆ–è¿ç®—æ»¡è¶³äº¤æ¢å¾‹å’Œç»“åˆå¾‹ï¼Œå³ aâŠ•bâŠ•a=bâŠ•aâŠ•a=bâŠ•(aâŠ•a)=bâŠ•0=bã€‚  æ±‰æ˜è·ç¦» #  ä¸¤ä¸ªæ•´æ•°ä¹‹é—´çš„æ±‰æ˜è·ç¦»æ˜¯å¯¹åº”ä½ç½®ä¸Šæ•°å­—ä¸åŒçš„ä½æ•°ã€‚XOR çš„ä½è¿ç®—ï¼Œå½“ä¸”ä»…å½“è¾“å…¥ä½ä¸åŒæ—¶è¾“å‡ºä¸º 1ã€‚\n è®¡ç®— x å’Œ y ä¹‹é—´çš„æ±‰æ˜è·ç¦»ï¼Œå¯ä»¥å…ˆè®¡ç®— x XOR yï¼Œç„¶åç»Ÿè®¡ç»“æœä¸­ç­‰äº 1 çš„ä½æ•°ã€‚\n ä¸ºäº†è®¡ç®—ç­‰äº 1 çš„ä½æ•°ï¼Œå¯ä»¥å°†æ¯ä¸ªä½ç§»åŠ¨åˆ°æœ€å·¦ä¾§æˆ–æœ€å³ä¾§ï¼Œç„¶åæ£€æŸ¥è¯¥ä½æ˜¯å¦ä¸º 1ã€‚æ£€æŸ¥æœ€å³ä½æ˜¯å¦ä¸º 1ï¼Œå¯ä»¥ä½¿ç”¨å–æ¨¡è¿ç®—ï¼ˆi % 2ï¼‰æˆ–è€… AND æ“ä½œï¼ˆi \u0026amp; 1ï¼‰ï¼Œè¿™ä¸¤ä¸ªæ“ä½œéƒ½ä¼šå±è”½æœ€å³ä½ä»¥å¤–çš„å…¶ä»–ä½ã€‚\n  å¸ƒèµ–æ©Â·å…‹å°¼æ ¹ç®—æ³• #  è¯¥ç®—æ³•ä½¿ç”¨ç‰¹å®šæ¯”ç‰¹ä½å’Œç®—æœ¯è¿ç®—ç§»é™¤ç­‰äº 1 çš„æœ€å³æ¯”ç‰¹ä½ã€‚\n å½“æˆ‘ä»¬åœ¨ number å’Œ number-1 ä¸Šåš AND ä½è¿ç®—æ—¶ï¼ŒåŸæ•°å­— number çš„æœ€å³è¾¹ç­‰äº 1 çš„æ¯”ç‰¹ä¼šè¢«ç§»é™¤ã€‚\n äºŒè¿›åˆ¶å­—ç¬¦ä¸²çš„æ¸¸æ ‡å–å€¼æ“ä½œ #  å½“å­—ç¬¦ä¸²ä¸­ a[i] ä¸º \u0026ldquo;0\u0026rdquo; æ—¶ï¼Œä¹‹é™…æ“ä½œæ¸¸æ ‡å–å‡ºçš„æ˜¯ uint8=48 ç±»å‹æ˜¯ byteï¼Œç›´æ¥ int è½¬æ¢å°±ä¼šå¾—åˆ°ä¸€ä¸ª int=48ï¼›å½“æ“ä½œ[-\u0026lsquo;\u0026lsquo;0\u0026rsquo;]ä¹‹åï¼Œç›¸å½“æ˜¯ utf8 ç¼–ç çš„ä¸¤ä¸ª 48 ç›¸å‡ï¼Œè·å¾—çš„æ˜¯ uint8=0ï¼Œint è½¬æ¢ä¹‹åå°±ä¼šå¾—åˆ°ä¸€ä¸ª int ç±»å‹çš„ 0ã€‚å¦‚æœè¯¥ä½ä¸º \u0026ldquo;1\u0026rdquo;ï¼Œç”±äºæ­£å¥½æ¯”\u0026quot;0\u0026quot;å¤š1ä¸ªç¼–ç ä½ï¼Œæ‰€ä»¥å¾—åˆ°çš„å°±æ˜¯ uint8=1ï¼Œint è½¬æ¢å³å¯å¾—åˆ° 1ã€‚\nå›æº¯ç®—æ³•ç¼–ç å…¬å¼ #  result = [] func backtrack(è·¯å¾„ï¼Œé€‰æ‹©åˆ—è¡¨) { if æ»¡è¶³ç»“æŸæ¡ä»¶ { result.add(è·¯å¾„) } return for é€‰æ‹© in é€‰æ‹©åˆ—è¡¨ { åšé€‰æ‹© backtrack(è·¯å¾„ï¼Œé€‰æ‹©åˆ—è¡¨) æ’¤é”€é€‰æ‹© } } ä½è¿ç®— bit operation #   IP åˆ° CIDR åªå‡ºç°ä¸€æ¬¡çš„æ•°å­— äºŒè¿›åˆ¶æ‰‹è¡¨  å­—ç¬¦ä¸² string #   ç½—é©¬æ•°å­—è½¬æ•´æ•° æœ‰æ•ˆçš„æ‹¬å· æœ€é•¿å…¬å…±å‰ç¼€ï¼ˆå®ç°æ–¹æ³•æœ‰å¾…ä¼˜åŒ–ï¼‰ äºŒè¿›åˆ¶æ±‚å’Œ å­—ç¬¦ä¸²ç›¸åŠ  éªŒè¯å›æ–‡ä¸² æ— é‡å¤å­—ç¬¦çš„æœ€é•¿å­ä¸² æ‹¬å·ç”Ÿæˆ æœ€é•¿å›æ–‡ä¸² Z å­—å‹å˜æ¢ ç”µè¯å·ç çš„å­—æ¯ç»„åˆ åˆ†å‰²å›æ–‡ä¸²  æ•°å­¦ mathematics #   æ•´æ•°åè½¬  æ•°ç»„ arrary #   ä¸¤æ•°ä¹‹å’Œ åˆå¹¶ä¸¤ä¸ªæœ‰åºæ•°ç»„ ä¸¤æ•°ä¹‹å’Œ II - è¾“å…¥æœ‰åºæ•°ç»„ æœç´¢æ—‹è½¬æ’åºæ•°ç»„ äºŒç»´æ•°ç»„ä¸­çš„æŸ¥æ‰¾ å¿«é€Ÿæ’åº ä¸‰æ•°ä¹‹å’Œ å²›å±¿çš„æœ€å¤§é¢ç§¯ æœ€é•¿è¿ç»­é€’å¢åºåˆ— æ•°ç»„ä¸­çš„ç¬¬ k ä¸ªæœ€å¤§å…ƒç´  å…¨æ’åˆ— ä¹˜æœ€å¤šæ°´çš„å®¹å™¨ æœ€å¤§å­åºå’Œ æœ€å¤§ä¹˜ç§¯å­æ•°ç»„  é“¾è¡¨ linked list #   åˆå¹¶ä¸¤ä¸ªæœ‰åºé“¾è¡¨ åè½¬é“¾è¡¨ åˆ é™¤é“¾è¡¨ä¸­çš„èŠ‚ç‚¹  äºŒå‰æ ‘ binary tree #   åè½¬äºŒå‰æ ‘ äºŒå‰æ ‘çš„æœ€å¤§æ·±åº¦ åˆå¹¶äºŒå‰æ ‘ äºŒå‰æ ‘å±‚æ¬¡éå†2 å°†æœ‰åºæ•°ç»„è½¬åŒ–ä¸ºé«˜åº¦å¹³è¡¡äºŒå‰æœç´¢æ ‘ å¯¹ç§°äºŒå‰æ ‘ äºŒå‰æ ‘æ·±åº¦ äºŒå‰æ ‘ä¸­åºéå†  å“ˆå¸Œè¡¨ hash map #   å®çŸ³ä¸çŸ³å¤´ å²›å±¿çš„å‘¨é•¿ ä¸¤ä¸ªæ•°ç»„çš„äº¤é›†  äºŒåˆ†æŸ¥æ‰¾ binary search #   äºŒåˆ†æŸ¥æ‰¾  "});})();