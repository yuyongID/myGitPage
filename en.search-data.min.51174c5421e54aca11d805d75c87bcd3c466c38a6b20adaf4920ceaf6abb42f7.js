'use strict';(function(){const indexCfg={cache:true};indexCfg.doc={id:'id',field:['title','content'],store:['title','href','section'],};const index=FlexSearch.create('balance',indexCfg);window.bookSearchIndex=index;index.add({'id':0,'href':'/myWiki/docs/docker/docker-learn/','title':"Docker Learn",'section':"Docker",'content':"docker learn test #  "});index.add({'id':1,'href':'/myWiki/docs/linux/','title':"Linux",'section':"Docs",'content':"linux系统中的Load： 是对当前CPU工作量的度量 (WikiPedia: the system load is a measure of the amount of work that a computer system is doing)。也有简单的说是进程队列的长度。\n什么样的Load average值要提高警惕 #   0.7 \u0026lt; load \u0026lt; 1: 此时是不错的状态，如果进来更多的汽车，你的马路仍然可以应付。 load = 1: 你的马路即将拥堵，而且没有更多的资源额外的任务，赶紧看看发生了什么吧。 load \u0026gt; 5: 非常严重拥堵，我们的马路非常繁忙，每辆车都无法很快的运行  "});index.add({'id':2,'href':'/myWiki/docs/qa/','title':"Q\u0026 A",'section':"Docs",'content':"Python垃圾回收机制 #  Python GC主要使用引用计数（reference counting）来跟踪和回收垃圾。在引用计数的基础上，通过“标记-清除”（mark and sweep）解决容器对象可能产生的循环引用问题，通过“分代回收”（generation collection）以空间换时间的方法提高垃圾回收效率。\n1 引用计数 #  PyObject是每个对象必有的内容，其中ob_refcnt就是做为引用计数。当一个对象有新的引用时，它的ob_refcnt就会增加，当引用它的对象被删除，它的ob_refcnt就会减少.引用计数为0时，该对象生命就结束了。\n优点:\n 简单 实时性  缺点:\n 维护引用计数消耗资源 循环引用  2 标记-清除机制 #  基本思路是先按需分配，等到没有空闲内存的时候从寄存器和程序栈上的引用出发，遍历以对象为节点、以引用为边构成的图，把所有可以访问到的对象打上标记，然后清扫一遍内存空间，把所有没标记的对象释放。\n3 分代技术 #  分代回收的整体思想是：将系统中的所有内存块根据其存活时间划分为不同的集合，每个集合就成为一个“代”，垃圾收集频率随着“代”的存活时间的增大而减小，存活时间通常利用经过几次垃圾回收来度量。\nPython默认定义了三代对象集合，索引数越大，对象存活时间越长。\n举例： 当某些内存块M经过了3次垃圾收集的清洗之后还存活时，我们就将内存块M划到一个集合A中去，而新分配的内存都划分到集合B中去。当垃圾收集开始工作时，大多数情况都只对集合B进行垃圾回收，而对集合A进行垃圾回收要隔相当长一段时间后才进行，这就使得垃圾收集机制需要处理的内存少了，效率自然就提高了。在这个过程中，集合B中的某些内存块由于存活时间长而会被转移到集合A中，当然，集合A中实际上也存在一些垃圾，这些垃圾的回收会因为这种分代的机制而被延迟。\n"});index.add({'id':3,'href':'/myWiki/docs/shell/','title':"Shell",'section':"Docs",'content':"Shell 记录 #  计算用命令列表 #     命令 意义     sort -k1 -nr sort 排列计算，不带参数会将元素归类；-k1 以第一列为关键词；-nr的n代表关键词是 number 数字，r 代表 reverse 倒叙输出。   uniq -c uniq 省略重复行。-c代表计数   date +%d/%b/%Y:%H:%M Nginx 日志日期格式的 data，date -d '-1 minute' +%d/%b/%Y:%H:%M当前时间的前一分钟        AWK 需要记录的内建变量 #     变量名 意义     $0 整行的内容   NR 从1开始的行数   OFS 输出字段分隔符，OFS=\u0026quot;\\t\u0026quot;输出用制表符来分列   NF 当前记录中的字段个数，就是有多少列。$NF 最后一列数据    AWK 正则与 grep 的对比 #  # 下面操作相等 grep \u0026#34;TIME_WAIT\u0026#34; netstat.txt awk \u0026#39;/TIME_WAIT/\u0026#39; netstat.txt # 下面操作相等 grep -v \u0026#34;TIME_WAIT\u0026#34; netstat.txt awk \u0026#39;!/TIME_WAIT/\u0026#39; netstat.txt 计算当前文件夹总大小 #  ls -l | awk \u0026#39;NR!=1{sum+=$5}END{print sum}\u0026#39; 计算 nginx 日志中 ip 数量前十 #  awk \u0026#39;{a[$1]++}END{for(i in a)print a[i]\u0026#34; \u0026#34;i}\u0026#39; access.log | sort -k1 -nr | head -10 awk \u0026#39;{print $1}\u0026#39; access.log |sort | uniq -c | sort -k1 -nr | head -10 统计日志中访问大于100次的 IP #  awk \u0026#39;{a[$1]++}END{for(i in a)if{a[i]\u0026gt;100 print a[i]\u0026#34;, \u0026#34;i}}\u0026#39; access.log 统计某时间段内访问最多的10个IP #  awk \u0026#39;$4\u0026gt;=\u0026#34;[9/Apr/2016:00:00:01\u0026#34; \u0026amp;\u0026amp; $4\u0026lt;=\u0026#34;[9/Apr/2016:23:59:59\u0026#34; {a[$1]++}END{for(i in a)print a[i],i}\u0026#39; access.log |sort -k1 -nr|head -n10 统计每个URL访问内容的总大小（$body_bytes_sent） #  awk \u0026#39;{a[$7]++;size[$7]+=$10}END{for(i in a)print a[i],size[i],i}\u0026#39; access.log 统计访问状态码为404的IP及出现次数 #  awk \u0026#39;{if($9~/404/)a[$1\u0026#34; \u0026#34;$9]++}END{for(i in a)print i,a[i]}\u0026#39; access.log "});index.add({'id':7,'href':'/myWiki/docs/go-language/go-notes/','title':"go 语言一些笔记",'section':"go 语言",'content':"一些笔记 #  1\u0026lt;\u0026lt;31 // 2的31次方 map 的空值 #  a := make(map[int]bool) fmt.Println(a[0]) // false b := make(map[int]int) fmt.Println(b[0]) // 0 c := make(map[int]string) fmt.Println(c[0]) // \u0026#34;\u0026#34; 空字符串 string 字符串迭代 #   使用 for+i 迭代字符串时，获取元素类型是 byte 使用 for + range 迭代字符串时，获取元素类型是 rune  转化为二进制字符串 #  s := fmt.Sprintf(\u0026#34;%b\u0026#34;, C) "});index.add({'id':8,'href':'/myWiki/docs/arithmetic/example/binarysearch/','title':"二分查找 binary search",'section':"栗子🌰",'content':"二分查找 binary search #   二分查找 ...  func search(nums []int, target int) int { left, right := 0, len(nums)-1 for left \u0026lt;= right { mid := left + (right-left)/2 if nums[mid] == target { return mid } if nums[mid] \u0026gt; target { right = mid - 1 continue } left = mid + 1 } return -1 }     "});index.add({'id':9,'href':'/myWiki/docs/arithmetic/example/binarytree/','title':"二叉树 binary tree",'section':"栗子🌰",'content':"二叉树 binary tree #   反转二叉树 ...  /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func invertTree(root *TreeNode) *TreeNode { if root == nil { return nil } root.Right, root.Left = invertTree(root.Left), invertTree(root.Right) return root }      二叉树的最大深度 ...  /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ // 递归方式 func maxDepth(root *TreeNode) int { if root == nil { return 0 } if root.Right == nil \u0026amp;\u0026amp; root.Left == nil { return 1 } leftDepth := maxDepth(root.Left) rightDepth := maxDepth(root.Right) if leftDepth \u0026gt; rightDepth { return 1+leftDepth } return 1+rightDepth } // BFS 迭代方式 func maxDepth(root *TreeNode) int { if root == nil { return 0 } queue := []*TreeNode{root,} depth := 0 for len(queue) \u0026gt; 0{ size := len(queue) for i:=0;i\u0026lt;size;i++{ node := queue[0] queue = queue[1:] if node.Left != nil { queue = append(queue, node.Left) } if node.Right != nil { queue = append(queue, node.Right) } } depth = depth+1 } return depth }      合并二叉树 ...  /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func mergeTrees(t1 *TreeNode, t2 *TreeNode) *TreeNode { if t1 == nil { return t2 } if t2 == nil { return t1 } var nodeLeft *TreeNode var nodeRight *TreeNode if t1.Left == nil \u0026amp;\u0026amp; t1.Right == nil { nodeLeft = t2.Left nodeRight = t2.Right } if t2.Left == nil \u0026amp;\u0026amp; t2.Right == nil { nodeLeft = t1.Left nodeRight = t1.Right } if nodeLeft == nil { nodeLeft = mergeTrees(t1.Left, t2.Left) } if nodeRight == nil { nodeRight = mergeTrees(t1.Right, t2.Right) } node := TreeNode{ Val: t1.Val+t2.Val, Left: nodeLeft, Right: nodeRight, } return \u0026amp;node }      二叉树层次遍历2 ...  /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func levelOrderBottom(root *TreeNode) [][]int { if root == nil { return nil } queue := []*TreeNode{root} result := [][]int{} for len(queue) \u0026gt; 0 { levelVal := []int{} size := len(queue) for i:=0;i\u0026lt;size;i++ { levelVal = append(levelVal, queue[i].Val) if queue[i].Left != nil { queue = append(queue, queue[i].Left) } if queue[i].Right != nil { queue = append(queue, queue[i].Right) } } queue = queue[size:] result = append([][]int{levelVal}, result...) } return result }      将有序数组转化为高度平衡二叉搜索树 ...  func sortedArrayToBST(nums []int) *TreeNode { if len(nums) \u0026lt;=0 { return nil } if len(nums) == 1 { return \u0026amp;TreeNode{Val:nums[0]} } mid := len(nums)/2 return \u0026amp;TreeNode{ Val: nums[mid], Left: sortedArrayToBST(nums[:mid]), Right: sortedArrayToBST(nums[mid+1:]), } }      对称二叉树 ...  /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ // 递归遍历，传入双树，递归对比左树和右 func isSymmetric(root *TreeNode) bool { return checker(root, root) } func checker(left, right *TreeNode) bool { if left == nil \u0026amp;\u0026amp; right == nil { return true } if left == nil || right == nil { return false } return left.Val == right.Val \u0026amp;\u0026amp; checker(left.Left, right.Right) \u0026amp;\u0026amp; checker(left.Right, right.Left) } // 迭代遍历，用队列缓存取一双一双自左树和右树的镜像节点。然后从队列中取出一双来进行节点值对比。相等就把两个对比完的节点的镜像值一双一双存进队列。 func isSymmetric(root *TreeNode) bool { queue := []*TreeNode{ root, root, } for len(queue) \u0026gt; 0 { left, right := queue[0], queue[1] queue = queue[2:] if left == nil \u0026amp;\u0026amp; right == nil { continue } if left == nil || right == nil { return false } if left.Val != right.Val { return false } queue = append(queue, left.Left) queue = append(queue, right.Right) queue = append(queue, left.Right) queue = append(queue, right.Left) } return true }      二叉树深度 ...  /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func maxDepth(root *TreeNode) int { if root == nil { return 0 } if root.Left == nil \u0026amp;\u0026amp; root.Right == nil { return 1 } leftDepth := maxDepth(root.Left) rightDepth := maxDepth(root.Right) if leftDepth \u0026gt; rightDepth { return 1 + leftDepth } return 1 + rightDepth }      二叉树中序遍历 ...  /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ // 递归方式 func inorderTraversal(root *TreeNode) []int { if root == nil { return []int{} } if root.Left == nil \u0026amp;\u0026amp; root.Right == nil { return []int{root.Val} } leftList := inorderTraversal(root.Left) rightList := inorderTraversal(root.Right) result := append(leftList, root.Val) result = append(result, rightList...) return result } // 迭代方式 /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func inorderTraversal(root *TreeNode) []int { if root == nil { return []int{} } if root.Left == nil \u0026amp;\u0026amp; root.Right == nil { return []int{root.Val} } result := []int{} stack := []*TreeNode{root} for len(stack) \u0026gt; 0 { node := stack[len(stack)-1] if node.Left != nil { stack = append(stack, node.Left) node.Left = nil continue } stack = stack[:len(stack)-1] result = append(result, node.Val) if node.Right != nil { stack = append(stack, node.Right) node.Right = nil } } return result }     "});index.add({'id':10,'href':'/myWiki/docs/arithmetic/example/bitoperation/','title':"位运算 bit operation",'section':"栗子🌰",'content':"位运算 bit operation #   IP 到 CIDR ...  #!/usr/bin/env python # -*- coding: utf-8 -*- def ipToCIDR(ip, range): \u0026#34;\u0026#34;\u0026#34; :type ip: str :type range: int :rtype: List[str] \u0026#34;\u0026#34;\u0026#34; ipInt = ipToInt(ip) ans = [] x = 0 while x \u0026lt; range: zeros = countZeros(ipInt + x) while x + (1\u0026lt;\u0026lt;zeros) \u0026gt; range: zeros -= 1 ans.append(intToIp(ipInt + x) + \u0026#34;/\u0026#34; + str(32 - zeros)) x += 1\u0026lt;\u0026lt;zeros return ans def ipToInt(ip): ans = 0 for idx, part in enumerate(ip.split(\u0026#39;.\u0026#39;)[::-1]): ans += int(part) \u0026lt;\u0026lt; idx * 8 return ans def intToIp(ipInt): ans = [] for x in xrange(4): ans.append((ipInt \u0026gt;\u0026gt; x * 8) \u0026amp; 255) return \u0026#39;.\u0026#39;.join(map(str, ans[::-1])) def countZeros(ip): cnt = 0 while ip: if ip \u0026amp; 1: break cnt += 1 ip \u0026gt;\u0026gt;= 1 return cnt if __name__ == \u0026#39;__main__\u0026#39;: print(ipToCIDR(\u0026#34;255.0.0.7\u0026#34;, 11))      只出现一次的数字 ...  答案是使用位运算。对于这道题，可使用异或运算 ⊕。\nfunc singleNumber(nums []int) int { single := 0 for _, num := range nums { single ^= num } return single }      汉明距离 ...  // 标准库方法 func hammingDistance(x int, y int) int { return bits.OnesCount(uint(x) ^ uint(y)) } // 通过位移计算异或结果的1的个数 func hammingDistance(x int, y int) int { distance := 0 xor := x^y for xor\u0026gt;0 { if xor\u0026amp;1 == 1 { distance = distance + 1 } xor = xor\u0026gt;\u0026gt;1 } return distance } // 布赖恩·克尼根算法 // 当我们在 number 和 number-1 上做 AND 位运算时，原数字 number 的最右边等于 1 的比特会被移除。 func hammingDistance(x int, y int) int { distance := 0 xor := x^y for xor\u0026gt;0 { distance = distance + 1 xor = xor \u0026amp; (xor-1) } return distance }     "});index.add({'id':11,'href':'/myWiki/docs/arithmetic/example/hashmap/','title':"哈希表 hash map",'section':"栗子🌰",'content':"哈希表 hash map #   宝石与石头 ...  func numJewelsInStones(J string, S string) int { jewels := make(map[string]struct{}) result := 0 for i:=0;i\u0026lt;len(J);i++{ jewels[string(J[i])] = struct{}{} } for i:=0;i\u0026lt;len(S);i++{ if _, ok := jewels[string(S[i])];ok { result = result + 1 } } return result }      岛屿的周长 ...  // 强行遍历所有节点的四周，判断四周格子的类型来计算是否周长+1 func islandPerimeter(grid [][]int) int { perimeter := 0 for i:=0;i\u0026lt;len(grid);i++{ sum := 0 for j:=0;j\u0026lt;len(grid[0]);j++{ if grid[i][j] == 0{ continue } if j-1\u0026lt;0 || grid[i][j-1] == 0 {sum++} if i-1\u0026lt;0 || grid[i-1][j] == 0 {sum++} if j+1\u0026gt;=len(grid[0]) || grid[i][j+1] == 0 {sum++} if i+1\u0026gt;=len(grid) || grid[i+1][j] == 0 {sum++} } perimeter = perimeter + sum } return perimeter } // DFS 递归遍历岛屿的格子，通过判断是否下一次进入的格子的类型和是否已经遍历过，来返回计入周长的边长是1还是0 func islandPerimeter(grid [][]int) int { for r:=0;r\u0026lt;len(grid);r++{ for c:=0;c\u0026lt;len(grid[0]);c++{ if grid[r][c] == 1 { return dfs(grid, r, c) } } } return 0 } func dfs(grid [][]int, r int, c int) int { if !(0 \u0026lt;= r \u0026amp;\u0026amp; r \u0026lt; len(grid) \u0026amp;\u0026amp; 0 \u0026lt;= c \u0026amp;\u0026amp; c \u0026lt; len(grid[0])) { return 1 } if grid[r][c] == 0 { return 1 } if grid[r][c] == 2 { return 0 } grid[r][c] = 2 return dfs(grid, r+1, c) + dfs(grid, r, c+1) + dfs(grid, r-1, c) + dfs(grid, r, c-1) }      两个数组的交集 ...  func intersection(nums1 []int, nums2 []int) []int { result := []int{} setMap := make(map[int]bool) for _, v := range nums1 { setMap[v] = false } for _, v := range nums2 { if sight, exist := setMap[v]; !sight \u0026amp;\u0026amp; exist { setMap[v] = true result = append(result, v) } } return result }     "});index.add({'id':12,'href':'/myWiki/docs/arithmetic/example/string/','title':"字符串 string",'section':"栗子🌰",'content':"字符串 string #   罗马数字转整数 ...  直接使用 hash map 作为索引会比较省事\nfunc romanToInt(s string) int { tranMap := map[string]int { \u0026#34;I\u0026#34;: 1, \u0026#34;V\u0026#34;: 5, \u0026#34;X\u0026#34;: 10, \u0026#34;L\u0026#34;: 50, \u0026#34;C\u0026#34;: 100, \u0026#34;D\u0026#34;: 500, \u0026#34;M\u0026#34;: 1000, \u0026#34;IV\u0026#34;: 4, \u0026#34;IX\u0026#34;: 9, \u0026#34;XL\u0026#34;: 40, \u0026#34;XC\u0026#34;: 90, \u0026#34;CD\u0026#34;: 400, \u0026#34;CM\u0026#34;: 900, } sList := strings.Split(s, \u0026#34;\u0026#34;) result := 0 for i:=0;i\u0026lt;len(sList);i++ { if i == len(sList) -1 { result = result + tranMap[sList[i]] continue } if v, ok := tranMap[sList[i]+sList[i+1]];ok{ result = result + v i = i + 1 continue } result = result + tranMap[sList[i]] } return result }      有效的括号 ...  func isValid(s string) bool { parMap := map[rune]rune { \u0026#39;(\u0026#39;: \u0026#39;0\u0026#39;, \u0026#39;{\u0026#39;: \u0026#39;0\u0026#39;, \u0026#39;[\u0026#39;: \u0026#39;0\u0026#39;, \u0026#39;)\u0026#39;: \u0026#39;(\u0026#39;, \u0026#39;}\u0026#39;: \u0026#39;{\u0026#39;, \u0026#39;]\u0026#39;: \u0026#39;[\u0026#39;, } parQueue := []rune{} for _, v := range s { if _, ok := parMap[v]; !ok { continue } if parMap[v] == \u0026#39;0\u0026#39; { parQueue = append(parQueue, v) continue } if len(parQueue) == 0 {return false} if parMap[v] != parQueue[len(parQueue)-1] { return false } parQueue = parQueue[:len(parQueue)-1] } if len(parQueue) \u0026gt; 0 {return false} return true }      最长公共前缀 ...  func longestCommonPrefix(strs []string) string { if len(strs) == 0 { return \u0026#34;\u0026#34; } if len(strs) == 1 { return strs[0] } mid := len(strs)/2 left := longestCommonPrefix(strs[:mid]) right := longestCommonPrefix(strs[mid:]) var length int if len(left) \u0026lt; len(right) { length = len(left) } else { length = len(right) } result := \u0026#34;\u0026#34; for i:=0;i\u0026lt;length;i++ { if left[i] != right[i] { break } result = result + string(left[i]) } return result }      二进制求和 ...  // 对齐末尾字符，同时字符“相加”，通过 carry 的值传递进位。每位的结果位 carry+a[i]+b[i]，留下的结果位为 %2 的结果，下一次的进位为 /2 的结果。 func addBinary(a string, b string) string { result, carry, n := \u0026#34;\u0026#34;, 0, 0 if len(a) \u0026gt; len(b) { n = len(a) } else { n = len(b) } for i:=0; i\u0026lt;n; i++ { if i \u0026lt; len(a) { carry = carry + int(a[len(a)-1-i] - \u0026#39;0\u0026#39;) // 当字符串中 a[len(a)-1-i] 为 \u0026#34;0\u0026#34; 时，之际操作游标取出的是 uint8=48 类型是 byte，直接 int 转换就会得到一个 int=48；当[-\u0026#39;\u0026#39;0\u0026#39;]之后，相当是 utf8 编码的两个 48 相减，获得的是 uint8=0，int 转换之后就会得到一个 int 类型的 0。如果该位为 \u0026#34;1\u0026#34;，由于正好比\u0026#34;0\u0026#34;多1个编码位，所以得到的就是 uint8=1，int 转换即可得到 1。  } if i \u0026lt; len(b) { carry = carry + int(b[len(b)-1-i] - \u0026#39;0\u0026#39;) } result = strconv.Itoa(carry%2) + result // result = fmt.Sprintf(\u0026#34;%b%s\u0026#34;, carry%2, result)  carry = carry / 2 } if carry \u0026gt; 0 { result = \u0026#34;1\u0026#34; + result } return result }      字符串相加 ...  func addStrings(num1 string, num2 string) string { carry, n := 0, 0 result := \u0026#34;\u0026#34; if len(num1) \u0026gt; len(num2) { n = len(num1) } else { n = len(num2) } for i:=0; i\u0026lt;n; i ++ { if i \u0026lt; len(num1) { carry = carry + int(num1[len(num1)-1-i] - \u0026#39;0\u0026#39;) } if i \u0026lt; len(num2) { carry = carry + int(num2[len(num2)-1-i] - \u0026#39;0\u0026#39;) } result = strconv.Itoa(carry%10) + result carry = carry / 10 } if carry\u0026gt;0 { result = strconv.Itoa(carry) + result } return result }      验证回文串 ...  func isPalindrome(s string) bool { left, right := 0, len(s)-1 for left \u0026lt;= right { for left \u0026lt; right \u0026amp;\u0026amp; !isalnum(s[left]) { left = left + 1 } for left \u0026lt; right \u0026amp;\u0026amp; !isalnum(s[right]) { right = right - 1 } if strings.ToLower(string(s[left])) != strings.ToLower(string(s[right])) { fmt.Print(string(s[left]), string(s[right])) return false } left, right = left+1, right-1 } return true } func isalnum(ch byte) bool { return (ch \u0026gt;= \u0026#39;A\u0026#39; \u0026amp;\u0026amp; ch \u0026lt;= \u0026#39;Z\u0026#39;) || (ch \u0026gt;= \u0026#39;a\u0026#39; \u0026amp;\u0026amp; ch \u0026lt;= \u0026#39;z\u0026#39;) || (ch \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; ch \u0026lt;= \u0026#39;9\u0026#39;) }     "});index.add({'id':13,'href':'/myWiki/docs/arithmetic/example/mathematics/','title':"数学 mathematics",'section':"栗子🌰",'content':"数学 mathematics #   整数反转 ...  func reverse(x int) int { y := 0 for x != 0 { y = y*10 + x%10 x = x/10 } if y \u0026lt; -(1\u0026lt;\u0026lt;31) || y \u0026gt; (1\u0026lt;\u0026lt;31)-1 { return 0 } return y }     "});index.add({'id':14,'href':'/myWiki/docs/arithmetic/example/array/','title':"数组 array",'section':"栗子🌰",'content':"数组 array #   两数之和 ...  func twoSum(nums []int, target int) []int { result := map[int]int{} for i:=0;i\u0026lt;len(nums);i++{ if k, exist := result[target-nums[i]];exist { fmt.Println(k, i) return []int{k, i} } result[nums[i]] = i } return nil }      合并两个有序数组 ...   合并有序数列，不一定从小到大合并，也可以从大到小合并； 第一个数组有空间余量，直接操作比创建新变量空间合适；  func merge(nums1 []int, m int, nums2 []int, n int) { p1 := m-1 p2 := n-1 p3 := m+n-1 for ;p1\u0026gt;=0\u0026amp;\u0026amp;p2\u0026gt;=0;p3--{ if nums1[p1] \u0026lt; nums2[p2] { nums1[p3] = nums2[p2] p2 = p2-1 continue } nums1[p3] = nums1[p1] p1 = p1-1 } for i:=0;i\u0026lt;p2+1;i++{ nums1[i] = nums2[i] } }      两数之和 II - 输入有序数组 ...  初始时两个指针分别指向第一个元素位置和最后一个元素的位置。每次计算两个指针指向的两个元素之和，并和目标值比较。如果两个元素之和等于目标值，则发现了唯一解。如果两个元素之和小于目标值，则将左侧指针右移一位。如果两个元素之和大于目标值，则将右侧指针左移一位。移动指针之后，重复上述操作，直到找到答案。\nfunc twoSum(numbers []int, target int) []int { low, high := 0, len(numbers) - 1 for low \u0026lt; high { sum := numbers[low] + numbers[high] if sum == target { return []int{low + 1, high + 1} } else if sum \u0026lt; target { low++ } else { high-- } } return []int{-1, -1} }       搜索旋转排序数组 ...  func search(nums []int, target int) int { left := 0 right := len(nums) - 1 for left \u0026lt;= right { mid := (left + right) / 2 if nums[mid] == target { return mid } // 判断是否在前半部分查找 \tif (nums[left] \u0026lt;= target \u0026amp;\u0026amp; target \u0026lt;= nums[mid]) || (nums[mid] \u0026lt;= nums[right] \u0026amp;\u0026amp; (target \u0026lt; nums[mid] || target \u0026gt; nums[right])) { right = mid - 1 } else { left = mid + 1 } } return -1 }      二维数组中的查找 ...  func findNumberIn2DArray(matrix [][]int, target int) bool { if len(matrix) == 0 || len(matrix[0]) == 0 { return false } r, c := 0, len(matrix[0])-1 for r\u0026lt;len(matrix) \u0026amp;\u0026amp; c\u0026gt;=0 { if matrix[r][c] == target { return true } if matrix[r][c] \u0026gt; target { c = c - 1 continue } if matrix[r][c] \u0026lt; target { r = r + 1 continue } } return false }      快速排序 ...  func sortArray(nums []int) []int { if len(nums) \u0026lt; 2 { return nums } lessList, greatList := []int{}, []int{} for _, v := range nums[1:] { if v \u0026lt; nums[0] { lessList = append(lessList, v) continue } greatList = append(greatList, v) } result := append([]int{}, sortArray(lessList)...) result = append(result, nums[0]) result = append(result, sortArray(greatList)...) return result } // 冒泡排序 func sortArray(nums []int) []int { if len(nums) \u0026lt; 2 { return nums } for i:=0; i\u0026lt;len(nums); i++ { for j:=0; j\u0026lt;(len(nums)-i)-1; j++ { if nums[j] \u0026gt; nums[j+1] { nums[j], nums[j+1] = nums[j+1], nums[j] } } } return nums }      三数之和 ...  func threeSum(nums []int) [][]int { n := len(nums) sort.Ints(nums) result := [][]int{} for i:=0; i\u0026lt;n; i++ { if i \u0026gt; 0 \u0026amp;\u0026amp; nums[i] == nums[i-1] { //固定位位游标去重  continue } right := n-1 for left:=i+1; left\u0026lt;n; left++ { //迭代移动左游标，不停右移增加  if left\u0026gt;i+1 \u0026amp;\u0026amp; nums[left] == nums[left-1]{ //大于初始值的左游标去重  continue } for left\u0026lt;right \u0026amp;\u0026amp; nums[i]+nums[left]+nums[right]\u0026gt;0 { //左右游标不能交叉  right = right - 1 //三值和大于0，右游标不停往左移，值越来越少  } if left == right {break} //游标相遇，直接退出迭代  if nums[i]+nums[left]+nums[right] == 0 { result = append(result, []int{nums[i], nums[left], nums[right]}) } } } return result }      岛屿的最大面积 ...  func maxAreaOfIsland(grid [][]int) int { result := 0 for r:=0; r\u0026lt;len(grid); r++ { for c:=0; c\u0026lt;len(grid[0]); c++ { if grid[r][c] == 1 { value := helper(r, c, grid) if result \u0026lt; value { result = value } } } } return result } func helper(r, c int, grid [][]int) int { if r \u0026lt; 0 || r \u0026gt; len(grid) - 1 || c \u0026lt; 0 || c \u0026gt; len(grid[0]) - 1 { return 0 } if grid[r][c] == 0 || grid[r][c] == 2 { return 0 } grid[r][c] = 2 return 1 + helper(r+1, c, grid) + helper(r-1, c, grid) + helper(r, c+1, grid) + helper(r, c-1, grid) }       最长连续递增序列 ...  func findLengthOfLCIS(nums []int) int { if len(nums) \u0026lt;= 1 { return len(nums) } result, tmp := 1, 1 for i:=0; i\u0026lt;len(nums)-1; i++ { if nums[i] \u0026lt; nums[i+1] { tmp = tmp + 1 } else { tmp = 1 } if tmp \u0026gt; result { result = tmp } } return result }      数组中的第k个最大元素 ...  // 快速选择算法 func findKthLargest(nums []int, k int) int { rand.Seed(time.Now().UnixNano()) left, right := 0, len(nums)-1 target := len(nums) - k cur := -1 for cur != target { cur = partition(left, right, nums, target) if cur \u0026lt; target { left = cur + 1 } else if cur \u0026gt; target { right = cur - 1 } } return nums[cur] } func partition(left, right int, nums []int, target int) int{ if left == right { return left } i := rand.Int() % (right - left + 1) + left n := nums[i] nums[i], nums[right] = nums[right], nums[i] l , r := left, right-1 for l \u0026lt; r { for l \u0026lt; r \u0026amp;\u0026amp; nums[l] \u0026lt;= n { l = l + 1 } for l \u0026lt; r \u0026amp;\u0026amp; n \u0026lt; nums[r] { r = r - 1 } if l != r { nums[l], nums[r] = nums[r], nums[l] } } if nums[l] \u0026gt; n { nums[l], nums[right] = nums[right], nums[l] return l } return right }       全排列 ...  func permute(nums []int) [][]int { result := [][]int{} path := []int{} used := make([]bool, len(nums)) backtrack(path, nums, used, \u0026amp;result) return result } func backtrack(path, nums []int, used []bool, result *[][]int) { if len(path) == len(nums) { tmp := make([]int, len(path)) copy(tmp, path) *result = append(*result, tmp) return } for i:=0; i\u0026lt;len(nums); i++ { if !used[i] { used[i] = true path = append(path, nums[i]) backtrack(path, nums, used, result) path = path[:len(path)-1] used[i] = false } } }      乘最多水的容器 ...  func maxArea(height []int) int { result, i, j := 0, 0, len(height)-1 for i != j { area := (j-i) * min(height[i], height[j]) if area \u0026gt; result { result = area } if height[i] \u0026lt; height[j] { i = i + 1 continue } j = j - 1 } return result } func min(i, j int) int { if i \u0026lt; j {return i} return j }     "});index.add({'id':17,'href':'/myWiki/docs/arithmetic/example/linkedlist/','title':"链表 linked list",'section':"栗子🌰",'content':"链表 linked list #   合并两个有序列表 ...  /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode { result := \u0026amp;ListNode{} preHead := result for (l1 != nil \u0026amp;\u0026amp; l2 != nil){ if l1.Val \u0026lt; l2.Val { preHead.Next = l1 l1 = l1.Next } else { preHead.Next = l2 l2 = l2.Next } preHead = preHead.Next } if l1 == nil{ preHead.Next = l2 } if l2 == nil { preHead.Next = l1 } return result.Next }      反转链表 ...  /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func reverseList(head *ListNode) *ListNode { if nil == head { return head } cur, next := head, head.Next for ; nil != next; cur, next, next.Next = next, next.Next, cur { } head.Next = nil return cur }      删除链表中的节点 ...  /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func deleteNode(node *ListNode) { node.Val, node.Next= node.Next.Val, node.Next.Next }     "});index.add({'id':18,'href':'/myWiki/docs/go-language/dev-rule/','title':"面向对象设计原则",'section':"go 语言",'content':"面向对象设计原则 #  依赖倒置原则（DIP）\n 高层模块（稳定）不应该依赖底层模块（变化），二者都应该依赖抽象（稳定） 抽象（稳定）不应该依赖实现细节（变化），实现细节应该依赖于抽象（稳定）  开放封闭原则（OCP）\n 对扩展开放，对更改封闭 类模块应该可以扩展的，但是不可以修改的  单一职责原则（LSP）\n 一个类应该仅有一个引起他变化的原因 变化的方向隐含这类的责任  Liskov替换原则（LSP）\n 子类必须能够替换他们的基类（IS-A） 继承表达类型抽象  接口隔离原则（ISP）\n 不应该强迫客户程序依赖他们不使用的方法 接口应该小而完备  优先使用对象组合，而不是类继承\n 类继承通常为“白箱复用”，对象组合通常为“黑箱复用” 继承在某种程度上破坏了封装性，子类父类耦合度高。 而对象组合则是要求被组合的对象有良好定义的接口，耦合度低。  封装变化点\n 使用封装来创建对象之间的分界层。类设计者可以在分界的一侧进行修改，而不会对另外一侧产生不良的影响。从而实现层次间的松耦合。  针对接口编程，而不是针对实现编程\n 不将变量的类型声明为某个特定的具体类，而声明为某接口； 客户程序无需获知对象的具体类型，只需要知道对象所具有的接口； 减少系统中各部分的依赖关系，从而实现“高内聚，低耦合”  "});index.add({'id':19,'href':'/myWiki/docs/arithmetic/leetcoderanking/','title':"高频题目",'section':"算法与数据结构",'content':"LeetCode 的高频题目 #  DFS：深度优先搜索算法（Depth First Search），对于二叉树而言，它沿着树的深度遍历树的节点，尽可能深的搜索树的分支，这一过程一直进行到已发现从源节点可达的所有节点为止。\n平衡二叉树： 左右子树的高度相差不超过 1 的树为平衡二叉树\n   插入方式 描述 旋转方式     LL 在 A 的左子树根节点的左子树上插入节点而破坏平衡 右旋转   RR 在 A 的右子树根节点的右子树上插入节点而破坏平衡 左旋转   LR 在A的左子树根节点的右子树上插入节点而破坏平衡 先左旋后右旋   RL 在 A 的右子树根节点的左子树上插入节点而破坏平衡 先右旋后左旋    XOR 异或运算 ⊕ #   任何数和 0 做异或运算，结果仍然是原来的数，即 a⊕0=a。 任何数和其自身做异或运算，结果是 0，即 a⊕a=0。 异或运算满足交换律和结合律，即 a⊕b⊕a=b⊕a⊕a=b⊕(a⊕a)=b⊕0=b。  汉明距离 #  两个整数之间的汉明距离是对应位置上数字不同的位数。XOR 的位运算，当且仅当输入位不同时输出为 1。\n 计算 x 和 y 之间的汉明距离，可以先计算 x XOR y，然后统计结果中等于 1 的位数。\n 为了计算等于 1 的位数，可以将每个位移动到最左侧或最右侧，然后检查该位是否为 1。检查最右位是否为 1，可以使用取模运算（i % 2）或者 AND 操作（i \u0026amp; 1），这两个操作都会屏蔽最右位以外的其他位。\n  布赖恩·克尼根算法 #  该算法使用特定比特位和算术运算移除等于 1 的最右比特位。\n 当我们在 number 和 number-1 上做 AND 位运算时，原数字 number 的最右边等于 1 的比特会被移除。\n 二进制字符串的游标取值操作 #  当字符串中 a[i] 为 \u0026ldquo;0\u0026rdquo; 时，之际操作游标取出的是 uint8=48 类型是 byte，直接 int 转换就会得到一个 int=48；当操作[-\u0026lsquo;\u0026lsquo;0\u0026rsquo;]之后，相当是 utf8 编码的两个 48 相减，获得的是 uint8=0，int 转换之后就会得到一个 int 类型的 0。如果该位为 \u0026ldquo;1\u0026rdquo;，由于正好比\u0026quot;0\u0026quot;多1个编码位，所以得到的就是 uint8=1，int 转换即可得到 1。\n回溯算法编码公式 #  result = [] func backtrack(路径，选择列表) { if 满足结束条件 { result.add(路径) } return for 选择 in 选择列表 { 做选择 backtrack(路径，选择列表) 撤销选择 } } 位运算 bit operation #   IP 到 CIDR 只出现一次的数字  字符串 string #   罗马数字转整数 有效的括号 最长公共前缀（实现方法有待优化） 二进制求和 字符串相加 验证回文串  数学 mathematics #   整数反转  数组 arrary #   两数之和 合并两个有序数组 两数之和 II - 输入有序数组 搜索旋转排序数组 二维数组中的查找 快速排序 三数之和 岛屿的最大面积 最长连续递增序列 数组中的第 k 个最大元素 全排列 乘最多水的容器  链表 linked list #   合并两个有序链表 反转链表 删除链表中的节点  二叉树 binary tree #   反转二叉树 二叉树的最大深度 合并二叉树 二叉树层次遍历2 将有序数组转化为高度平衡二叉搜索树 对称二叉树 二叉树深度 二叉树中序遍历  哈希表 hash map #   宝石与石头 岛屿的周长 两个数组的交集  二分查找 binary search #   二分查找  "});})();