'use strict';(function(){const indexCfg={cache:true};indexCfg.doc={id:'id',field:['title','content'],store:['title','href','section'],};const index=FlexSearch.create('balance',indexCfg);window.bookSearchIndex=index;index.add({'id':0,'href':'/myWiki/docs/docker/docker-learn/','title':"Docker Learn",'section':"Docker",'content':"docker learn test #  "});index.add({'id':1,'href':'/myWiki/docs/linux/','title':"Linux",'section':"Docs",'content':"linuxç³»ç»Ÿä¸­çš„Loadï¼š æ˜¯å¯¹å½“å‰CPUå·¥ä½œé‡çš„åº¦é‡ (WikiPedia: the system load is a measure of the amount of work that a computer system is doing)ã€‚ä¹Ÿæœ‰ç®€å•çš„è¯´æ˜¯è¿›ç¨‹é˜Ÿåˆ—çš„é•¿åº¦ã€‚\nä»€ä¹ˆæ ·çš„Load averageå€¼è¦æé«˜è­¦æƒ• #   0.7 \u0026lt; load \u0026lt; 1: æ­¤æ—¶æ˜¯ä¸é”™çš„çŠ¶æ€ï¼Œå¦‚æœè¿›æ¥æ›´å¤šçš„æ±½è½¦ï¼Œä½ çš„é©¬è·¯ä»ç„¶å¯ä»¥åº”ä»˜ã€‚ load = 1: ä½ çš„é©¬è·¯å³å°†æ‹¥å µï¼Œè€Œä¸”æ²¡æœ‰æ›´å¤šçš„èµ„æºé¢å¤–çš„ä»»åŠ¡ï¼Œèµ¶ç´§çœ‹çœ‹å‘ç”Ÿäº†ä»€ä¹ˆå§ã€‚ load \u0026gt; 5: éå¸¸ä¸¥é‡æ‹¥å µï¼Œæˆ‘ä»¬çš„é©¬è·¯éå¸¸ç¹å¿™ï¼Œæ¯è¾†è½¦éƒ½æ— æ³•å¾ˆå¿«çš„è¿è¡Œ  "});index.add({'id':2,'href':'/myWiki/docs/qa/','title':"Q\u0026 A",'section':"Docs",'content':"Pythonåƒåœ¾å›æ”¶æœºåˆ¶ #  Python GCä¸»è¦ä½¿ç”¨å¼•ç”¨è®¡æ•°ï¼ˆreference countingï¼‰æ¥è·Ÿè¸ªå’Œå›æ”¶åƒåœ¾ã€‚åœ¨å¼•ç”¨è®¡æ•°çš„åŸºç¡€ä¸Šï¼Œé€šè¿‡â€œæ ‡è®°-æ¸…é™¤â€ï¼ˆmark and sweepï¼‰è§£å†³å®¹å™¨å¯¹è±¡å¯èƒ½äº§ç”Ÿçš„å¾ªç¯å¼•ç”¨é—®é¢˜ï¼Œé€šè¿‡â€œåˆ†ä»£å›æ”¶â€ï¼ˆgeneration collectionï¼‰ä»¥ç©ºé—´æ¢æ—¶é—´çš„æ–¹æ³•æé«˜åƒåœ¾å›æ”¶æ•ˆç‡ã€‚\n1 å¼•ç”¨è®¡æ•° #  PyObjectæ˜¯æ¯ä¸ªå¯¹è±¡å¿…æœ‰çš„å†…å®¹ï¼Œå…¶ä¸­ob_refcntå°±æ˜¯åšä¸ºå¼•ç”¨è®¡æ•°ã€‚å½“ä¸€ä¸ªå¯¹è±¡æœ‰æ–°çš„å¼•ç”¨æ—¶ï¼Œå®ƒçš„ob_refcntå°±ä¼šå¢åŠ ï¼Œå½“å¼•ç”¨å®ƒçš„å¯¹è±¡è¢«åˆ é™¤ï¼Œå®ƒçš„ob_refcntå°±ä¼šå‡å°‘.å¼•ç”¨è®¡æ•°ä¸º0æ—¶ï¼Œè¯¥å¯¹è±¡ç”Ÿå‘½å°±ç»“æŸäº†ã€‚\nä¼˜ç‚¹:\n ç®€å• å®æ—¶æ€§  ç¼ºç‚¹:\n ç»´æŠ¤å¼•ç”¨è®¡æ•°æ¶ˆè€—èµ„æº å¾ªç¯å¼•ç”¨  2 æ ‡è®°-æ¸…é™¤æœºåˆ¶ #  åŸºæœ¬æ€è·¯æ˜¯å…ˆæŒ‰éœ€åˆ†é…ï¼Œç­‰åˆ°æ²¡æœ‰ç©ºé—²å†…å­˜çš„æ—¶å€™ä»å¯„å­˜å™¨å’Œç¨‹åºæ ˆä¸Šçš„å¼•ç”¨å‡ºå‘ï¼Œéå†ä»¥å¯¹è±¡ä¸ºèŠ‚ç‚¹ã€ä»¥å¼•ç”¨ä¸ºè¾¹æ„æˆçš„å›¾ï¼ŒæŠŠæ‰€æœ‰å¯ä»¥è®¿é—®åˆ°çš„å¯¹è±¡æ‰“ä¸Šæ ‡è®°ï¼Œç„¶åæ¸…æ‰«ä¸€éå†…å­˜ç©ºé—´ï¼ŒæŠŠæ‰€æœ‰æ²¡æ ‡è®°çš„å¯¹è±¡é‡Šæ”¾ã€‚\n3 åˆ†ä»£æŠ€æœ¯ #  åˆ†ä»£å›æ”¶çš„æ•´ä½“æ€æƒ³æ˜¯ï¼šå°†ç³»ç»Ÿä¸­çš„æ‰€æœ‰å†…å­˜å—æ ¹æ®å…¶å­˜æ´»æ—¶é—´åˆ’åˆ†ä¸ºä¸åŒçš„é›†åˆï¼Œæ¯ä¸ªé›†åˆå°±æˆä¸ºä¸€ä¸ªâ€œä»£â€ï¼Œåƒåœ¾æ”¶é›†é¢‘ç‡éšç€â€œä»£â€çš„å­˜æ´»æ—¶é—´çš„å¢å¤§è€Œå‡å°ï¼Œå­˜æ´»æ—¶é—´é€šå¸¸åˆ©ç”¨ç»è¿‡å‡ æ¬¡åƒåœ¾å›æ”¶æ¥åº¦é‡ã€‚\nPythoné»˜è®¤å®šä¹‰äº†ä¸‰ä»£å¯¹è±¡é›†åˆï¼Œç´¢å¼•æ•°è¶Šå¤§ï¼Œå¯¹è±¡å­˜æ´»æ—¶é—´è¶Šé•¿ã€‚\nä¸¾ä¾‹ï¼š å½“æŸäº›å†…å­˜å—Mç»è¿‡äº†3æ¬¡åƒåœ¾æ”¶é›†çš„æ¸…æ´—ä¹‹åè¿˜å­˜æ´»æ—¶ï¼Œæˆ‘ä»¬å°±å°†å†…å­˜å—Måˆ’åˆ°ä¸€ä¸ªé›†åˆAä¸­å»ï¼Œè€Œæ–°åˆ†é…çš„å†…å­˜éƒ½åˆ’åˆ†åˆ°é›†åˆBä¸­å»ã€‚å½“åƒåœ¾æ”¶é›†å¼€å§‹å·¥ä½œæ—¶ï¼Œå¤§å¤šæ•°æƒ…å†µéƒ½åªå¯¹é›†åˆBè¿›è¡Œåƒåœ¾å›æ”¶ï¼Œè€Œå¯¹é›†åˆAè¿›è¡Œåƒåœ¾å›æ”¶è¦éš”ç›¸å½“é•¿ä¸€æ®µæ—¶é—´åæ‰è¿›è¡Œï¼Œè¿™å°±ä½¿å¾—åƒåœ¾æ”¶é›†æœºåˆ¶éœ€è¦å¤„ç†çš„å†…å­˜å°‘äº†ï¼Œæ•ˆç‡è‡ªç„¶å°±æé«˜äº†ã€‚åœ¨è¿™ä¸ªè¿‡ç¨‹ä¸­ï¼Œé›†åˆBä¸­çš„æŸäº›å†…å­˜å—ç”±äºå­˜æ´»æ—¶é—´é•¿è€Œä¼šè¢«è½¬ç§»åˆ°é›†åˆAä¸­ï¼Œå½“ç„¶ï¼Œé›†åˆAä¸­å®é™…ä¸Šä¹Ÿå­˜åœ¨ä¸€äº›åƒåœ¾ï¼Œè¿™äº›åƒåœ¾çš„å›æ”¶ä¼šå› ä¸ºè¿™ç§åˆ†ä»£çš„æœºåˆ¶è€Œè¢«å»¶è¿Ÿã€‚\n"});index.add({'id':3,'href':'/myWiki/docs/shell/','title':"Shell",'section':"Docs",'content':"Shell è®°å½• #  è®¡ç®—ç”¨å‘½ä»¤åˆ—è¡¨ #     å‘½ä»¤ æ„ä¹‰     sort -k1 -nr sort æ’åˆ—è®¡ç®—ï¼Œä¸å¸¦å‚æ•°ä¼šå°†å…ƒç´ å½’ç±»ï¼›-k1 ä»¥ç¬¬ä¸€åˆ—ä¸ºå…³é”®è¯ï¼›-nrçš„nä»£è¡¨å…³é”®è¯æ˜¯ number æ•°å­—ï¼Œr ä»£è¡¨ reverse å€’å™è¾“å‡ºã€‚   uniq -c uniq çœç•¥é‡å¤è¡Œã€‚-cä»£è¡¨è®¡æ•°   date +%d/%b/%Y:%H:%M Nginx æ—¥å¿—æ—¥æœŸæ ¼å¼çš„ dataï¼Œdate -d '-1 minute' +%d/%b/%Y:%H:%Må½“å‰æ—¶é—´çš„å‰ä¸€åˆ†é’Ÿ        AWK éœ€è¦è®°å½•çš„å†…å»ºå˜é‡ #     å˜é‡å æ„ä¹‰     $0 æ•´è¡Œçš„å†…å®¹   NR ä»1å¼€å§‹çš„è¡Œæ•°   OFS è¾“å‡ºå­—æ®µåˆ†éš”ç¬¦ï¼ŒOFS=\u0026quot;\\t\u0026quot;è¾“å‡ºç”¨åˆ¶è¡¨ç¬¦æ¥åˆ†åˆ—   NF å½“å‰è®°å½•ä¸­çš„å­—æ®µä¸ªæ•°ï¼Œå°±æ˜¯æœ‰å¤šå°‘åˆ—ã€‚$NF æœ€åä¸€åˆ—æ•°æ®    AWK æ­£åˆ™ä¸ grep çš„å¯¹æ¯” #  # ä¸‹é¢æ“ä½œç›¸ç­‰ grep \u0026#34;TIME_WAIT\u0026#34; netstat.txt awk \u0026#39;/TIME_WAIT/\u0026#39; netstat.txt # ä¸‹é¢æ“ä½œç›¸ç­‰ grep -v \u0026#34;TIME_WAIT\u0026#34; netstat.txt awk \u0026#39;!/TIME_WAIT/\u0026#39; netstat.txt è®¡ç®—å½“å‰æ–‡ä»¶å¤¹æ€»å¤§å° #  ls -l | awk \u0026#39;NR!=1{sum+=$5}END{print sum}\u0026#39; è®¡ç®— nginx æ—¥å¿—ä¸­ ip æ•°é‡å‰å #  awk \u0026#39;{a[$1]++}END{for(i in a)print a[i]\u0026#34; \u0026#34;i}\u0026#39; access.log | sort -k1 -nr | head -10 awk \u0026#39;{print $1}\u0026#39; access.log |sort | uniq -c | sort -k1 -nr | head -10 ç»Ÿè®¡æ—¥å¿—ä¸­è®¿é—®å¤§äº100æ¬¡çš„ IP #  awk \u0026#39;{a[$1]++}END{for(i in a)if{a[i]\u0026gt;100 print a[i]\u0026#34;, \u0026#34;i}}\u0026#39; access.log ç»Ÿè®¡æŸæ—¶é—´æ®µå†…è®¿é—®æœ€å¤šçš„10ä¸ªIP #  awk \u0026#39;$4\u0026gt;=\u0026#34;[9/Apr/2016:00:00:01\u0026#34; \u0026amp;\u0026amp; $4\u0026lt;=\u0026#34;[9/Apr/2016:23:59:59\u0026#34; {a[$1]++}END{for(i in a)print a[i],i}\u0026#39; access.log |sort -k1 -nr|head -n10 ç»Ÿè®¡æ¯ä¸ªURLè®¿é—®å†…å®¹çš„æ€»å¤§å°ï¼ˆ$body_bytes_sentï¼‰ #  awk \u0026#39;{a[$7]++;size[$7]+=$10}END{for(i in a)print a[i],size[i],i}\u0026#39; access.log ç»Ÿè®¡è®¿é—®çŠ¶æ€ç ä¸º404çš„IPåŠå‡ºç°æ¬¡æ•° #  awk \u0026#39;{if($9~/404/)a[$1\u0026#34; \u0026#34;$9]++}END{for(i in a)print i,a[i]}\u0026#39; access.log "});index.add({'id':7,'href':'/myWiki/docs/go-language/go-notes/','title':"go è¯­è¨€ä¸€äº›ç¬”è®°",'section':"go è¯­è¨€",'content':"ä¸€äº›ç¬”è®° #  1\u0026lt;\u0026lt;31 // 2çš„31æ¬¡æ–¹ map çš„ç©ºå€¼ #  a := make(map[int]bool) fmt.Println(a[0]) // false b := make(map[int]int) fmt.Println(b[0]) // 0 c := make(map[int]string) fmt.Println(c[0]) // \u0026#34;\u0026#34; ç©ºå­—ç¬¦ä¸² string å­—ç¬¦ä¸²è¿­ä»£ #   ä½¿ç”¨ for+i è¿­ä»£å­—ç¬¦ä¸²æ—¶ï¼Œè·å–å…ƒç´ ç±»å‹æ˜¯ byte ä½¿ç”¨ for + range è¿­ä»£å­—ç¬¦ä¸²æ—¶ï¼Œè·å–å…ƒç´ ç±»å‹æ˜¯ rune  è½¬åŒ–ä¸ºäºŒè¿›åˆ¶å­—ç¬¦ä¸² #  s := fmt.Sprintf(\u0026#34;%b\u0026#34;, C) "});index.add({'id':8,'href':'/myWiki/docs/arithmetic/example/binarysearch/','title':"äºŒåˆ†æŸ¥æ‰¾ binary search",'section':"æ —å­ğŸŒ°",'content':"äºŒåˆ†æŸ¥æ‰¾ binary search #   äºŒåˆ†æŸ¥æ‰¾ ...  func search(nums []int, target int) int { left, right := 0, len(nums)-1 for left \u0026lt;= right { mid := left + (right-left)/2 if nums[mid] == target { return mid } if nums[mid] \u0026gt; target { right = mid - 1 continue } left = mid + 1 } return -1 }     "});index.add({'id':9,'href':'/myWiki/docs/arithmetic/example/binarytree/','title':"äºŒå‰æ ‘ binary tree",'section':"æ —å­ğŸŒ°",'content':"äºŒå‰æ ‘ binary tree #   åè½¬äºŒå‰æ ‘ ...  /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func invertTree(root *TreeNode) *TreeNode { if root == nil { return nil } root.Right, root.Left = invertTree(root.Left), invertTree(root.Right) return root }      äºŒå‰æ ‘çš„æœ€å¤§æ·±åº¦ ...  /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ // é€’å½’æ–¹å¼ func maxDepth(root *TreeNode) int { if root == nil { return 0 } if root.Right == nil \u0026amp;\u0026amp; root.Left == nil { return 1 } leftDepth := maxDepth(root.Left) rightDepth := maxDepth(root.Right) if leftDepth \u0026gt; rightDepth { return 1+leftDepth } return 1+rightDepth } // BFS è¿­ä»£æ–¹å¼ func maxDepth(root *TreeNode) int { if root == nil { return 0 } queue := []*TreeNode{root,} depth := 0 for len(queue) \u0026gt; 0{ size := len(queue) for i:=0;i\u0026lt;size;i++{ node := queue[0] queue = queue[1:] if node.Left != nil { queue = append(queue, node.Left) } if node.Right != nil { queue = append(queue, node.Right) } } depth = depth+1 } return depth }      åˆå¹¶äºŒå‰æ ‘ ...  /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func mergeTrees(t1 *TreeNode, t2 *TreeNode) *TreeNode { if t1 == nil { return t2 } if t2 == nil { return t1 } var nodeLeft *TreeNode var nodeRight *TreeNode if t1.Left == nil \u0026amp;\u0026amp; t1.Right == nil { nodeLeft = t2.Left nodeRight = t2.Right } if t2.Left == nil \u0026amp;\u0026amp; t2.Right == nil { nodeLeft = t1.Left nodeRight = t1.Right } if nodeLeft == nil { nodeLeft = mergeTrees(t1.Left, t2.Left) } if nodeRight == nil { nodeRight = mergeTrees(t1.Right, t2.Right) } node := TreeNode{ Val: t1.Val+t2.Val, Left: nodeLeft, Right: nodeRight, } return \u0026amp;node }      äºŒå‰æ ‘å±‚æ¬¡éå†2 ...  /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func levelOrderBottom(root *TreeNode) [][]int { if root == nil { return nil } queue := []*TreeNode{root} result := [][]int{} for len(queue) \u0026gt; 0 { levelVal := []int{} size := len(queue) for i:=0;i\u0026lt;size;i++ { levelVal = append(levelVal, queue[i].Val) if queue[i].Left != nil { queue = append(queue, queue[i].Left) } if queue[i].Right != nil { queue = append(queue, queue[i].Right) } } queue = queue[size:] result = append([][]int{levelVal}, result...) } return result }      å°†æœ‰åºæ•°ç»„è½¬åŒ–ä¸ºé«˜åº¦å¹³è¡¡äºŒå‰æœç´¢æ ‘ ...  func sortedArrayToBST(nums []int) *TreeNode { if len(nums) \u0026lt;=0 { return nil } if len(nums) == 1 { return \u0026amp;TreeNode{Val:nums[0]} } mid := len(nums)/2 return \u0026amp;TreeNode{ Val: nums[mid], Left: sortedArrayToBST(nums[:mid]), Right: sortedArrayToBST(nums[mid+1:]), } }      å¯¹ç§°äºŒå‰æ ‘ ...  /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ // é€’å½’éå†ï¼Œä¼ å…¥åŒæ ‘ï¼Œé€’å½’å¯¹æ¯”å·¦æ ‘å’Œå³ func isSymmetric(root *TreeNode) bool { return checker(root, root) } func checker(left, right *TreeNode) bool { if left == nil \u0026amp;\u0026amp; right == nil { return true } if left == nil || right == nil { return false } return left.Val == right.Val \u0026amp;\u0026amp; checker(left.Left, right.Right) \u0026amp;\u0026amp; checker(left.Right, right.Left) } // è¿­ä»£éå†ï¼Œç”¨é˜Ÿåˆ—ç¼“å­˜å–ä¸€åŒä¸€åŒè‡ªå·¦æ ‘å’Œå³æ ‘çš„é•œåƒèŠ‚ç‚¹ã€‚ç„¶åä»é˜Ÿåˆ—ä¸­å–å‡ºä¸€åŒæ¥è¿›è¡ŒèŠ‚ç‚¹å€¼å¯¹æ¯”ã€‚ç›¸ç­‰å°±æŠŠä¸¤ä¸ªå¯¹æ¯”å®Œçš„èŠ‚ç‚¹çš„é•œåƒå€¼ä¸€åŒä¸€åŒå­˜è¿›é˜Ÿåˆ—ã€‚ func isSymmetric(root *TreeNode) bool { queue := []*TreeNode{ root, root, } for len(queue) \u0026gt; 0 { left, right := queue[0], queue[1] queue = queue[2:] if left == nil \u0026amp;\u0026amp; right == nil { continue } if left == nil || right == nil { return false } if left.Val != right.Val { return false } queue = append(queue, left.Left) queue = append(queue, right.Right) queue = append(queue, left.Right) queue = append(queue, right.Left) } return true }      äºŒå‰æ ‘æ·±åº¦ ...  /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func maxDepth(root *TreeNode) int { if root == nil { return 0 } if root.Left == nil \u0026amp;\u0026amp; root.Right == nil { return 1 } leftDepth := maxDepth(root.Left) rightDepth := maxDepth(root.Right) if leftDepth \u0026gt; rightDepth { return 1 + leftDepth } return 1 + rightDepth }      äºŒå‰æ ‘ä¸­åºéå† ...  /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ // é€’å½’æ–¹å¼ func inorderTraversal(root *TreeNode) []int { if root == nil { return []int{} } if root.Left == nil \u0026amp;\u0026amp; root.Right == nil { return []int{root.Val} } leftList := inorderTraversal(root.Left) rightList := inorderTraversal(root.Right) result := append(leftList, root.Val) result = append(result, rightList...) return result } // è¿­ä»£æ–¹å¼ /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func inorderTraversal(root *TreeNode) []int { if root == nil { return []int{} } if root.Left == nil \u0026amp;\u0026amp; root.Right == nil { return []int{root.Val} } result := []int{} stack := []*TreeNode{root} for len(stack) \u0026gt; 0 { node := stack[len(stack)-1] if node.Left != nil { stack = append(stack, node.Left) node.Left = nil continue } stack = stack[:len(stack)-1] result = append(result, node.Val) if node.Right != nil { stack = append(stack, node.Right) node.Right = nil } } return result }     "});index.add({'id':10,'href':'/myWiki/docs/arithmetic/example/bitoperation/','title':"ä½è¿ç®— bit operation",'section':"æ —å­ğŸŒ°",'content':"ä½è¿ç®— bit operation #   IP åˆ° CIDR ...  #!/usr/bin/env python # -*- coding: utf-8 -*- def ipToCIDR(ip, range): \u0026#34;\u0026#34;\u0026#34; :type ip: str :type range: int :rtype: List[str] \u0026#34;\u0026#34;\u0026#34; ipInt = ipToInt(ip) ans = [] x = 0 while x \u0026lt; range: zeros = countZeros(ipInt + x) while x + (1\u0026lt;\u0026lt;zeros) \u0026gt; range: zeros -= 1 ans.append(intToIp(ipInt + x) + \u0026#34;/\u0026#34; + str(32 - zeros)) x += 1\u0026lt;\u0026lt;zeros return ans def ipToInt(ip): ans = 0 for idx, part in enumerate(ip.split(\u0026#39;.\u0026#39;)[::-1]): ans += int(part) \u0026lt;\u0026lt; idx * 8 return ans def intToIp(ipInt): ans = [] for x in xrange(4): ans.append((ipInt \u0026gt;\u0026gt; x * 8) \u0026amp; 255) return \u0026#39;.\u0026#39;.join(map(str, ans[::-1])) def countZeros(ip): cnt = 0 while ip: if ip \u0026amp; 1: break cnt += 1 ip \u0026gt;\u0026gt;= 1 return cnt if __name__ == \u0026#39;__main__\u0026#39;: print(ipToCIDR(\u0026#34;255.0.0.7\u0026#34;, 11))      åªå‡ºç°ä¸€æ¬¡çš„æ•°å­— ...  ç­”æ¡ˆæ˜¯ä½¿ç”¨ä½è¿ç®—ã€‚å¯¹äºè¿™é“é¢˜ï¼Œå¯ä½¿ç”¨å¼‚æˆ–è¿ç®— âŠ•ã€‚\nfunc singleNumber(nums []int) int { single := 0 for _, num := range nums { single ^= num } return single }      æ±‰æ˜è·ç¦» ...  // æ ‡å‡†åº“æ–¹æ³• func hammingDistance(x int, y int) int { return bits.OnesCount(uint(x) ^ uint(y)) } // é€šè¿‡ä½ç§»è®¡ç®—å¼‚æˆ–ç»“æœçš„1çš„ä¸ªæ•° func hammingDistance(x int, y int) int { distance := 0 xor := x^y for xor\u0026gt;0 { if xor\u0026amp;1 == 1 { distance = distance + 1 } xor = xor\u0026gt;\u0026gt;1 } return distance } // å¸ƒèµ–æ©Â·å…‹å°¼æ ¹ç®—æ³• // å½“æˆ‘ä»¬åœ¨ number å’Œ number-1 ä¸Šåš AND ä½è¿ç®—æ—¶ï¼ŒåŸæ•°å­— number çš„æœ€å³è¾¹ç­‰äº 1 çš„æ¯”ç‰¹ä¼šè¢«ç§»é™¤ã€‚ func hammingDistance(x int, y int) int { distance := 0 xor := x^y for xor\u0026gt;0 { distance = distance + 1 xor = xor \u0026amp; (xor-1) } return distance }     "});index.add({'id':11,'href':'/myWiki/docs/arithmetic/example/hashmap/','title':"å“ˆå¸Œè¡¨ hash map",'section':"æ —å­ğŸŒ°",'content':"å“ˆå¸Œè¡¨ hash map #   å®çŸ³ä¸çŸ³å¤´ ...  func numJewelsInStones(J string, S string) int { jewels := make(map[string]struct{}) result := 0 for i:=0;i\u0026lt;len(J);i++{ jewels[string(J[i])] = struct{}{} } for i:=0;i\u0026lt;len(S);i++{ if _, ok := jewels[string(S[i])];ok { result = result + 1 } } return result }      å²›å±¿çš„å‘¨é•¿ ...  // å¼ºè¡Œéå†æ‰€æœ‰èŠ‚ç‚¹çš„å››å‘¨ï¼Œåˆ¤æ–­å››å‘¨æ ¼å­çš„ç±»å‹æ¥è®¡ç®—æ˜¯å¦å‘¨é•¿+1 func islandPerimeter(grid [][]int) int { perimeter := 0 for i:=0;i\u0026lt;len(grid);i++{ sum := 0 for j:=0;j\u0026lt;len(grid[0]);j++{ if grid[i][j] == 0{ continue } if j-1\u0026lt;0 || grid[i][j-1] == 0 {sum++} if i-1\u0026lt;0 || grid[i-1][j] == 0 {sum++} if j+1\u0026gt;=len(grid[0]) || grid[i][j+1] == 0 {sum++} if i+1\u0026gt;=len(grid) || grid[i+1][j] == 0 {sum++} } perimeter = perimeter + sum } return perimeter } // DFS é€’å½’éå†å²›å±¿çš„æ ¼å­ï¼Œé€šè¿‡åˆ¤æ–­æ˜¯å¦ä¸‹ä¸€æ¬¡è¿›å…¥çš„æ ¼å­çš„ç±»å‹å’Œæ˜¯å¦å·²ç»éå†è¿‡ï¼Œæ¥è¿”å›è®¡å…¥å‘¨é•¿çš„è¾¹é•¿æ˜¯1è¿˜æ˜¯0 func islandPerimeter(grid [][]int) int { for r:=0;r\u0026lt;len(grid);r++{ for c:=0;c\u0026lt;len(grid[0]);c++{ if grid[r][c] == 1 { return dfs(grid, r, c) } } } return 0 } func dfs(grid [][]int, r int, c int) int { if !(0 \u0026lt;= r \u0026amp;\u0026amp; r \u0026lt; len(grid) \u0026amp;\u0026amp; 0 \u0026lt;= c \u0026amp;\u0026amp; c \u0026lt; len(grid[0])) { return 1 } if grid[r][c] == 0 { return 1 } if grid[r][c] == 2 { return 0 } grid[r][c] = 2 return dfs(grid, r+1, c) + dfs(grid, r, c+1) + dfs(grid, r-1, c) + dfs(grid, r, c-1) }      ä¸¤ä¸ªæ•°ç»„çš„äº¤é›† ...  func intersection(nums1 []int, nums2 []int) []int { result := []int{} setMap := make(map[int]bool) for _, v := range nums1 { setMap[v] = false } for _, v := range nums2 { if sight, exist := setMap[v]; !sight \u0026amp;\u0026amp; exist { setMap[v] = true result = append(result, v) } } return result }     "});index.add({'id':12,'href':'/myWiki/docs/arithmetic/example/string/','title':"å­—ç¬¦ä¸² string",'section':"æ —å­ğŸŒ°",'content':"å­—ç¬¦ä¸² string #   ç½—é©¬æ•°å­—è½¬æ•´æ•° ...  ç›´æ¥ä½¿ç”¨ hash map ä½œä¸ºç´¢å¼•ä¼šæ¯”è¾ƒçœäº‹\nfunc romanToInt(s string) int { tranMap := map[string]int { \u0026#34;I\u0026#34;: 1, \u0026#34;V\u0026#34;: 5, \u0026#34;X\u0026#34;: 10, \u0026#34;L\u0026#34;: 50, \u0026#34;C\u0026#34;: 100, \u0026#34;D\u0026#34;: 500, \u0026#34;M\u0026#34;: 1000, \u0026#34;IV\u0026#34;: 4, \u0026#34;IX\u0026#34;: 9, \u0026#34;XL\u0026#34;: 40, \u0026#34;XC\u0026#34;: 90, \u0026#34;CD\u0026#34;: 400, \u0026#34;CM\u0026#34;: 900, } sList := strings.Split(s, \u0026#34;\u0026#34;) result := 0 for i:=0;i\u0026lt;len(sList);i++ { if i == len(sList) -1 { result = result + tranMap[sList[i]] continue } if v, ok := tranMap[sList[i]+sList[i+1]];ok{ result = result + v i = i + 1 continue } result = result + tranMap[sList[i]] } return result }      æœ‰æ•ˆçš„æ‹¬å· ...  func isValid(s string) bool { parMap := map[rune]rune { \u0026#39;(\u0026#39;: \u0026#39;0\u0026#39;, \u0026#39;{\u0026#39;: \u0026#39;0\u0026#39;, \u0026#39;[\u0026#39;: \u0026#39;0\u0026#39;, \u0026#39;)\u0026#39;: \u0026#39;(\u0026#39;, \u0026#39;}\u0026#39;: \u0026#39;{\u0026#39;, \u0026#39;]\u0026#39;: \u0026#39;[\u0026#39;, } parQueue := []rune{} for _, v := range s { if _, ok := parMap[v]; !ok { continue } if parMap[v] == \u0026#39;0\u0026#39; { parQueue = append(parQueue, v) continue } if len(parQueue) == 0 {return false} if parMap[v] != parQueue[len(parQueue)-1] { return false } parQueue = parQueue[:len(parQueue)-1] } if len(parQueue) \u0026gt; 0 {return false} return true }      æœ€é•¿å…¬å…±å‰ç¼€ ...  func longestCommonPrefix(strs []string) string { if len(strs) == 0 { return \u0026#34;\u0026#34; } if len(strs) == 1 { return strs[0] } mid := len(strs)/2 left := longestCommonPrefix(strs[:mid]) right := longestCommonPrefix(strs[mid:]) var length int if len(left) \u0026lt; len(right) { length = len(left) } else { length = len(right) } result := \u0026#34;\u0026#34; for i:=0;i\u0026lt;length;i++ { if left[i] != right[i] { break } result = result + string(left[i]) } return result }      äºŒè¿›åˆ¶æ±‚å’Œ ...  // å¯¹é½æœ«å°¾å­—ç¬¦ï¼ŒåŒæ—¶å­—ç¬¦â€œç›¸åŠ â€ï¼Œé€šè¿‡ carry çš„å€¼ä¼ é€’è¿›ä½ã€‚æ¯ä½çš„ç»“æœä½ carry+a[i]+b[i]ï¼Œç•™ä¸‹çš„ç»“æœä½ä¸º %2 çš„ç»“æœï¼Œä¸‹ä¸€æ¬¡çš„è¿›ä½ä¸º /2 çš„ç»“æœã€‚ func addBinary(a string, b string) string { result, carry, n := \u0026#34;\u0026#34;, 0, 0 if len(a) \u0026gt; len(b) { n = len(a) } else { n = len(b) } for i:=0; i\u0026lt;n; i++ { if i \u0026lt; len(a) { carry = carry + int(a[len(a)-1-i] - \u0026#39;0\u0026#39;) // å½“å­—ç¬¦ä¸²ä¸­ a[len(a)-1-i] ä¸º \u0026#34;0\u0026#34; æ—¶ï¼Œä¹‹é™…æ“ä½œæ¸¸æ ‡å–å‡ºçš„æ˜¯ uint8=48 ç±»å‹æ˜¯ byteï¼Œç›´æ¥ int è½¬æ¢å°±ä¼šå¾—åˆ°ä¸€ä¸ª int=48ï¼›å½“[-\u0026#39;\u0026#39;0\u0026#39;]ä¹‹åï¼Œç›¸å½“æ˜¯ utf8 ç¼–ç çš„ä¸¤ä¸ª 48 ç›¸å‡ï¼Œè·å¾—çš„æ˜¯ uint8=0ï¼Œint è½¬æ¢ä¹‹åå°±ä¼šå¾—åˆ°ä¸€ä¸ª int ç±»å‹çš„ 0ã€‚å¦‚æœè¯¥ä½ä¸º \u0026#34;1\u0026#34;ï¼Œç”±äºæ­£å¥½æ¯”\u0026#34;0\u0026#34;å¤š1ä¸ªç¼–ç ä½ï¼Œæ‰€ä»¥å¾—åˆ°çš„å°±æ˜¯ uint8=1ï¼Œint è½¬æ¢å³å¯å¾—åˆ° 1ã€‚  } if i \u0026lt; len(b) { carry = carry + int(b[len(b)-1-i] - \u0026#39;0\u0026#39;) } result = strconv.Itoa(carry%2) + result // result = fmt.Sprintf(\u0026#34;%b%s\u0026#34;, carry%2, result)  carry = carry / 2 } if carry \u0026gt; 0 { result = \u0026#34;1\u0026#34; + result } return result }      å­—ç¬¦ä¸²ç›¸åŠ  ...  func addStrings(num1 string, num2 string) string { carry, n := 0, 0 result := \u0026#34;\u0026#34; if len(num1) \u0026gt; len(num2) { n = len(num1) } else { n = len(num2) } for i:=0; i\u0026lt;n; i ++ { if i \u0026lt; len(num1) { carry = carry + int(num1[len(num1)-1-i] - \u0026#39;0\u0026#39;) } if i \u0026lt; len(num2) { carry = carry + int(num2[len(num2)-1-i] - \u0026#39;0\u0026#39;) } result = strconv.Itoa(carry%10) + result carry = carry / 10 } if carry\u0026gt;0 { result = strconv.Itoa(carry) + result } return result }      éªŒè¯å›æ–‡ä¸² ...  func isPalindrome(s string) bool { left, right := 0, len(s)-1 for left \u0026lt;= right { for left \u0026lt; right \u0026amp;\u0026amp; !isalnum(s[left]) { left = left + 1 } for left \u0026lt; right \u0026amp;\u0026amp; !isalnum(s[right]) { right = right - 1 } if strings.ToLower(string(s[left])) != strings.ToLower(string(s[right])) { fmt.Print(string(s[left]), string(s[right])) return false } left, right = left+1, right-1 } return true } func isalnum(ch byte) bool { return (ch \u0026gt;= \u0026#39;A\u0026#39; \u0026amp;\u0026amp; ch \u0026lt;= \u0026#39;Z\u0026#39;) || (ch \u0026gt;= \u0026#39;a\u0026#39; \u0026amp;\u0026amp; ch \u0026lt;= \u0026#39;z\u0026#39;) || (ch \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; ch \u0026lt;= \u0026#39;9\u0026#39;) }     "});index.add({'id':13,'href':'/myWiki/docs/arithmetic/example/mathematics/','title':"æ•°å­¦ mathematics",'section':"æ —å­ğŸŒ°",'content':"æ•°å­¦ mathematics #   æ•´æ•°åè½¬ ...  func reverse(x int) int { y := 0 for x != 0 { y = y*10 + x%10 x = x/10 } if y \u0026lt; -(1\u0026lt;\u0026lt;31) || y \u0026gt; (1\u0026lt;\u0026lt;31)-1 { return 0 } return y }     "});index.add({'id':14,'href':'/myWiki/docs/arithmetic/example/array/','title':"æ•°ç»„ array",'section':"æ —å­ğŸŒ°",'content':"æ•°ç»„ array #   ä¸¤æ•°ä¹‹å’Œ ...  func twoSum(nums []int, target int) []int { result := map[int]int{} for i:=0;i\u0026lt;len(nums);i++{ if k, exist := result[target-nums[i]];exist { fmt.Println(k, i) return []int{k, i} } result[nums[i]] = i } return nil }      åˆå¹¶ä¸¤ä¸ªæœ‰åºæ•°ç»„ ...   åˆå¹¶æœ‰åºæ•°åˆ—ï¼Œä¸ä¸€å®šä»å°åˆ°å¤§åˆå¹¶ï¼Œä¹Ÿå¯ä»¥ä»å¤§åˆ°å°åˆå¹¶ï¼› ç¬¬ä¸€ä¸ªæ•°ç»„æœ‰ç©ºé—´ä½™é‡ï¼Œç›´æ¥æ“ä½œæ¯”åˆ›å»ºæ–°å˜é‡ç©ºé—´åˆé€‚ï¼›  func merge(nums1 []int, m int, nums2 []int, n int) { p1 := m-1 p2 := n-1 p3 := m+n-1 for ;p1\u0026gt;=0\u0026amp;\u0026amp;p2\u0026gt;=0;p3--{ if nums1[p1] \u0026lt; nums2[p2] { nums1[p3] = nums2[p2] p2 = p2-1 continue } nums1[p3] = nums1[p1] p1 = p1-1 } for i:=0;i\u0026lt;p2+1;i++{ nums1[i] = nums2[i] } }      ä¸¤æ•°ä¹‹å’Œ II - è¾“å…¥æœ‰åºæ•°ç»„ ...  åˆå§‹æ—¶ä¸¤ä¸ªæŒ‡é’ˆåˆ†åˆ«æŒ‡å‘ç¬¬ä¸€ä¸ªå…ƒç´ ä½ç½®å’Œæœ€åä¸€ä¸ªå…ƒç´ çš„ä½ç½®ã€‚æ¯æ¬¡è®¡ç®—ä¸¤ä¸ªæŒ‡é’ˆæŒ‡å‘çš„ä¸¤ä¸ªå…ƒç´ ä¹‹å’Œï¼Œå¹¶å’Œç›®æ ‡å€¼æ¯”è¾ƒã€‚å¦‚æœä¸¤ä¸ªå…ƒç´ ä¹‹å’Œç­‰äºç›®æ ‡å€¼ï¼Œåˆ™å‘ç°äº†å”¯ä¸€è§£ã€‚å¦‚æœä¸¤ä¸ªå…ƒç´ ä¹‹å’Œå°äºç›®æ ‡å€¼ï¼Œåˆ™å°†å·¦ä¾§æŒ‡é’ˆå³ç§»ä¸€ä½ã€‚å¦‚æœä¸¤ä¸ªå…ƒç´ ä¹‹å’Œå¤§äºç›®æ ‡å€¼ï¼Œåˆ™å°†å³ä¾§æŒ‡é’ˆå·¦ç§»ä¸€ä½ã€‚ç§»åŠ¨æŒ‡é’ˆä¹‹åï¼Œé‡å¤ä¸Šè¿°æ“ä½œï¼Œç›´åˆ°æ‰¾åˆ°ç­”æ¡ˆã€‚\nfunc twoSum(numbers []int, target int) []int { low, high := 0, len(numbers) - 1 for low \u0026lt; high { sum := numbers[low] + numbers[high] if sum == target { return []int{low + 1, high + 1} } else if sum \u0026lt; target { low++ } else { high-- } } return []int{-1, -1} }       æœç´¢æ—‹è½¬æ’åºæ•°ç»„ ...  func search(nums []int, target int) int { left := 0 right := len(nums) - 1 for left \u0026lt;= right { mid := (left + right) / 2 if nums[mid] == target { return mid } // åˆ¤æ–­æ˜¯å¦åœ¨å‰åŠéƒ¨åˆ†æŸ¥æ‰¾ \tif (nums[left] \u0026lt;= target \u0026amp;\u0026amp; target \u0026lt;= nums[mid]) || (nums[mid] \u0026lt;= nums[right] \u0026amp;\u0026amp; (target \u0026lt; nums[mid] || target \u0026gt; nums[right])) { right = mid - 1 } else { left = mid + 1 } } return -1 }      äºŒç»´æ•°ç»„ä¸­çš„æŸ¥æ‰¾ ...  func findNumberIn2DArray(matrix [][]int, target int) bool { if len(matrix) == 0 || len(matrix[0]) == 0 { return false } r, c := 0, len(matrix[0])-1 for r\u0026lt;len(matrix) \u0026amp;\u0026amp; c\u0026gt;=0 { if matrix[r][c] == target { return true } if matrix[r][c] \u0026gt; target { c = c - 1 continue } if matrix[r][c] \u0026lt; target { r = r + 1 continue } } return false }      å¿«é€Ÿæ’åº ...  func sortArray(nums []int) []int { if len(nums) \u0026lt; 2 { return nums } lessList, greatList := []int{}, []int{} for _, v := range nums[1:] { if v \u0026lt; nums[0] { lessList = append(lessList, v) continue } greatList = append(greatList, v) } result := append([]int{}, sortArray(lessList)...) result = append(result, nums[0]) result = append(result, sortArray(greatList)...) return result } // å†’æ³¡æ’åº func sortArray(nums []int) []int { if len(nums) \u0026lt; 2 { return nums } for i:=0; i\u0026lt;len(nums); i++ { for j:=0; j\u0026lt;(len(nums)-i)-1; j++ { if nums[j] \u0026gt; nums[j+1] { nums[j], nums[j+1] = nums[j+1], nums[j] } } } return nums }      ä¸‰æ•°ä¹‹å’Œ ...  func threeSum(nums []int) [][]int { n := len(nums) sort.Ints(nums) result := [][]int{} for i:=0; i\u0026lt;n; i++ { if i \u0026gt; 0 \u0026amp;\u0026amp; nums[i] == nums[i-1] { //å›ºå®šä½ä½æ¸¸æ ‡å»é‡  continue } right := n-1 for left:=i+1; left\u0026lt;n; left++ { //è¿­ä»£ç§»åŠ¨å·¦æ¸¸æ ‡ï¼Œä¸åœå³ç§»å¢åŠ   if left\u0026gt;i+1 \u0026amp;\u0026amp; nums[left] == nums[left-1]{ //å¤§äºåˆå§‹å€¼çš„å·¦æ¸¸æ ‡å»é‡  continue } for left\u0026lt;right \u0026amp;\u0026amp; nums[i]+nums[left]+nums[right]\u0026gt;0 { //å·¦å³æ¸¸æ ‡ä¸èƒ½äº¤å‰  right = right - 1 //ä¸‰å€¼å’Œå¤§äº0ï¼Œå³æ¸¸æ ‡ä¸åœå¾€å·¦ç§»ï¼Œå€¼è¶Šæ¥è¶Šå°‘  } if left == right {break} //æ¸¸æ ‡ç›¸é‡ï¼Œç›´æ¥é€€å‡ºè¿­ä»£  if nums[i]+nums[left]+nums[right] == 0 { result = append(result, []int{nums[i], nums[left], nums[right]}) } } } return result }      å²›å±¿çš„æœ€å¤§é¢ç§¯ ...  func maxAreaOfIsland(grid [][]int) int { result := 0 for r:=0; r\u0026lt;len(grid); r++ { for c:=0; c\u0026lt;len(grid[0]); c++ { if grid[r][c] == 1 { value := helper(r, c, grid) if result \u0026lt; value { result = value } } } } return result } func helper(r, c int, grid [][]int) int { if r \u0026lt; 0 || r \u0026gt; len(grid) - 1 || c \u0026lt; 0 || c \u0026gt; len(grid[0]) - 1 { return 0 } if grid[r][c] == 0 || grid[r][c] == 2 { return 0 } grid[r][c] = 2 return 1 + helper(r+1, c, grid) + helper(r-1, c, grid) + helper(r, c+1, grid) + helper(r, c-1, grid) }       æœ€é•¿è¿ç»­é€’å¢åºåˆ— ...  func findLengthOfLCIS(nums []int) int { if len(nums) \u0026lt;= 1 { return len(nums) } result, tmp := 1, 1 for i:=0; i\u0026lt;len(nums)-1; i++ { if nums[i] \u0026lt; nums[i+1] { tmp = tmp + 1 } else { tmp = 1 } if tmp \u0026gt; result { result = tmp } } return result }      æ•°ç»„ä¸­çš„ç¬¬kä¸ªæœ€å¤§å…ƒç´  ...  // å¿«é€Ÿé€‰æ‹©ç®—æ³• func findKthLargest(nums []int, k int) int { rand.Seed(time.Now().UnixNano()) left, right := 0, len(nums)-1 target := len(nums) - k cur := -1 for cur != target { cur = partition(left, right, nums, target) if cur \u0026lt; target { left = cur + 1 } else if cur \u0026gt; target { right = cur - 1 } } return nums[cur] } func partition(left, right int, nums []int, target int) int{ if left == right { return left } i := rand.Int() % (right - left + 1) + left n := nums[i] nums[i], nums[right] = nums[right], nums[i] l , r := left, right-1 for l \u0026lt; r { for l \u0026lt; r \u0026amp;\u0026amp; nums[l] \u0026lt;= n { l = l + 1 } for l \u0026lt; r \u0026amp;\u0026amp; n \u0026lt; nums[r] { r = r - 1 } if l != r { nums[l], nums[r] = nums[r], nums[l] } } if nums[l] \u0026gt; n { nums[l], nums[right] = nums[right], nums[l] return l } return right }       å…¨æ’åˆ— ...  func permute(nums []int) [][]int { result := [][]int{} path := []int{} used := make([]bool, len(nums)) backtrack(path, nums, used, \u0026amp;result) return result } func backtrack(path, nums []int, used []bool, result *[][]int) { if len(path) == len(nums) { tmp := make([]int, len(path)) copy(tmp, path) *result = append(*result, tmp) return } for i:=0; i\u0026lt;len(nums); i++ { if !used[i] { used[i] = true path = append(path, nums[i]) backtrack(path, nums, used, result) path = path[:len(path)-1] used[i] = false } } }      ä¹˜æœ€å¤šæ°´çš„å®¹å™¨ ...  func maxArea(height []int) int { result, i, j := 0, 0, len(height)-1 for i != j { area := (j-i) * min(height[i], height[j]) if area \u0026gt; result { result = area } if height[i] \u0026lt; height[j] { i = i + 1 continue } j = j - 1 } return result } func min(i, j int) int { if i \u0026lt; j {return i} return j }     "});index.add({'id':17,'href':'/myWiki/docs/arithmetic/example/linkedlist/','title':"é“¾è¡¨ linked list",'section':"æ —å­ğŸŒ°",'content':"é“¾è¡¨ linked list #   åˆå¹¶ä¸¤ä¸ªæœ‰åºåˆ—è¡¨ ...  /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode { result := \u0026amp;ListNode{} preHead := result for (l1 != nil \u0026amp;\u0026amp; l2 != nil){ if l1.Val \u0026lt; l2.Val { preHead.Next = l1 l1 = l1.Next } else { preHead.Next = l2 l2 = l2.Next } preHead = preHead.Next } if l1 == nil{ preHead.Next = l2 } if l2 == nil { preHead.Next = l1 } return result.Next }      åè½¬é“¾è¡¨ ...  /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func reverseList(head *ListNode) *ListNode { if nil == head { return head } cur, next := head, head.Next for ; nil != next; cur, next, next.Next = next, next.Next, cur { } head.Next = nil return cur }      åˆ é™¤é“¾è¡¨ä¸­çš„èŠ‚ç‚¹ ...  /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func deleteNode(node *ListNode) { node.Val, node.Next= node.Next.Val, node.Next.Next }     "});index.add({'id':18,'href':'/myWiki/docs/go-language/dev-rule/','title':"é¢å‘å¯¹è±¡è®¾è®¡åŸåˆ™",'section':"go è¯­è¨€",'content':"é¢å‘å¯¹è±¡è®¾è®¡åŸåˆ™ #  ä¾èµ–å€’ç½®åŸåˆ™ï¼ˆDIPï¼‰\n é«˜å±‚æ¨¡å—ï¼ˆç¨³å®šï¼‰ä¸åº”è¯¥ä¾èµ–åº•å±‚æ¨¡å—ï¼ˆå˜åŒ–ï¼‰ï¼ŒäºŒè€…éƒ½åº”è¯¥ä¾èµ–æŠ½è±¡ï¼ˆç¨³å®šï¼‰ æŠ½è±¡ï¼ˆç¨³å®šï¼‰ä¸åº”è¯¥ä¾èµ–å®ç°ç»†èŠ‚ï¼ˆå˜åŒ–ï¼‰ï¼Œå®ç°ç»†èŠ‚åº”è¯¥ä¾èµ–äºæŠ½è±¡ï¼ˆç¨³å®šï¼‰  å¼€æ”¾å°é—­åŸåˆ™ï¼ˆOCPï¼‰\n å¯¹æ‰©å±•å¼€æ”¾ï¼Œå¯¹æ›´æ”¹å°é—­ ç±»æ¨¡å—åº”è¯¥å¯ä»¥æ‰©å±•çš„ï¼Œä½†æ˜¯ä¸å¯ä»¥ä¿®æ”¹çš„  å•ä¸€èŒè´£åŸåˆ™ï¼ˆLSPï¼‰\n ä¸€ä¸ªç±»åº”è¯¥ä»…æœ‰ä¸€ä¸ªå¼•èµ·ä»–å˜åŒ–çš„åŸå›  å˜åŒ–çš„æ–¹å‘éšå«è¿™ç±»çš„è´£ä»»  Liskovæ›¿æ¢åŸåˆ™ï¼ˆLSPï¼‰\n å­ç±»å¿…é¡»èƒ½å¤Ÿæ›¿æ¢ä»–ä»¬çš„åŸºç±»ï¼ˆIS-Aï¼‰ ç»§æ‰¿è¡¨è¾¾ç±»å‹æŠ½è±¡  æ¥å£éš”ç¦»åŸåˆ™ï¼ˆISPï¼‰\n ä¸åº”è¯¥å¼ºè¿«å®¢æˆ·ç¨‹åºä¾èµ–ä»–ä»¬ä¸ä½¿ç”¨çš„æ–¹æ³• æ¥å£åº”è¯¥å°è€Œå®Œå¤‡  ä¼˜å…ˆä½¿ç”¨å¯¹è±¡ç»„åˆï¼Œè€Œä¸æ˜¯ç±»ç»§æ‰¿\n ç±»ç»§æ‰¿é€šå¸¸ä¸ºâ€œç™½ç®±å¤ç”¨â€ï¼Œå¯¹è±¡ç»„åˆé€šå¸¸ä¸ºâ€œé»‘ç®±å¤ç”¨â€ ç»§æ‰¿åœ¨æŸç§ç¨‹åº¦ä¸Šç ´åäº†å°è£…æ€§ï¼Œå­ç±»çˆ¶ç±»è€¦åˆåº¦é«˜ã€‚ è€Œå¯¹è±¡ç»„åˆåˆ™æ˜¯è¦æ±‚è¢«ç»„åˆçš„å¯¹è±¡æœ‰è‰¯å¥½å®šä¹‰çš„æ¥å£ï¼Œè€¦åˆåº¦ä½ã€‚  å°è£…å˜åŒ–ç‚¹\n ä½¿ç”¨å°è£…æ¥åˆ›å»ºå¯¹è±¡ä¹‹é—´çš„åˆ†ç•Œå±‚ã€‚ç±»è®¾è®¡è€…å¯ä»¥åœ¨åˆ†ç•Œçš„ä¸€ä¾§è¿›è¡Œä¿®æ”¹ï¼Œè€Œä¸ä¼šå¯¹å¦å¤–ä¸€ä¾§äº§ç”Ÿä¸è‰¯çš„å½±å“ã€‚ä»è€Œå®ç°å±‚æ¬¡é—´çš„æ¾è€¦åˆã€‚  é’ˆå¯¹æ¥å£ç¼–ç¨‹ï¼Œè€Œä¸æ˜¯é’ˆå¯¹å®ç°ç¼–ç¨‹\n ä¸å°†å˜é‡çš„ç±»å‹å£°æ˜ä¸ºæŸä¸ªç‰¹å®šçš„å…·ä½“ç±»ï¼Œè€Œå£°æ˜ä¸ºæŸæ¥å£ï¼› å®¢æˆ·ç¨‹åºæ— éœ€è·çŸ¥å¯¹è±¡çš„å…·ä½“ç±»å‹ï¼Œåªéœ€è¦çŸ¥é“å¯¹è±¡æ‰€å…·æœ‰çš„æ¥å£ï¼› å‡å°‘ç³»ç»Ÿä¸­å„éƒ¨åˆ†çš„ä¾èµ–å…³ç³»ï¼Œä»è€Œå®ç°â€œé«˜å†…èšï¼Œä½è€¦åˆâ€  "});index.add({'id':19,'href':'/myWiki/docs/arithmetic/leetcoderanking/','title':"é«˜é¢‘é¢˜ç›®",'section':"ç®—æ³•ä¸æ•°æ®ç»“æ„",'content':"LeetCode çš„é«˜é¢‘é¢˜ç›® #  DFSï¼šæ·±åº¦ä¼˜å…ˆæœç´¢ç®—æ³•ï¼ˆDepth First Searchï¼‰ï¼Œå¯¹äºäºŒå‰æ ‘è€Œè¨€ï¼Œå®ƒæ²¿ç€æ ‘çš„æ·±åº¦éå†æ ‘çš„èŠ‚ç‚¹ï¼Œå°½å¯èƒ½æ·±çš„æœç´¢æ ‘çš„åˆ†æ”¯ï¼Œè¿™ä¸€è¿‡ç¨‹ä¸€ç›´è¿›è¡Œåˆ°å·²å‘ç°ä»æºèŠ‚ç‚¹å¯è¾¾çš„æ‰€æœ‰èŠ‚ç‚¹ä¸ºæ­¢ã€‚\nå¹³è¡¡äºŒå‰æ ‘ï¼š å·¦å³å­æ ‘çš„é«˜åº¦ç›¸å·®ä¸è¶…è¿‡ 1 çš„æ ‘ä¸ºå¹³è¡¡äºŒå‰æ ‘\n   æ’å…¥æ–¹å¼ æè¿° æ—‹è½¬æ–¹å¼     LL åœ¨ A çš„å·¦å­æ ‘æ ¹èŠ‚ç‚¹çš„å·¦å­æ ‘ä¸Šæ’å…¥èŠ‚ç‚¹è€Œç ´åå¹³è¡¡ å³æ—‹è½¬   RR åœ¨ A çš„å³å­æ ‘æ ¹èŠ‚ç‚¹çš„å³å­æ ‘ä¸Šæ’å…¥èŠ‚ç‚¹è€Œç ´åå¹³è¡¡ å·¦æ—‹è½¬   LR åœ¨Açš„å·¦å­æ ‘æ ¹èŠ‚ç‚¹çš„å³å­æ ‘ä¸Šæ’å…¥èŠ‚ç‚¹è€Œç ´åå¹³è¡¡ å…ˆå·¦æ—‹åå³æ—‹   RL åœ¨ A çš„å³å­æ ‘æ ¹èŠ‚ç‚¹çš„å·¦å­æ ‘ä¸Šæ’å…¥èŠ‚ç‚¹è€Œç ´åå¹³è¡¡ å…ˆå³æ—‹åå·¦æ—‹    XOR å¼‚æˆ–è¿ç®— âŠ• #   ä»»ä½•æ•°å’Œ 0 åšå¼‚æˆ–è¿ç®—ï¼Œç»“æœä»ç„¶æ˜¯åŸæ¥çš„æ•°ï¼Œå³ aâŠ•0=aã€‚ ä»»ä½•æ•°å’Œå…¶è‡ªèº«åšå¼‚æˆ–è¿ç®—ï¼Œç»“æœæ˜¯ 0ï¼Œå³ aâŠ•a=0ã€‚ å¼‚æˆ–è¿ç®—æ»¡è¶³äº¤æ¢å¾‹å’Œç»“åˆå¾‹ï¼Œå³ aâŠ•bâŠ•a=bâŠ•aâŠ•a=bâŠ•(aâŠ•a)=bâŠ•0=bã€‚  æ±‰æ˜è·ç¦» #  ä¸¤ä¸ªæ•´æ•°ä¹‹é—´çš„æ±‰æ˜è·ç¦»æ˜¯å¯¹åº”ä½ç½®ä¸Šæ•°å­—ä¸åŒçš„ä½æ•°ã€‚XOR çš„ä½è¿ç®—ï¼Œå½“ä¸”ä»…å½“è¾“å…¥ä½ä¸åŒæ—¶è¾“å‡ºä¸º 1ã€‚\n è®¡ç®— x å’Œ y ä¹‹é—´çš„æ±‰æ˜è·ç¦»ï¼Œå¯ä»¥å…ˆè®¡ç®— x XOR yï¼Œç„¶åç»Ÿè®¡ç»“æœä¸­ç­‰äº 1 çš„ä½æ•°ã€‚\n ä¸ºäº†è®¡ç®—ç­‰äº 1 çš„ä½æ•°ï¼Œå¯ä»¥å°†æ¯ä¸ªä½ç§»åŠ¨åˆ°æœ€å·¦ä¾§æˆ–æœ€å³ä¾§ï¼Œç„¶åæ£€æŸ¥è¯¥ä½æ˜¯å¦ä¸º 1ã€‚æ£€æŸ¥æœ€å³ä½æ˜¯å¦ä¸º 1ï¼Œå¯ä»¥ä½¿ç”¨å–æ¨¡è¿ç®—ï¼ˆi % 2ï¼‰æˆ–è€… AND æ“ä½œï¼ˆi \u0026amp; 1ï¼‰ï¼Œè¿™ä¸¤ä¸ªæ“ä½œéƒ½ä¼šå±è”½æœ€å³ä½ä»¥å¤–çš„å…¶ä»–ä½ã€‚\n  å¸ƒèµ–æ©Â·å…‹å°¼æ ¹ç®—æ³• #  è¯¥ç®—æ³•ä½¿ç”¨ç‰¹å®šæ¯”ç‰¹ä½å’Œç®—æœ¯è¿ç®—ç§»é™¤ç­‰äº 1 çš„æœ€å³æ¯”ç‰¹ä½ã€‚\n å½“æˆ‘ä»¬åœ¨ number å’Œ number-1 ä¸Šåš AND ä½è¿ç®—æ—¶ï¼ŒåŸæ•°å­— number çš„æœ€å³è¾¹ç­‰äº 1 çš„æ¯”ç‰¹ä¼šè¢«ç§»é™¤ã€‚\n äºŒè¿›åˆ¶å­—ç¬¦ä¸²çš„æ¸¸æ ‡å–å€¼æ“ä½œ #  å½“å­—ç¬¦ä¸²ä¸­ a[i] ä¸º \u0026ldquo;0\u0026rdquo; æ—¶ï¼Œä¹‹é™…æ“ä½œæ¸¸æ ‡å–å‡ºçš„æ˜¯ uint8=48 ç±»å‹æ˜¯ byteï¼Œç›´æ¥ int è½¬æ¢å°±ä¼šå¾—åˆ°ä¸€ä¸ª int=48ï¼›å½“æ“ä½œ[-\u0026lsquo;\u0026lsquo;0\u0026rsquo;]ä¹‹åï¼Œç›¸å½“æ˜¯ utf8 ç¼–ç çš„ä¸¤ä¸ª 48 ç›¸å‡ï¼Œè·å¾—çš„æ˜¯ uint8=0ï¼Œint è½¬æ¢ä¹‹åå°±ä¼šå¾—åˆ°ä¸€ä¸ª int ç±»å‹çš„ 0ã€‚å¦‚æœè¯¥ä½ä¸º \u0026ldquo;1\u0026rdquo;ï¼Œç”±äºæ­£å¥½æ¯”\u0026quot;0\u0026quot;å¤š1ä¸ªç¼–ç ä½ï¼Œæ‰€ä»¥å¾—åˆ°çš„å°±æ˜¯ uint8=1ï¼Œint è½¬æ¢å³å¯å¾—åˆ° 1ã€‚\nå›æº¯ç®—æ³•ç¼–ç å…¬å¼ #  result = [] func backtrack(è·¯å¾„ï¼Œé€‰æ‹©åˆ—è¡¨) { if æ»¡è¶³ç»“æŸæ¡ä»¶ { result.add(è·¯å¾„) } return for é€‰æ‹© in é€‰æ‹©åˆ—è¡¨ { åšé€‰æ‹© backtrack(è·¯å¾„ï¼Œé€‰æ‹©åˆ—è¡¨) æ’¤é”€é€‰æ‹© } } ä½è¿ç®— bit operation #   IP åˆ° CIDR åªå‡ºç°ä¸€æ¬¡çš„æ•°å­—  å­—ç¬¦ä¸² string #   ç½—é©¬æ•°å­—è½¬æ•´æ•° æœ‰æ•ˆçš„æ‹¬å· æœ€é•¿å…¬å…±å‰ç¼€ï¼ˆå®ç°æ–¹æ³•æœ‰å¾…ä¼˜åŒ–ï¼‰ äºŒè¿›åˆ¶æ±‚å’Œ å­—ç¬¦ä¸²ç›¸åŠ  éªŒè¯å›æ–‡ä¸²  æ•°å­¦ mathematics #   æ•´æ•°åè½¬  æ•°ç»„ arrary #   ä¸¤æ•°ä¹‹å’Œ åˆå¹¶ä¸¤ä¸ªæœ‰åºæ•°ç»„ ä¸¤æ•°ä¹‹å’Œ II - è¾“å…¥æœ‰åºæ•°ç»„ æœç´¢æ—‹è½¬æ’åºæ•°ç»„ äºŒç»´æ•°ç»„ä¸­çš„æŸ¥æ‰¾ å¿«é€Ÿæ’åº ä¸‰æ•°ä¹‹å’Œ å²›å±¿çš„æœ€å¤§é¢ç§¯ æœ€é•¿è¿ç»­é€’å¢åºåˆ— æ•°ç»„ä¸­çš„ç¬¬ k ä¸ªæœ€å¤§å…ƒç´  å…¨æ’åˆ— ä¹˜æœ€å¤šæ°´çš„å®¹å™¨  é“¾è¡¨ linked list #   åˆå¹¶ä¸¤ä¸ªæœ‰åºé“¾è¡¨ åè½¬é“¾è¡¨ åˆ é™¤é“¾è¡¨ä¸­çš„èŠ‚ç‚¹  äºŒå‰æ ‘ binary tree #   åè½¬äºŒå‰æ ‘ äºŒå‰æ ‘çš„æœ€å¤§æ·±åº¦ åˆå¹¶äºŒå‰æ ‘ äºŒå‰æ ‘å±‚æ¬¡éå†2 å°†æœ‰åºæ•°ç»„è½¬åŒ–ä¸ºé«˜åº¦å¹³è¡¡äºŒå‰æœç´¢æ ‘ å¯¹ç§°äºŒå‰æ ‘ äºŒå‰æ ‘æ·±åº¦ äºŒå‰æ ‘ä¸­åºéå†  å“ˆå¸Œè¡¨ hash map #   å®çŸ³ä¸çŸ³å¤´ å²›å±¿çš„å‘¨é•¿ ä¸¤ä¸ªæ•°ç»„çš„äº¤é›†  äºŒåˆ†æŸ¥æ‰¾ binary search #   äºŒåˆ†æŸ¥æ‰¾  "});})();