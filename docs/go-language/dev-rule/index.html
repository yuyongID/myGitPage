<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="面向对象设计原则 #  依赖倒置原则（DIP）
 高层模块（稳定）不应该依赖底层模块（变化），二者都应该依赖抽象（稳定） 抽象（稳定）不应该依赖实现细节（变化），实现细节应该依赖于抽象（稳定）  开放封闭原则（OCP）
 对扩展开放，对更改封闭 类模块应该可以扩展的，但是不可以修改的  单一职责原则（LSP）
 一个类应该仅有一个引起他变化的原因 变化的方向隐含这类的责任  Liskov替换原则（LSP）
 子类必须能够替换他们的基类（IS-A） 继承表达类型抽象  接口隔离原则（ISP）
 不应该强迫客户程序依赖他们不使用的方法 接口应该小而完备  优先使用对象组合，而不是类继承
 类继承通常为“白箱复用”，对象组合通常为“黑箱复用” 继承在某种程度上破坏了封装性，子类父类耦合度高。 而对象组合则是要求被组合的对象有良好定义的接口，耦合度低。  封装变化点
 使用封装来创建对象之间的分界层。类设计者可以在分界的一侧进行修改，而不会对另外一侧产生不良的影响。从而实现层次间的松耦合。  针对接口编程，而不是针对实现编程
 不将变量的类型声明为某个特定的具体类，而声明为某接口； 客户程序无需获知对象的具体类型，只需要知道对象所具有的接口； 减少系统中各部分的依赖关系，从而实现“高内聚，低耦合”"><meta name=theme-color content="#FFFFFF"><meta property="og:title" content="面向对象设计原则"><meta property="og:description" content="面向对象设计原则 #  依赖倒置原则（DIP）
 高层模块（稳定）不应该依赖底层模块（变化），二者都应该依赖抽象（稳定） 抽象（稳定）不应该依赖实现细节（变化），实现细节应该依赖于抽象（稳定）  开放封闭原则（OCP）
 对扩展开放，对更改封闭 类模块应该可以扩展的，但是不可以修改的  单一职责原则（LSP）
 一个类应该仅有一个引起他变化的原因 变化的方向隐含这类的责任  Liskov替换原则（LSP）
 子类必须能够替换他们的基类（IS-A） 继承表达类型抽象  接口隔离原则（ISP）
 不应该强迫客户程序依赖他们不使用的方法 接口应该小而完备  优先使用对象组合，而不是类继承
 类继承通常为“白箱复用”，对象组合通常为“黑箱复用” 继承在某种程度上破坏了封装性，子类父类耦合度高。 而对象组合则是要求被组合的对象有良好定义的接口，耦合度低。  封装变化点
 使用封装来创建对象之间的分界层。类设计者可以在分界的一侧进行修改，而不会对另外一侧产生不良的影响。从而实现层次间的松耦合。  针对接口编程，而不是针对实现编程
 不将变量的类型声明为某个特定的具体类，而声明为某接口； 客户程序无需获知对象的具体类型，只需要知道对象所具有的接口； 减少系统中各部分的依赖关系，从而实现“高内聚，低耦合”"><meta property="og:type" content="article"><meta property="og:url" content="https://yuyongid.github.io/myWiki/docs/go-language/dev-rule/"><title>面向对象设计原则 | 裕用 Wiki</title><link rel=manifest href=/myWiki/manifest.json><link rel=icon href=/myWiki/favicon.png type=image/x-icon><link rel=stylesheet href=/myWiki/book.min.6cd8553a6854f4812343f0f0c8baca31271e686434f381fbe3c7226f66639176.css integrity="sha256-bNhVOmhU9IEjQ/DwyLrKMSceaGQ084H748cib2ZjkXY="><script defer src=/myWiki/en.search.min.d9046e63aa629a2cff3b122190fdac58b654d2b138315cc1b5c9f82b38d89763.js integrity="sha256-2QRuY6pimiz/OxIhkP2sWLZU0rE4MVzBtcn4KzjYl2M="></script></head><body><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><nav><h2 class=book-brand><a href=/myWiki><span>裕用 Wiki</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li><a href=/myWiki/docs/linux/>Linux</a></li><li><a href=/myWiki/docs/shell/>Shell</a></li><li class=book-section-flat><span>Docker</span><ul><li><a href=/myWiki/docs/docker/docker-learn/>Docker Learn</a></li></ul></li><li class=book-section-flat><span>go 语言</span><ul><li><a href=/myWiki/docs/go-language/go-notes/>go 语言一些笔记</a></li><li><a href=/myWiki/docs/go-language/dev-rule/ class=active>面向对象设计原则</a></li></ul></li><li class=book-section-flat><span>算法与数据结构</span><ul><li><span>栗子🌰</span><ul><li><a href=/myWiki/docs/arithmetic/example/binarysearch/>二分查找 binary search</a></li><li><a href=/myWiki/docs/arithmetic/example/binarytree/>二叉树 binary tree</a></li><li><a href=/myWiki/docs/arithmetic/example/bitoperation/>位运算 bit operation</a></li><li><a href=/myWiki/docs/arithmetic/example/hashmap/>哈希表 hash map</a></li><li><a href=/myWiki/docs/arithmetic/example/string/>字符串 string</a></li><li><a href=/myWiki/docs/arithmetic/example/mathematics/>数学 mathematics</a></li><li><a href=/myWiki/docs/arithmetic/example/array/>数组 array</a></li><li><a href=/myWiki/docs/arithmetic/example/linkedlist/>链表 linked list</a></li></ul></li><li><a href=/myWiki/docs/arithmetic/leetcoderanking/>高频题目</a></li></ul></li></ul></nav><script>(function(){var menu=document.querySelector("aside.book-menu nav");addEventListener("beforeunload",function(event){localStorage.setItem("menu.scrollTop",menu.scrollTop);});menu.scrollTop=localStorage.getItem("menu.scrollTop");})();</script></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/myWiki/svg/menu.svg class=book-icon alt=Menu></label>
<strong>面向对象设计原则</strong>
<label for=toc-control><img src=/myWiki/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#面向对象设计原则>面向对象设计原则</a></li></ul></nav></aside></header><article class=markdown><h2 id=面向对象设计原则>面向对象设计原则
<a class=anchor href=#%e9%9d%a2%e5%90%91%e5%af%b9%e8%b1%a1%e8%ae%be%e8%ae%a1%e5%8e%9f%e5%88%99>#</a></h2><p>依赖倒置原则（DIP）</p><ul><li>高层模块（稳定）不应该依赖底层模块（变化），二者都应该依赖抽象（稳定）</li><li>抽象（稳定）不应该依赖实现细节（变化），实现细节应该依赖于抽象（稳定）</li></ul><p>开放封闭原则（OCP）</p><ul><li>对扩展开放，对更改封闭</li><li>类模块应该可以扩展的，但是不可以修改的</li></ul><p>单一职责原则（LSP）</p><ul><li>一个类应该仅有一个引起他变化的原因</li><li>变化的方向隐含这类的责任</li></ul><p>Liskov替换原则（LSP）</p><ul><li>子类必须能够替换他们的基类（IS-A）</li><li>继承表达类型抽象</li></ul><p>接口隔离原则（ISP）</p><ul><li>不应该强迫客户程序依赖他们不使用的方法</li><li>接口应该小而完备</li></ul><p>优先使用对象组合，而不是类继承</p><ul><li>类继承通常为“白箱复用”，对象组合通常为“黑箱复用”</li><li>继承在某种程度上破坏了封装性，子类父类耦合度高。</li><li>而对象组合则是要求被组合的对象有良好定义的接口，耦合度低。</li></ul><p>封装变化点</p><ul><li>使用封装来创建对象之间的分界层。类设计者可以在分界的一侧进行修改，而不会对另外一侧产生不良的影响。从而实现层次间的松耦合。</li></ul><p>针对接口编程，而不是针对实现编程</p><ul><li>不将变量的类型声明为某个特定的具体类，而声明为某接口；</li><li>客户程序无需获知对象的具体类型，只需要知道对象所具有的接口；</li><li>减少系统中各部分的依赖关系，从而实现“高内聚，低耦合”</li></ul></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><nav id=TableOfContents><ul><li><a href=#面向对象设计原则>面向对象设计原则</a></li></ul></nav></aside></main></body></html>