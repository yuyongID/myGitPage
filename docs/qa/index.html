<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Python垃圾回收机制 #  Python GC主要使用引用计数（reference counting）来跟踪和回收垃圾。在引用计数的基础上，通过“标记-清除”（mark and sweep）解决容器对象可能产生的循环引用问题，通过“分代回收”（generation collection）以空间换时间的方法提高垃圾回收效率。
1 引用计数 #  PyObject是每个对象必有的内容，其中ob_refcnt就是做为引用计数。当一个对象有新的引用时，它的ob_refcnt就会增加，当引用它的对象被删除，它的ob_refcnt就会减少.引用计数为0时，该对象生命就结束了。
优点:
 简单 实时性  缺点:
 维护引用计数消耗资源 循环引用  2 标记-清除机制 #  基本思路是先按需分配，等到没有空闲内存的时候从寄存器和程序栈上的引用出发，遍历以对象为节点、以引用为边构成的图，把所有可以访问到的对象打上标记，然后清扫一遍内存空间，把所有没标记的对象释放。
3 分代技术 #  分代回收的整体思想是：将系统中的所有内存块根据其存活时间划分为不同的集合，每个集合就成为一个“代”，垃圾收集频率随着“代”的存活时间的增大而减小，存活时间通常利用经过几次垃圾回收来度量。
Python默认定义了三代对象集合，索引数越大，对象存活时间越长。
reids 数据类型 #     数据类型 最大存储 特性 应用场景     string 512MB 可以包含任何数据,比如jpg图片或者序列化的对象,一个键最大能存储512M 常规key-value缓存应用。常规计数: 微博数, 粉丝数。   hash 每个 hash 可以存储 2^32 -1 键值对（40多亿） 适合存储对象,并且可以像数据库中update一个属性一样只修改某一项属性值(Memcached中需要取出整个字符串反序列化成对象修改完再序列化存回去) 存储、读取、修改用户属性。用户对象包含姓名，年龄，生日等信息   list 列表最多可存储 2^32 - 1 元素（40多亿） 增删快,提供了操作某一段元素的API 1、最新消息排行等功能(比如朋友圈的时间线) 2、消息队列   set 集合中最大的成员数为 232 - 1 1、添加、删除、查找的复杂度都是O(1) 2、为集合提供了求交集、并集、差集等操作 1、共同好友 2、利用唯一性,统计访问网站的所有独立ip 3、好友推荐时,根据tag求交集,大于某个阈值就可以推荐   zset  数据插入集合时,已经进行天然排序 1、排行榜 2、带权重的消息队列    压测 #  线下环境压测的意义 #  缩比的压力测试环境压测出来的数据，完全不能用做生产环境的参考。但是这样的测试环境在研发阶段有其重要价值："><meta name=theme-color content="#FFFFFF"><meta property="og:title" content><meta property="og:description" content="Python垃圾回收机制 #  Python GC主要使用引用计数（reference counting）来跟踪和回收垃圾。在引用计数的基础上，通过“标记-清除”（mark and sweep）解决容器对象可能产生的循环引用问题，通过“分代回收”（generation collection）以空间换时间的方法提高垃圾回收效率。
1 引用计数 #  PyObject是每个对象必有的内容，其中ob_refcnt就是做为引用计数。当一个对象有新的引用时，它的ob_refcnt就会增加，当引用它的对象被删除，它的ob_refcnt就会减少.引用计数为0时，该对象生命就结束了。
优点:
 简单 实时性  缺点:
 维护引用计数消耗资源 循环引用  2 标记-清除机制 #  基本思路是先按需分配，等到没有空闲内存的时候从寄存器和程序栈上的引用出发，遍历以对象为节点、以引用为边构成的图，把所有可以访问到的对象打上标记，然后清扫一遍内存空间，把所有没标记的对象释放。
3 分代技术 #  分代回收的整体思想是：将系统中的所有内存块根据其存活时间划分为不同的集合，每个集合就成为一个“代”，垃圾收集频率随着“代”的存活时间的增大而减小，存活时间通常利用经过几次垃圾回收来度量。
Python默认定义了三代对象集合，索引数越大，对象存活时间越长。
reids 数据类型 #     数据类型 最大存储 特性 应用场景     string 512MB 可以包含任何数据,比如jpg图片或者序列化的对象,一个键最大能存储512M 常规key-value缓存应用。常规计数: 微博数, 粉丝数。   hash 每个 hash 可以存储 2^32 -1 键值对（40多亿） 适合存储对象,并且可以像数据库中update一个属性一样只修改某一项属性值(Memcached中需要取出整个字符串反序列化成对象修改完再序列化存回去) 存储、读取、修改用户属性。用户对象包含姓名，年龄，生日等信息   list 列表最多可存储 2^32 - 1 元素（40多亿） 增删快,提供了操作某一段元素的API 1、最新消息排行等功能(比如朋友圈的时间线) 2、消息队列   set 集合中最大的成员数为 232 - 1 1、添加、删除、查找的复杂度都是O(1) 2、为集合提供了求交集、并集、差集等操作 1、共同好友 2、利用唯一性,统计访问网站的所有独立ip 3、好友推荐时,根据tag求交集,大于某个阈值就可以推荐   zset  数据插入集合时,已经进行天然排序 1、排行榜 2、带权重的消息队列    压测 #  线下环境压测的意义 #  缩比的压力测试环境压测出来的数据，完全不能用做生产环境的参考。但是这样的测试环境在研发阶段有其重要价值："><meta property="og:type" content="article"><meta property="og:url" content="https://yuyongid.github.io/myWiki/docs/qa/"><title>Q& A | 裕用 Wiki</title><link rel=manifest href=/myWiki/manifest.json><link rel=icon href=/myWiki/favicon.png type=image/x-icon><link rel=stylesheet href=/myWiki/book.min.6cd8553a6854f4812343f0f0c8baca31271e686434f381fbe3c7226f66639176.css integrity="sha256-bNhVOmhU9IEjQ/DwyLrKMSceaGQ084H748cib2ZjkXY="><script defer src=/myWiki/en.search.min.39f1a4b7f0433c12245c7d38dc9281f5440ebdfeb6d94fa0fa7ed3bae7b9d3fb.js integrity="sha256-OfGkt/BDPBIkXH043JKB9UQOvf622U+g+n7Tuue50/s="></script></head><body><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><nav><h2 class=book-brand><a href=/myWiki><span>裕用 Wiki</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li><a href=/myWiki/docs/linux/>Linux</a></li><li><a href=/myWiki/docs/qa/ class=active>Q& A</a></li><li><a href=/myWiki/docs/shell/>Shell</a></li><li class=book-section-flat><span>Docker</span><ul><li><a href=/myWiki/docs/docker/docker-learn/>Docker Learn</a></li></ul></li><li class=book-section-flat><span>go 语言</span><ul><li><a href=/myWiki/docs/go-language/go-notes/>go 语言一些笔记</a></li><li><a href=/myWiki/docs/go-language/dev-rule/>面向对象设计原则</a></li></ul></li><li class=book-section-flat><span>算法与数据结构</span><ul><li><span>栗子🌰</span><ul><li><a href=/myWiki/docs/arithmetic/example/binarysearch/>二分查找 binary search</a></li><li><a href=/myWiki/docs/arithmetic/example/binarytree/>二叉树 binary tree</a></li><li><a href=/myWiki/docs/arithmetic/example/bitoperation/>位运算 bit operation</a></li><li><a href=/myWiki/docs/arithmetic/example/hashmap/>哈希表 hash map</a></li><li><a href=/myWiki/docs/arithmetic/example/string/>字符串 string</a></li><li><a href=/myWiki/docs/arithmetic/example/mathematics/>数学 mathematics</a></li><li><a href=/myWiki/docs/arithmetic/example/array/>数组 array</a></li><li><a href=/myWiki/docs/arithmetic/example/linkedlist/>链表 linked list</a></li></ul></li><li><a href=/myWiki/docs/arithmetic/leetcoderanking/>高频题目</a></li></ul></li></ul></nav><script>(function(){var menu=document.querySelector("aside.book-menu nav");addEventListener("beforeunload",function(event){localStorage.setItem("menu.scrollTop",menu.scrollTop);});menu.scrollTop=localStorage.getItem("menu.scrollTop");})();</script></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/myWiki/svg/menu.svg class=book-icon alt=Menu></label>
<strong>Q& A</strong>
<label for=toc-control><img src=/myWiki/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#python垃圾回收机制>Python垃圾回收机制</a><ul><li><a href=#1-引用计数>1 引用计数</a></li><li><a href=#2-标记-清除机制>2 标记-清除机制</a></li><li><a href=#3-分代技术>3 分代技术</a></li></ul></li><li><a href=#reids-数据类型>reids 数据类型</a></li><li><a href=#压测>压测</a><ul><li><a href=#线下环境压测的意义>线下环境压测的意义</a></li><li><a href=#压测制定的考虑>压测制定的考虑</a></li><li><a href=#分布式锁>分布式锁</a></li><li><a href=#乐观锁和悲观锁>乐观锁和悲观锁</a></li></ul></li></ul></nav></aside></header><article class=markdown><h2 id=python垃圾回收机制>Python垃圾回收机制
<a class=anchor href=#python%e5%9e%83%e5%9c%be%e5%9b%9e%e6%94%b6%e6%9c%ba%e5%88%b6>#</a></h2><p>Python GC主要使用引用计数（reference counting）来跟踪和回收垃圾。在引用计数的基础上，通过“标记-清除”（mark and sweep）解决容器对象可能产生的循环引用问题，通过“分代回收”（generation collection）以空间换时间的方法提高垃圾回收效率。</p><h3 id=1-引用计数>1 引用计数
<a class=anchor href=#1-%e5%bc%95%e7%94%a8%e8%ae%a1%e6%95%b0>#</a></h3><p>PyObject是每个对象必有的内容，其中<code>ob_refcnt</code>就是做为引用计数。当一个对象有新的引用时，它的<code>ob_refcnt</code>就会增加，当引用它的对象被删除，它的<code>ob_refcnt</code>就会减少.引用计数为0时，该对象生命就结束了。</p><p>优点:</p><ol><li>简单</li><li>实时性</li></ol><p>缺点:</p><ol><li>维护引用计数消耗资源</li><li>循环引用</li></ol><h3 id=2-标记-清除机制>2 标记-清除机制
<a class=anchor href=#2-%e6%a0%87%e8%ae%b0-%e6%b8%85%e9%99%a4%e6%9c%ba%e5%88%b6>#</a></h3><p>基本思路是先按需分配，等到没有空闲内存的时候从寄存器和程序栈上的引用出发，遍历以对象为节点、以引用为边构成的图，把所有可以访问到的对象打上标记，然后清扫一遍内存空间，把所有没标记的对象释放。</p><h3 id=3-分代技术>3 分代技术
<a class=anchor href=#3-%e5%88%86%e4%bb%a3%e6%8a%80%e6%9c%af>#</a></h3><p>分代回收的整体思想是：将系统中的所有内存块根据其存活时间划分为不同的集合，每个集合就成为一个“代”，垃圾收集频率随着“代”的存活时间的增大而减小，存活时间通常利用经过几次垃圾回收来度量。</p><p>Python默认定义了三代对象集合，索引数越大，对象存活时间越长。</p><h2 id=reids-数据类型>reids 数据类型
<a class=anchor href=#reids-%e6%95%b0%e6%8d%ae%e7%b1%bb%e5%9e%8b>#</a></h2><table><thead><tr><th align=left>数据类型</th><th align=left>最大存储</th><th align=left>特性</th><th align=left>应用场景</th></tr></thead><tbody><tr><td align=left>string</td><td align=left>512MB</td><td align=left>可以包含任何数据,比如jpg图片或者序列化的对象,一个键最大能存储512M</td><td align=left>常规key-value缓存应用。常规计数: 微博数, 粉丝数。</td></tr><tr><td align=left>hash</td><td align=left>每个 hash 可以存储 2^32 -1 键值对（40多亿）</td><td align=left>适合存储对象,并且可以像数据库中update一个属性一样只修改某一项属性值(Memcached中需要取出整个字符串反序列化成对象修改完再序列化存回去)</td><td align=left>存储、读取、修改用户属性。用户对象包含姓名，年龄，生日等信息</td></tr><tr><td align=left>list</td><td align=left>列表最多可存储 2^32 - 1 元素（40多亿）</td><td align=left>增删快,提供了操作某一段元素的API</td><td align=left>1、最新消息排行等功能(比如朋友圈的时间线) 2、消息队列</td></tr><tr><td align=left>set</td><td align=left>集合中最大的成员数为 232 - 1</td><td align=left>1、添加、删除、查找的复杂度都是O(1) 2、为集合提供了求交集、并集、差集等操作</td><td align=left>1、共同好友 2、利用唯一性,统计访问网站的所有独立ip 3、好友推荐时,根据tag求交集,大于某个阈值就可以推荐</td></tr><tr><td align=left>zset</td><td align=left></td><td align=left>数据插入集合时,已经进行天然排序</td><td align=left>1、排行榜 2、带权重的消息队列</td></tr></tbody></table><h2 id=压测>压测
<a class=anchor href=#%e5%8e%8b%e6%b5%8b>#</a></h2><h3 id=线下环境压测的意义>线下环境压测的意义
<a class=anchor href=#%e7%ba%bf%e4%b8%8b%e7%8e%af%e5%a2%83%e5%8e%8b%e6%b5%8b%e7%9a%84%e6%84%8f%e4%b9%89>#</a></h3><p>缩比的压力测试环境压测出来的数据，完全不能用做生产环境的参考。但是这样的测试环境在研发阶段有其重要价值：</p><ol><li>上线前发现性能瓶颈：链接异常为释放，线程数过多等；</li><li>应用基线数据：每次上线前压一次，对比历史数据即可发现是否有提升；</li><li>快速吸能调优及验证；</li></ol><h3 id=压测制定的考虑>压测制定的考虑
<a class=anchor href=#%e5%8e%8b%e6%b5%8b%e5%88%b6%e5%ae%9a%e7%9a%84%e8%80%83%e8%99%91>#</a></h3><ol><li>流量模型的去定。可以基于业务的一段时间各接口的峰值，最后拼装成流量模型；</li><li>脏数据问题。有专用测试账户和单独请求头部两种方式，最终数据落到影子库和影子表里。仿真环境要多测试，数据要有多重机制保障；</li><li>监控覆盖度要足够；</li><li>压测扩展。验证其他功能，类似限流，熔断，降级；</li><li>参数调优。nginx配置，linux内核参数快速回收等；</li><li>缓存和数据库。重要业务有缓存，reids cpu 高是否有模糊匹配，高时间复杂度的指令，mysql 的索引添加，慢查询；</li><li>mock服务。计费，短信；</li><li>cpu阈值。50%～70%，响应时间1s为宜；</li></ol><hr><h3 id=分布式锁>分布式锁
<a class=anchor href=#%e5%88%86%e5%b8%83%e5%bc%8f%e9%94%81>#</a></h3><p>常用的分布式锁的实现有三种方式。</p><ul><li><p>基于redis实现（利用redis的原子性操作setnx来实现）</p><ol><li>每次进来先检测一下这个key是否实现。如果失效了移除失效锁</li><li>使用setnx原子命令争抢锁。Redis Setnx（<strong>SET</strong> if <strong>N</strong>ot e<strong>X</strong>ists） 命令在指定的 key 不存在时，为 key 设置指定的值，确认返回值为 1。属于 string 的数据类型。</li><li>抢到锁的设置过期时间。EXPIRE key 10086 设置 key 生存时间为 10086 秒</li></ol><blockquote><p>优点：redis本身是内存操作、并且通常是多片部署，因此有这较高的并发控制，可以抗住大量的请求。</p><p>缺点：redis本身是缓存，有一定概率出现数据不一致请求。</p></blockquote></li><li><p>基于 mysql 实现（利用 mysql 的 innodb 的行锁来实现，有两种方式， 排他锁与共享锁）</p><ul><li><code>SELECT ... FOR UPDATE</code> 是排他锁，其他事物不能读取，也不能写。</li></ul><blockquote><p>为选择的行添加排它锁(X锁)，保证查询到的数据是最新的数据，允许其它事务对该数据加上共享锁(S锁)，但不能修改，只有当前事务可以修改，其它事务需要等当前事务 commit 或 rollback 之后才可以修改加锁的行;</p></blockquote><ul><li><code>SELECT ... LOCK IN SHARE MODE</code>是共享锁，其他事务可以读，但不能写。</li></ul><blockquote><p>为选择的行添加共享锁(S锁)，其它事务也可以对该行数据添加S锁，它保证了读取到的是最新的数据，并且不允许别人修改，但是自己也 <strong>不一定</strong> 能够修改，因为可能别的事务也对这个数据加了S锁;</p></blockquote></li><li><p>基于Zookeeper实现（利用zk的临时顺序节点来实现）</p></li></ul><h3 id=乐观锁和悲观锁>乐观锁和悲观锁
<a class=anchor href=#%e4%b9%90%e8%a7%82%e9%94%81%e5%92%8c%e6%82%b2%e8%a7%82%e9%94%81>#</a></h3><ul><li><p><strong>乐观锁(Optimistic Lock)</strong>：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。 乐观锁不能解决脏读的问题。</p></li><li><p><strong>悲观锁(Pessimistic Lock)</strong>：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。</p></li></ul></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><nav id=TableOfContents><ul><li><a href=#python垃圾回收机制>Python垃圾回收机制</a><ul><li><a href=#1-引用计数>1 引用计数</a></li><li><a href=#2-标记-清除机制>2 标记-清除机制</a></li><li><a href=#3-分代技术>3 分代技术</a></li></ul></li><li><a href=#reids-数据类型>reids 数据类型</a></li><li><a href=#压测>压测</a><ul><li><a href=#线下环境压测的意义>线下环境压测的意义</a></li><li><a href=#压测制定的考虑>压测制定的考虑</a></li><li><a href=#分布式锁>分布式锁</a></li><li><a href=#乐观锁和悲观锁>乐观锁和悲观锁</a></li></ul></li></ul></nav></aside></main></body></html>