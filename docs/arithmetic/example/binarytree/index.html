<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="二叉树 binary tree #   反转二叉树 ...  /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func invertTree(root *TreeNode) *TreeNode { if root == nil { return nil } root.Right, root.Left = invertTree(root.Left), invertTree(root.Right) return root }      二叉树的最大深度 ...  /** * Definition for a binary tree node."><meta name=theme-color content="#FFFFFF"><meta property="og:title" content="二叉树 binary tree"><meta property="og:description" content="二叉树 binary tree #   反转二叉树 ...  /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func invertTree(root *TreeNode) *TreeNode { if root == nil { return nil } root.Right, root.Left = invertTree(root.Left), invertTree(root.Right) return root }      二叉树的最大深度 ...  /** * Definition for a binary tree node."><meta property="og:type" content="article"><meta property="og:url" content="https://yuyongid.github.io/myWiki/docs/arithmetic/example/binarytree/"><title>二叉树 binary tree | 裕用 Wiki</title><link rel=manifest href=/myWiki/manifest.json><link rel=icon href=/myWiki/favicon.png type=image/x-icon><link rel=stylesheet href=/myWiki/book.min.6cd8553a6854f4812343f0f0c8baca31271e686434f381fbe3c7226f66639176.css integrity="sha256-bNhVOmhU9IEjQ/DwyLrKMSceaGQ084H748cib2ZjkXY="><script defer src=/myWiki/en.search.min.42aa2e0dc3fe5e0605ba7b140df725ac1d98936135dd05905f57b00f2321fdb8.js integrity="sha256-QqouDcP+XgYFunsUDfclrB2Yk2E13QWQX1ewDyMh/bg="></script></head><body><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><nav><h2 class=book-brand><a href=/myWiki><span>裕用 Wiki</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li><a href=/myWiki/docs/linux/>Linux</a></li><li><a href=/myWiki/docs/shell/>Shell</a></li><li class=book-section-flat><span>Docker</span><ul><li><a href=/myWiki/docs/docker/docker-learn/>Docker Learn</a></li></ul></li><li class=book-section-flat><span>go 语言</span><ul><li><a href=/myWiki/docs/go-language/go-notes/>go 语言一些笔记</a></li><li><a href=/myWiki/docs/go-language/dev-rule/>面向对象设计原则</a></li></ul></li><li class=book-section-flat><span>算法与数据结构</span><ul><li><span>栗子🌰</span><ul><li><a href=/myWiki/docs/arithmetic/example/binarytree/ class=active>二叉树 binary tree</a></li><li><a href=/myWiki/docs/arithmetic/example/bitoperation/>位运算 bit operation</a></li><li><a href=/myWiki/docs/arithmetic/example/hashmap/>哈希表 hash map</a></li><li><a href=/myWiki/docs/arithmetic/example/string/>字符串 string</a></li><li><a href=/myWiki/docs/arithmetic/example/mathematics/>数学 mathematics</a></li><li><a href=/myWiki/docs/arithmetic/example/array/>数组 array</a></li><li><a href=/myWiki/docs/arithmetic/example/linkedlist/>链表 linked list</a></li></ul></li><li><a href=/myWiki/docs/arithmetic/leetcoderanking/>高频题目</a></li></ul></li></ul></nav><script>(function(){var menu=document.querySelector("aside.book-menu nav");addEventListener("beforeunload",function(event){localStorage.setItem("menu.scrollTop",menu.scrollTop);});menu.scrollTop=localStorage.getItem("menu.scrollTop");})();</script></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/myWiki/svg/menu.svg class=book-icon alt=Menu></label>
<strong>二叉树 binary tree</strong>
<label for=toc-control><img src=/myWiki/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#二叉树-binary-tree>二叉树 binary tree</a></li></ul></nav></aside></header><article class=markdown><h2 id=二叉树-binary-tree>二叉树 binary tree
<a class=anchor href=#%e4%ba%8c%e5%8f%89%e6%a0%91-binary-tree>#</a></h2><div class=book-expand><label><div class="book-expand-head flex justify-between"><span>反转二叉树</span>
<span>...</span></div><input type=checkbox class=hidden><div class="book-expand-content markdown-inner"><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#75715e>/**
</span><span style=color:#75715e> * Definition for a binary tree node.
</span><span style=color:#75715e> * type TreeNode struct {
</span><span style=color:#75715e> *     Val int
</span><span style=color:#75715e> *     Left *TreeNode
</span><span style=color:#75715e> *     Right *TreeNode
</span><span style=color:#75715e> * }
</span><span style=color:#75715e> */</span>
<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>invertTree</span>(<span style=color:#a6e22e>root</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span>) <span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span> {
    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>root</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>
    }
    <span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Right</span>, <span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Left</span> = <span style=color:#a6e22e>invertTree</span>(<span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Left</span>), <span style=color:#a6e22e>invertTree</span>(<span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Right</span>)
    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>root</span>
}
</code></pre></div></div></label></div><div class=book-expand><label><div class="book-expand-head flex justify-between"><span>二叉树的最大深度</span>
<span>...</span></div><input type=checkbox class=hidden><div class="book-expand-content markdown-inner"><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#75715e>/**
</span><span style=color:#75715e> * Definition for a binary tree node.
</span><span style=color:#75715e> * type TreeNode struct {
</span><span style=color:#75715e> *     Val int
</span><span style=color:#75715e> *     Left *TreeNode
</span><span style=color:#75715e> *     Right *TreeNode
</span><span style=color:#75715e> * }
</span><span style=color:#75715e> */</span>
<span style=color:#75715e>// 递归方式
</span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>maxDepth</span>(<span style=color:#a6e22e>root</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span>) <span style=color:#66d9ef>int</span> {
    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>root</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
        <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>
    }
    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Right</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Left</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
      <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>1</span>
    }
    <span style=color:#a6e22e>leftDepth</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>maxDepth</span>(<span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Left</span>)
    <span style=color:#a6e22e>rightDepth</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>maxDepth</span>(<span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Right</span>)
    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>leftDepth</span> &gt; <span style=color:#a6e22e>rightDepth</span> {
        <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>1</span><span style=color:#f92672>+</span><span style=color:#a6e22e>leftDepth</span>
    }
    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>1</span><span style=color:#f92672>+</span><span style=color:#a6e22e>rightDepth</span>
}

<span style=color:#75715e>// BFS 迭代方式
</span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>maxDepth</span>(<span style=color:#a6e22e>root</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span>) <span style=color:#66d9ef>int</span> {
    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>root</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
        <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>
    }
    <span style=color:#a6e22e>queue</span> <span style=color:#f92672>:=</span> []<span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span>{<span style=color:#a6e22e>root</span>,}
    <span style=color:#a6e22e>depth</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>
    <span style=color:#66d9ef>for</span> len(<span style=color:#a6e22e>queue</span>) &gt; <span style=color:#ae81ff>0</span>{
        <span style=color:#a6e22e>size</span> <span style=color:#f92672>:=</span> len(<span style=color:#a6e22e>queue</span>)
        <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span><span style=color:#f92672>:=</span><span style=color:#ae81ff>0</span>;<span style=color:#a6e22e>i</span>&lt;<span style=color:#a6e22e>size</span>;<span style=color:#a6e22e>i</span><span style=color:#f92672>++</span>{
            <span style=color:#a6e22e>node</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>queue</span>[<span style=color:#ae81ff>0</span>]
            <span style=color:#a6e22e>queue</span> = <span style=color:#a6e22e>queue</span>[<span style=color:#ae81ff>1</span>:]
            <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>Left</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
                <span style=color:#a6e22e>queue</span> = append(<span style=color:#a6e22e>queue</span>, <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>Left</span>)
            }
            <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>Right</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
                <span style=color:#a6e22e>queue</span> = append(<span style=color:#a6e22e>queue</span>, <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>Right</span>)
            }
        }
        <span style=color:#a6e22e>depth</span> = <span style=color:#a6e22e>depth</span><span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>
    }
    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>depth</span>
}
</code></pre></div></div></label></div><div class=book-expand><label><div class="book-expand-head flex justify-between"><span>合并二叉树</span>
<span>...</span></div><input type=checkbox class=hidden><div class="book-expand-content markdown-inner"><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#75715e>/**
</span><span style=color:#75715e> * Definition for a binary tree node.
</span><span style=color:#75715e> * type TreeNode struct {
</span><span style=color:#75715e> *     Val int
</span><span style=color:#75715e> *     Left *TreeNode
</span><span style=color:#75715e> *     Right *TreeNode
</span><span style=color:#75715e> * }
</span><span style=color:#75715e> */</span>
<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>mergeTrees</span>(<span style=color:#a6e22e>t1</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span>, <span style=color:#a6e22e>t2</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span>) <span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span> {
    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>t1</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
        <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>t2</span>
    }
    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>t2</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
        <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>t1</span>
    }
    <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>nodeLeft</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span>
    <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>nodeRight</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span>
    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>t1</span>.<span style=color:#a6e22e>Left</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>t1</span>.<span style=color:#a6e22e>Right</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
        <span style=color:#a6e22e>nodeLeft</span> = <span style=color:#a6e22e>t2</span>.<span style=color:#a6e22e>Left</span>
        <span style=color:#a6e22e>nodeRight</span> = <span style=color:#a6e22e>t2</span>.<span style=color:#a6e22e>Right</span>
    }
    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>t2</span>.<span style=color:#a6e22e>Left</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>t2</span>.<span style=color:#a6e22e>Right</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
        <span style=color:#a6e22e>nodeLeft</span> = <span style=color:#a6e22e>t1</span>.<span style=color:#a6e22e>Left</span>
        <span style=color:#a6e22e>nodeRight</span> = <span style=color:#a6e22e>t1</span>.<span style=color:#a6e22e>Right</span>
    }
    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>nodeLeft</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
        <span style=color:#a6e22e>nodeLeft</span> = <span style=color:#a6e22e>mergeTrees</span>(<span style=color:#a6e22e>t1</span>.<span style=color:#a6e22e>Left</span>, <span style=color:#a6e22e>t2</span>.<span style=color:#a6e22e>Left</span>)
    }
    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>nodeRight</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
        <span style=color:#a6e22e>nodeRight</span> = <span style=color:#a6e22e>mergeTrees</span>(<span style=color:#a6e22e>t1</span>.<span style=color:#a6e22e>Right</span>, <span style=color:#a6e22e>t2</span>.<span style=color:#a6e22e>Right</span>)
    }
    <span style=color:#a6e22e>node</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>TreeNode</span>{
        <span style=color:#a6e22e>Val</span>: <span style=color:#a6e22e>t1</span>.<span style=color:#a6e22e>Val</span><span style=color:#f92672>+</span><span style=color:#a6e22e>t2</span>.<span style=color:#a6e22e>Val</span>,
        <span style=color:#a6e22e>Left</span>: <span style=color:#a6e22e>nodeLeft</span>,
        <span style=color:#a6e22e>Right</span>: <span style=color:#a6e22e>nodeRight</span>,
    }
    <span style=color:#66d9ef>return</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>node</span>
}
</code></pre></div></div></label></div><div class=book-expand><label><div class="book-expand-head flex justify-between"><span>二叉树层次遍历2</span>
<span>...</span></div><input type=checkbox class=hidden><div class="book-expand-content markdown-inner"><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#75715e>/**
</span><span style=color:#75715e> * Definition for a binary tree node.
</span><span style=color:#75715e> * type TreeNode struct {
</span><span style=color:#75715e> *     Val int
</span><span style=color:#75715e> *     Left *TreeNode
</span><span style=color:#75715e> *     Right *TreeNode
</span><span style=color:#75715e> * }
</span><span style=color:#75715e> */</span>
<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>levelOrderBottom</span>(<span style=color:#a6e22e>root</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span>) [][]<span style=color:#66d9ef>int</span> {
    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>root</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>
    }
    <span style=color:#a6e22e>queue</span> <span style=color:#f92672>:=</span> []<span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span>{<span style=color:#a6e22e>root</span>}
    <span style=color:#a6e22e>result</span> <span style=color:#f92672>:=</span> [][]<span style=color:#66d9ef>int</span>{}
    <span style=color:#66d9ef>for</span> len(<span style=color:#a6e22e>queue</span>) &gt; <span style=color:#ae81ff>0</span> {
        <span style=color:#a6e22e>levelVal</span> <span style=color:#f92672>:=</span> []<span style=color:#66d9ef>int</span>{}
        <span style=color:#a6e22e>size</span> <span style=color:#f92672>:=</span> len(<span style=color:#a6e22e>queue</span>)
        <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span><span style=color:#f92672>:=</span><span style=color:#ae81ff>0</span>;<span style=color:#a6e22e>i</span>&lt;<span style=color:#a6e22e>size</span>;<span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
            <span style=color:#a6e22e>levelVal</span> = append(<span style=color:#a6e22e>levelVal</span>, <span style=color:#a6e22e>queue</span>[<span style=color:#a6e22e>i</span>].<span style=color:#a6e22e>Val</span>)
            <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>queue</span>[<span style=color:#a6e22e>i</span>].<span style=color:#a6e22e>Left</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
                <span style=color:#a6e22e>queue</span> = append(<span style=color:#a6e22e>queue</span>, <span style=color:#a6e22e>queue</span>[<span style=color:#a6e22e>i</span>].<span style=color:#a6e22e>Left</span>)
            }
            <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>queue</span>[<span style=color:#a6e22e>i</span>].<span style=color:#a6e22e>Right</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
                <span style=color:#a6e22e>queue</span> = append(<span style=color:#a6e22e>queue</span>, <span style=color:#a6e22e>queue</span>[<span style=color:#a6e22e>i</span>].<span style=color:#a6e22e>Right</span>)
            }
        }
        <span style=color:#a6e22e>queue</span> = <span style=color:#a6e22e>queue</span>[<span style=color:#a6e22e>size</span>:]
        <span style=color:#a6e22e>result</span> = append([][]<span style=color:#66d9ef>int</span>{<span style=color:#a6e22e>levelVal</span>}, <span style=color:#a6e22e>result</span><span style=color:#f92672>...</span>)
    }
    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>result</span>
}
</code></pre></div></div></label></div><div class=book-expand><label><div class="book-expand-head flex justify-between"><span>将有序数组转化为高度平衡二叉搜索树</span>
<span>...</span></div><input type=checkbox class=hidden><div class="book-expand-content markdown-inner"><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>sortedArrayToBST</span>(<span style=color:#a6e22e>nums</span> []<span style=color:#66d9ef>int</span>) <span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span> {
    <span style=color:#66d9ef>if</span> len(<span style=color:#a6e22e>nums</span>) <span style=color:#f92672>&lt;=</span><span style=color:#ae81ff>0</span> {
        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>
    }
    <span style=color:#66d9ef>if</span> len(<span style=color:#a6e22e>nums</span>) <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span> {
        <span style=color:#66d9ef>return</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>TreeNode</span>{<span style=color:#a6e22e>Val</span>:<span style=color:#a6e22e>nums</span>[<span style=color:#ae81ff>0</span>]}
    }
    <span style=color:#a6e22e>mid</span> <span style=color:#f92672>:=</span> len(<span style=color:#a6e22e>nums</span>)<span style=color:#f92672>/</span><span style=color:#ae81ff>2</span>
    <span style=color:#66d9ef>return</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>TreeNode</span>{
        <span style=color:#a6e22e>Val</span>: <span style=color:#a6e22e>nums</span>[<span style=color:#a6e22e>mid</span>],
        <span style=color:#a6e22e>Left</span>: <span style=color:#a6e22e>sortedArrayToBST</span>(<span style=color:#a6e22e>nums</span>[:<span style=color:#a6e22e>mid</span>]),
        <span style=color:#a6e22e>Right</span>: <span style=color:#a6e22e>sortedArrayToBST</span>(<span style=color:#a6e22e>nums</span>[<span style=color:#a6e22e>mid</span><span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>:]),
    }
}
</code></pre></div></div></label></div><div class=book-expand><label><div class="book-expand-head flex justify-between"><span>对称二叉树</span>
<span>...</span></div><input type=checkbox class=hidden><div class="book-expand-content markdown-inner"><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#75715e>/**
</span><span style=color:#75715e> * Definition for a binary tree node.
</span><span style=color:#75715e> * type TreeNode struct {
</span><span style=color:#75715e> *     Val int
</span><span style=color:#75715e> *     Left *TreeNode
</span><span style=color:#75715e> *     Right *TreeNode
</span><span style=color:#75715e> * }
</span><span style=color:#75715e> */</span>
<span style=color:#75715e>// 递归遍历，传入双树，递归对比左树和右
</span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>isSymmetric</span>(<span style=color:#a6e22e>root</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span>) <span style=color:#66d9ef>bool</span> {
    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>checker</span>(<span style=color:#a6e22e>root</span>, <span style=color:#a6e22e>root</span>)
}
<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>checker</span>(<span style=color:#a6e22e>left</span>, <span style=color:#a6e22e>right</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span>) <span style=color:#66d9ef>bool</span> {
    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>left</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>right</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>
    }
    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>left</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> <span style=color:#f92672>||</span> <span style=color:#a6e22e>right</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>
    }
    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>left</span>.<span style=color:#a6e22e>Val</span> <span style=color:#f92672>==</span> <span style=color:#a6e22e>right</span>.<span style=color:#a6e22e>Val</span> <span style=color:#f92672>&amp;&amp;</span>
        <span style=color:#a6e22e>checker</span>(<span style=color:#a6e22e>left</span>.<span style=color:#a6e22e>Left</span>, <span style=color:#a6e22e>right</span>.<span style=color:#a6e22e>Right</span>) <span style=color:#f92672>&amp;&amp;</span>
        <span style=color:#a6e22e>checker</span>(<span style=color:#a6e22e>left</span>.<span style=color:#a6e22e>Right</span>, <span style=color:#a6e22e>right</span>.<span style=color:#a6e22e>Left</span>)
}
<span style=color:#75715e>// 迭代遍历，用队列缓存取一双一双自左树和右树的镜像节点。然后从队列中取出一双来进行节点值对比。相等就把两个对比完的节点的镜像值一双一双存进队列。
</span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>isSymmetric</span>(<span style=color:#a6e22e>root</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span>) <span style=color:#66d9ef>bool</span> {
    <span style=color:#a6e22e>queue</span> <span style=color:#f92672>:=</span> []<span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span>{
        <span style=color:#a6e22e>root</span>,
        <span style=color:#a6e22e>root</span>,
    }
    <span style=color:#66d9ef>for</span> len(<span style=color:#a6e22e>queue</span>) &gt; <span style=color:#ae81ff>0</span> {
        <span style=color:#a6e22e>left</span>, <span style=color:#a6e22e>right</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>queue</span>[<span style=color:#ae81ff>0</span>], <span style=color:#a6e22e>queue</span>[<span style=color:#ae81ff>1</span>]
        <span style=color:#a6e22e>queue</span> = <span style=color:#a6e22e>queue</span>[<span style=color:#ae81ff>2</span>:]
        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>left</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>right</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
            <span style=color:#66d9ef>continue</span>
        }
        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>left</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> <span style=color:#f92672>||</span> <span style=color:#a6e22e>right</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>
        }
        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>left</span>.<span style=color:#a6e22e>Val</span> <span style=color:#f92672>!=</span> <span style=color:#a6e22e>right</span>.<span style=color:#a6e22e>Val</span> {
            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>
        }
        <span style=color:#a6e22e>queue</span> = append(<span style=color:#a6e22e>queue</span>, <span style=color:#a6e22e>left</span>.<span style=color:#a6e22e>Left</span>)
        <span style=color:#a6e22e>queue</span> = append(<span style=color:#a6e22e>queue</span>, <span style=color:#a6e22e>right</span>.<span style=color:#a6e22e>Right</span>)
        <span style=color:#a6e22e>queue</span> = append(<span style=color:#a6e22e>queue</span>, <span style=color:#a6e22e>left</span>.<span style=color:#a6e22e>Right</span>)
        <span style=color:#a6e22e>queue</span> = append(<span style=color:#a6e22e>queue</span>, <span style=color:#a6e22e>right</span>.<span style=color:#a6e22e>Left</span>)
    }
    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>
}
</code></pre></div></div></label></div><div class=book-expand><label><div class="book-expand-head flex justify-between"><span>二叉树深度</span>
<span>...</span></div><input type=checkbox class=hidden><div class="book-expand-content markdown-inner"><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#75715e>/**
</span><span style=color:#75715e> * Definition for a binary tree node.
</span><span style=color:#75715e> * type TreeNode struct {
</span><span style=color:#75715e> *     Val int
</span><span style=color:#75715e> *     Left *TreeNode
</span><span style=color:#75715e> *     Right *TreeNode
</span><span style=color:#75715e> * }
</span><span style=color:#75715e> */</span>
<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>maxDepth</span>(<span style=color:#a6e22e>root</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span>) <span style=color:#66d9ef>int</span> {
    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>root</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
        <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>
    }
    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Left</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Right</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
        <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>1</span>
    }
    <span style=color:#a6e22e>leftDepth</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>maxDepth</span>(<span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Left</span>)
    <span style=color:#a6e22e>rightDepth</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>maxDepth</span>(<span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Right</span>)
    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>leftDepth</span> &gt; <span style=color:#a6e22e>rightDepth</span> {
        <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>leftDepth</span>
    }
    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>rightDepth</span>
}
</code></pre></div></div></label></div><div class=book-expand><label><div class="book-expand-head flex justify-between"><span>二叉树中序遍历</span>
<span>...</span></div><input type=checkbox class=hidden><div class="book-expand-content markdown-inner"><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#75715e>/**
</span><span style=color:#75715e> * Definition for a binary tree node.
</span><span style=color:#75715e> * type TreeNode struct {
</span><span style=color:#75715e> *     Val int
</span><span style=color:#75715e> *     Left *TreeNode
</span><span style=color:#75715e> *     Right *TreeNode
</span><span style=color:#75715e> * }
</span><span style=color:#75715e> */</span>
<span style=color:#75715e>// 递归方式
</span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>inorderTraversal</span>(<span style=color:#a6e22e>root</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span>) []<span style=color:#66d9ef>int</span> {
    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>root</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
        <span style=color:#66d9ef>return</span> []<span style=color:#66d9ef>int</span>{}
    }
    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Left</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Right</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
        <span style=color:#66d9ef>return</span> []<span style=color:#66d9ef>int</span>{<span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Val</span>}
    }
    <span style=color:#a6e22e>leftList</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>inorderTraversal</span>(<span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Left</span>)
    <span style=color:#a6e22e>rightList</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>inorderTraversal</span>(<span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Right</span>)
    <span style=color:#a6e22e>result</span> <span style=color:#f92672>:=</span> append(<span style=color:#a6e22e>leftList</span>, <span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Val</span>)
    <span style=color:#a6e22e>result</span> = append(<span style=color:#a6e22e>result</span>, <span style=color:#a6e22e>rightList</span><span style=color:#f92672>...</span>)
    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>result</span>
}
<span style=color:#75715e>// 迭代方式
</span><span style=color:#75715e></span><span style=color:#75715e>/**
</span><span style=color:#75715e> * Definition for a binary tree node.
</span><span style=color:#75715e> * type TreeNode struct {
</span><span style=color:#75715e> *     Val int
</span><span style=color:#75715e> *     Left *TreeNode
</span><span style=color:#75715e> *     Right *TreeNode
</span><span style=color:#75715e> * }
</span><span style=color:#75715e> */</span>
<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>inorderTraversal</span>(<span style=color:#a6e22e>root</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span>) []<span style=color:#66d9ef>int</span> {
    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>root</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
        <span style=color:#66d9ef>return</span> []<span style=color:#66d9ef>int</span>{}
    }
    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Left</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Right</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
        <span style=color:#66d9ef>return</span> []<span style=color:#66d9ef>int</span>{<span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Val</span>}
    }
    <span style=color:#a6e22e>result</span> <span style=color:#f92672>:=</span> []<span style=color:#66d9ef>int</span>{}
    <span style=color:#a6e22e>stack</span> <span style=color:#f92672>:=</span> []<span style=color:#f92672>*</span><span style=color:#a6e22e>TreeNode</span>{<span style=color:#a6e22e>root</span>}
    <span style=color:#66d9ef>for</span> len(<span style=color:#a6e22e>stack</span>) &gt; <span style=color:#ae81ff>0</span> {
        <span style=color:#a6e22e>node</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>stack</span>[len(<span style=color:#a6e22e>stack</span>)<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>]
        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>Left</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
            <span style=color:#a6e22e>stack</span> = append(<span style=color:#a6e22e>stack</span>, <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>Left</span>)
            <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>Left</span> = <span style=color:#66d9ef>nil</span>
            <span style=color:#66d9ef>continue</span>
        }
        <span style=color:#a6e22e>stack</span> = <span style=color:#a6e22e>stack</span>[:len(<span style=color:#a6e22e>stack</span>)<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>]
        <span style=color:#a6e22e>result</span> = append(<span style=color:#a6e22e>result</span>, <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>Val</span>)
        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>Right</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
            <span style=color:#a6e22e>stack</span> = append(<span style=color:#a6e22e>stack</span>, <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>Right</span>)
            <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>Right</span> = <span style=color:#66d9ef>nil</span>
        }
    }
    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>result</span>
}
</code></pre></div></div></label></div></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><nav id=TableOfContents><ul><li><a href=#二叉树-binary-tree>二叉树 binary tree</a></li></ul></nav></aside></main></body></html>