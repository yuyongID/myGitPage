'use strict';(function(){const indexCfg={cache:true};indexCfg.doc={id:'id',field:['title','content'],store:['title','href','section'],};const index=FlexSearch.create('balance',indexCfg);window.bookSearchIndex=index;index.add({'id':0,'href':'/myWiki/docs/docker/docker-learn/','title':"Docker Learn",'section':"Docker",'content':"docker learn test #  "});index.add({'id':1,'href':'/myWiki/docs/go-language/go-notes/','title':"Go Notes",'section':"go 语言",'content':"一些笔记 #  1\u0026lt;\u0026lt;31 // 2的31次方 "});index.add({'id':5,'href':'/myWiki/docs/arithmetic/example/bitoperation/','title':"位运算 bit operation",'section':"栗子🌰",'content':"位运算 bit operation #   IP 到 CIDR ...  #!/usr/bin/env python # -*- coding: utf-8 -*- def ipToCIDR(ip, range): \u0026#34;\u0026#34;\u0026#34; :type ip: str :type range: int :rtype: List[str] \u0026#34;\u0026#34;\u0026#34; ipInt = ipToInt(ip) ans = [] x = 0 while x \u0026lt; range: zeros = countZeros(ipInt + x) while x + (1\u0026lt;\u0026lt;zeros) \u0026gt; range: zeros -= 1 ans.append(intToIp(ipInt + x) + \u0026#34;/\u0026#34; + str(32 - zeros)) x += 1\u0026lt;\u0026lt;zeros return ans def ipToInt(ip): ans = 0 for idx, part in enumerate(ip.split(\u0026#39;.\u0026#39;)[::-1]): ans += int(part) \u0026lt;\u0026lt; idx * 8 return ans def intToIp(ipInt): ans = [] for x in xrange(4): ans.append((ipInt \u0026gt;\u0026gt; x * 8) \u0026amp; 255) return \u0026#39;.\u0026#39;.join(map(str, ans[::-1])) def countZeros(ip): cnt = 0 while ip: if ip \u0026amp; 1: break cnt += 1 ip \u0026gt;\u0026gt;= 1 return cnt if __name__ == \u0026#39;__main__\u0026#39;: print(ipToCIDR(\u0026#34;255.0.0.7\u0026#34;, 11))      只出现一次的数字 ...  答案是使用位运算。对于这道题，可使用异或运算 ⊕。异或运算有以下三个性质。\n 任何数和 0 做异或运算，结果仍然是原来的数，即 a⊕0=a。 任何数和其自身做异或运算，结果是 0，即 a⊕a=0。 异或运算满足交换律和结合律，即 a⊕b⊕a=b⊕a⊕a=b⊕(a⊕a)=b⊕0=b。  func singleNumber(nums []int) int { single := 0 for _, num := range nums { single ^= num } return single }     "});index.add({'id':8,'href':'/myWiki/docs/arithmetic/example/linkedlist/','title':"链表 linked list",'section':"栗子🌰",'content':"链表 linked list #   合并两个有序列表 ...  /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode { result := \u0026amp;ListNode{} preHead := result for (l1 != nil \u0026amp;\u0026amp; l2 != nil){ if l1.Val \u0026lt; l2.Val { preHead.Next = l1 l1 = l1.Next } else { preHead.Next = l2 l2 = l2.Next } preHead = preHead.Next } if l1 == nil{ preHead.Next = l2 } if l2 == nil { preHead.Next = l1 } return result.Next }     "});index.add({'id':9,'href':'/myWiki/docs/arithmetic/leetcoderanking/','title':"高频题目",'section':"算法与数据结构",'content':"LeetCode 的高频题目 #  链表 linked list #   合并两个有序链表  位运算 bit operation #   IP 到 CIDR 只出现一次的数字  "});})();