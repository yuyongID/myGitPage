'use strict';(function(){const indexCfg={cache:true};indexCfg.doc={id:'id',field:['title','content'],store:['title','href','section'],};const index=FlexSearch.create('balance',indexCfg);window.bookSearchIndex=index;index.add({'id':0,'href':'/myWiki/docs/docker/docker-learn/','title':"Docker Learn",'section':"Docker",'content':"docker learn test #  "});index.add({'id':1,'href':'/myWiki/docs/go-language/go-notes/','title':"Go Notes",'section':"go è¯­è¨€",'content':"ä¸€äº›ç¬”è®° #  1\u0026lt;\u0026lt;31 // 2çš„31æ¬¡æ–¹ "});index.add({'id':5,'href':'/myWiki/docs/arithmetic/example/bitoperation/','title':"ä½è¿ç®— bit operation",'section':"æ —å­ğŸŒ°",'content':"ä½è¿ç®— bit operation #   IP åˆ° CIDR ...  #!/usr/bin/env python # -*- coding: utf-8 -*- def ipToCIDR(ip, range): \u0026#34;\u0026#34;\u0026#34; :type ip: str :type range: int :rtype: List[str] \u0026#34;\u0026#34;\u0026#34; ipInt = ipToInt(ip) ans = [] x = 0 while x \u0026lt; range: zeros = countZeros(ipInt + x) while x + (1\u0026lt;\u0026lt;zeros) \u0026gt; range: zeros -= 1 ans.append(intToIp(ipInt + x) + \u0026#34;/\u0026#34; + str(32 - zeros)) x += 1\u0026lt;\u0026lt;zeros return ans def ipToInt(ip): ans = 0 for idx, part in enumerate(ip.split(\u0026#39;.\u0026#39;)[::-1]): ans += int(part) \u0026lt;\u0026lt; idx * 8 return ans def intToIp(ipInt): ans = [] for x in xrange(4): ans.append((ipInt \u0026gt;\u0026gt; x * 8) \u0026amp; 255) return \u0026#39;.\u0026#39;.join(map(str, ans[::-1])) def countZeros(ip): cnt = 0 while ip: if ip \u0026amp; 1: break cnt += 1 ip \u0026gt;\u0026gt;= 1 return cnt if __name__ == \u0026#39;__main__\u0026#39;: print(ipToCIDR(\u0026#34;255.0.0.7\u0026#34;, 11))      åªå‡ºç°ä¸€æ¬¡çš„æ•°å­— ...  ç­”æ¡ˆæ˜¯ä½¿ç”¨ä½è¿ç®—ã€‚å¯¹äºè¿™é“é¢˜ï¼Œå¯ä½¿ç”¨å¼‚æˆ–è¿ç®— âŠ•ã€‚å¼‚æˆ–è¿ç®—æœ‰ä»¥ä¸‹ä¸‰ä¸ªæ€§è´¨ã€‚\n ä»»ä½•æ•°å’Œ 0 åšå¼‚æˆ–è¿ç®—ï¼Œç»“æœä»ç„¶æ˜¯åŸæ¥çš„æ•°ï¼Œå³ aâŠ•0=aã€‚ ä»»ä½•æ•°å’Œå…¶è‡ªèº«åšå¼‚æˆ–è¿ç®—ï¼Œç»“æœæ˜¯ 0ï¼Œå³ aâŠ•a=0ã€‚ å¼‚æˆ–è¿ç®—æ»¡è¶³äº¤æ¢å¾‹å’Œç»“åˆå¾‹ï¼Œå³ aâŠ•bâŠ•a=bâŠ•aâŠ•a=bâŠ•(aâŠ•a)=bâŠ•0=bã€‚  func singleNumber(nums []int) int { single := 0 for _, num := range nums { single ^= num } return single }     "});index.add({'id':8,'href':'/myWiki/docs/arithmetic/example/linkedlist/','title':"é“¾è¡¨ linked list",'section':"æ —å­ğŸŒ°",'content':"é“¾è¡¨ linked list #   åˆå¹¶ä¸¤ä¸ªæœ‰åºåˆ—è¡¨ ...  /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode { result := \u0026amp;ListNode{} preHead := result for (l1 != nil \u0026amp;\u0026amp; l2 != nil){ if l1.Val \u0026lt; l2.Val { preHead.Next = l1 l1 = l1.Next } else { preHead.Next = l2 l2 = l2.Next } preHead = preHead.Next } if l1 == nil{ preHead.Next = l2 } if l2 == nil { preHead.Next = l1 } return result.Next }     "});index.add({'id':9,'href':'/myWiki/docs/arithmetic/leetcoderanking/','title':"é«˜é¢‘é¢˜ç›®",'section':"ç®—æ³•ä¸æ•°æ®ç»“æ„",'content':"LeetCode çš„é«˜é¢‘é¢˜ç›® #  é“¾è¡¨ linked list #   åˆå¹¶ä¸¤ä¸ªæœ‰åºé“¾è¡¨  ä½è¿ç®— bit operation #   IP åˆ° CIDR åªå‡ºç°ä¸€æ¬¡çš„æ•°å­—  "});})();