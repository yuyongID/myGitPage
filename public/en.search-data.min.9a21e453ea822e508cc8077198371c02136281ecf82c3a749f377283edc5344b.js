'use strict';(function(){const indexCfg={cache:true};indexCfg.doc={id:'id',field:['title','content'],store:['title','href','section'],};const index=FlexSearch.create('balance',indexCfg);window.bookSearchIndex=index;index.add({'id':0,'href':'/myWiki/docs/docker/docker-learn/','title':"Docker Learn",'section':"Docker",'content':"docker learn test #  "});index.add({'id':4,'href':'/myWiki/docs/go-language/go-notes/','title':"go 语言一些笔记",'section':"go 语言",'content':"一些笔记 #  1\u0026lt;\u0026lt;31 // 2的31次方 "});index.add({'id':5,'href':'/myWiki/docs/arithmetic/example/bitoperation/','title':"位运算 bit operation",'section':"栗子🌰",'content':"位运算 bit operation #   IP 到 CIDR ...  #!/usr/bin/env python # -*- coding: utf-8 -*- def ipToCIDR(ip, range): \u0026#34;\u0026#34;\u0026#34; :type ip: str :type range: int :rtype: List[str] \u0026#34;\u0026#34;\u0026#34; ipInt = ipToInt(ip) ans = [] x = 0 while x \u0026lt; range: zeros = countZeros(ipInt + x) while x + (1\u0026lt;\u0026lt;zeros) \u0026gt; range: zeros -= 1 ans.append(intToIp(ipInt + x) + \u0026#34;/\u0026#34; + str(32 - zeros)) x += 1\u0026lt;\u0026lt;zeros return ans def ipToInt(ip): ans = 0 for idx, part in enumerate(ip.split(\u0026#39;.\u0026#39;)[::-1]): ans += int(part) \u0026lt;\u0026lt; idx * 8 return ans def intToIp(ipInt): ans = [] for x in xrange(4): ans.append((ipInt \u0026gt;\u0026gt; x * 8) \u0026amp; 255) return \u0026#39;.\u0026#39;.join(map(str, ans[::-1])) def countZeros(ip): cnt = 0 while ip: if ip \u0026amp; 1: break cnt += 1 ip \u0026gt;\u0026gt;= 1 return cnt if __name__ == \u0026#39;__main__\u0026#39;: print(ipToCIDR(\u0026#34;255.0.0.7\u0026#34;, 11))      只出现一次的数字 ...  答案是使用位运算。对于这道题，可使用异或运算 ⊕。异或运算有以下三个性质。\n 任何数和 0 做异或运算，结果仍然是原来的数，即 a⊕0=a。 任何数和其自身做异或运算，结果是 0，即 a⊕a=0。 异或运算满足交换律和结合律，即 a⊕b⊕a=b⊕a⊕a=b⊕(a⊕a)=b⊕0=b。  func singleNumber(nums []int) int { single := 0 for _, num := range nums { single ^= num } return single }     "});index.add({'id':6,'href':'/myWiki/docs/arithmetic/example/string/','title':"字符串 string",'section':"栗子🌰",'content':"字符串 string #   整数反转 ...  直接使用 hash map 作为索引会比较省事\nfunc romanToInt(s string) int { tranMap := map[string]int { \u0026#34;I\u0026#34;: 1, \u0026#34;V\u0026#34;: 5, \u0026#34;X\u0026#34;: 10, \u0026#34;L\u0026#34;: 50, \u0026#34;C\u0026#34;: 100, \u0026#34;D\u0026#34;: 500, \u0026#34;M\u0026#34;: 1000, \u0026#34;IV\u0026#34;: 4, \u0026#34;IX\u0026#34;: 9, \u0026#34;XL\u0026#34;: 40, \u0026#34;XC\u0026#34;: 90, \u0026#34;CD\u0026#34;: 400, \u0026#34;CM\u0026#34;: 900, } sList := strings.Split(s, \u0026#34;\u0026#34;) result := 0 for i:=0;i\u0026lt;len(sList);i++ { if i == len(sList) -1 { result = result + tranMap[sList[i]] continue } if v, ok := tranMap[sList[i]+sList[i+1]];ok{ result = result + v i = i + 1 continue } result = result + tranMap[sList[i]] } return result }     "});index.add({'id':7,'href':'/myWiki/docs/arithmetic/example/mathematics/','title':"数学 mathematics",'section':"栗子🌰",'content':"数学 mathematics #   整数反转 ...  func reverse(x int) int { y := 0 for x != 0 { y = y*10 + x%10 x = x/10 } if y \u0026lt; -(1\u0026lt;\u0026lt;31) || y \u0026gt; (1\u0026lt;\u0026lt;31)-1 { return 0 } return y }     "});index.add({'id':8,'href':'/myWiki/docs/arithmetic/example/array/','title':"数组 array",'section':"栗子🌰",'content':"数组 array #   两数之和 ...  func twoSum(nums []int, target int) []int { result := map[int]int{} for i:=0;i\u0026lt;len(nums);i++{ if k, exist := result[target-nums[i]];exist { fmt.Println(k, i) return []int{k, i} } result[nums[i]] = i } return nil }      合并两个有序数组 ...   合并有序数列，不一定从小到大合并，也可以从大到小合并； 第一个数组有空间余量，直接操作比创建新变量空间合适；  func merge(nums1 []int, m int, nums2 []int, n int) { p1 := m-1 p2 := n-1 p3 := m+n-1 for ;p1\u0026gt;=0\u0026amp;\u0026amp;p2\u0026gt;=0;p3--{ if nums1[p1] \u0026lt; nums2[p2] { nums1[p3] = nums2[p2] p2 = p2-1 continue } nums1[p3] = nums1[p1] p1 = p1-1 } for i:=0;i\u0026lt;p2+1;i++{ nums1[i] = nums2[i] } }     "});index.add({'id':11,'href':'/myWiki/docs/arithmetic/example/linkedlist/','title':"链表 linked list",'section':"栗子🌰",'content':"链表 linked list #   合并两个有序列表 ...  /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode { result := \u0026amp;ListNode{} preHead := result for (l1 != nil \u0026amp;\u0026amp; l2 != nil){ if l1.Val \u0026lt; l2.Val { preHead.Next = l1 l1 = l1.Next } else { preHead.Next = l2 l2 = l2.Next } preHead = preHead.Next } if l1 == nil{ preHead.Next = l2 } if l2 == nil { preHead.Next = l1 } return result.Next }     "});index.add({'id':12,'href':'/myWiki/docs/go-language/dev-rule/','title':"面向对象设计原则",'section':"go 语言",'content':"面向对象设计原则 #  依赖倒置原则（DIP）\n 高层模块（稳定）不应该依赖底层模块（变化），二者都应该依赖抽象（稳定） 抽象（稳定）不应该依赖实现细节（变化），实现细节应该依赖于抽象（稳定）  开放封闭原则（OCP）\n 对扩展开放，对更改封闭 类模块应该可以扩展的，但是不可以修改的  单一职责原则（LSP）\n 一个类应该仅有一个引起他变化的原因 变化的方向隐含这类的责任  Liskov替换原则（LSP）\n 子类必须能够替换他们的基类（IS-A） 继承表达类型抽象  接口隔离原则（ISP）\n 不应该强迫客户程序依赖他们不使用的方法 接口应该小而完备  优先使用对象组合，而不是类继承\n 类继承通常为“白箱复用”，对象组合通常为“黑箱复用” 继承在某种程度上破坏了封装性，子类父类耦合度高。 而对象组合则是要求被组合的对象有良好定义的接口，耦合度低。  封装变化点\n 使用封装来创建对象之间的分界层。类设计者可以在分界的一侧进行修改，而不会对另外一侧产生不良的影响。从而实现层次间的松耦合。  针对接口编程，而不是针对实现编程\n 不将变量的类型声明为某个特定的具体类，而声明为某接口； 客户程序无需获知对象的具体类型，只需要知道对象所具有的接口； 减少系统中各部分的依赖关系，从而实现“高内聚，低耦合”  "});index.add({'id':13,'href':'/myWiki/docs/arithmetic/leetcoderanking/','title':"高频题目",'section':"算法与数据结构",'content':"LeetCode 的高频题目 #  位运算 bit operation #   IP 到 CIDR 只出现一次的数字  字符串 string #   罗马数字转整数  数学 mathematics #   整数反转  数组 arrary #   两数之和 合并两个有序数组  链表 linked list #   合并两个有序链表  "});})();